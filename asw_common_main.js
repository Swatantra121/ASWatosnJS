var g_myVar,
    g_context_opened = "N",
    g_area_zoom_ind = "N",
    g_select_zoom_arr = [],
    g_pogjson_backup = [],
    g_pogjson_data_backup = [], //ASA-1914 Issue5.3
    g_default_checkbox,
    g_taskItemInContext1,
    g_pog_edited_ind,
    g_multi_shelf_index = -1,
    g_multi_shelf_ind = "N",
    g_multi_mod_index = "",
    g_multi_shelf_obj_type = "",
    g_multi_shelf_arr = [],
    g_multi_delete_shelf_ind = "N",
    g_multi_delete_done = "N",
    g_clearInfoType = "N",
    g_edit_ind,
    g_db,
    g_fileDownloadCheckTimer,
    g_trs,
    g_object_hit_ind = "O",
    g_temp_cut_arr = [],
    g_multiselect = "N",
    g_taskItemInContext,
    g_errored_items = [],
    g_error_category = "",
    g_mousedown_locx,
    g_auto_position_ind = "N",
    g_hangbar_dft_maxmerch,
    g_pegboard_dft_item_depth,
    g_pdf_online_clck = "N",
    g_dupShelfDepth = 0.1,
    g_auto_fill_active = "N",
    g_mod_block_list = [],
    g_temp_image_arr = [],
    g_pegbrd_auto_placing,
    g_multiItemCopy = "N",
    g_canvas_drag = "N",
    g_mselect_drag = "N",
    g_start_canvas = 1,
    g_present_canvas = 1,
    g_ctrl_select = "N",
    g_dragging = false,
    g_selecting = false,
    g_product_list_drag = "N",
    g_item_edit_flag = "N",
    g_dblclick_opened = "N",
    g_pogcr_pdf_chest_split,
    g_minvalue = 0.01,
    g_nodataModuleName,
    g_lr_overhung,
    g_pog_json_comp,
    g_new_canvas,
    g_fileUploadFlag = "N",
    g_shelf_index = -1,
    g_module_index = 0,
    g_final_x = 0,
    g_final_y = 0,
    g_final_z = 0,
    g_wireframe_id,
    g_isBookend = "N",
    g_shelf_object_type,
    g_movedObjID = -1,
    g_objectHit_id,
    g_lines = [], // for function fitText
    g_peg_holes_active = "Y",
    g_module_width,
    g_world_pdf,
    g_dblclick_objid,
    g_compare_pog_flag = "N",
    g_ComViewIndex = -1,
    g_ComBaseIndex = -1,
    g_compare_view = "NONE",
    g_slope = 0,
    g_manual_zoom_ind = "N",
    g_show_fixel_label = "N",
    g_edit_pallet_shelfid = -1,
    g_show_notch_label = "N",
    g_shelf_edit_flag = "N",
    g_show_item_label = "N",
    g_show_peg_tags = "N",
    g_carpark_item_flag = "N",
    g_ItemImages = [],
    g_auto_cal_depth_fac = "N", //ASA-1255
    g_deletedItems = [],
    g_l_module_dir,
    g_l_direction,
    g_l_ignore,
    g_l_order_type,
    g_l_start_one_mod,
    g_l_include_mod_name,
    g_l_separator,
    g_l_leading_text,
    g_l_trailing_text,
    g_l_start_one_mod_loc,
    g_l_start_one_fixel,
    g_keyCode = 0,
    g_cutaway_cam_detail = [],
    g_prev_undo_action = "NONE",
    g_duplicate_fixel_flag = "N",
    g_shelf_basket_spread = "",
    g_carpark_items = [],
    g_show_days_of_supply,
    g_get_orient_images,
    g_drag_shelf_notch,
    g_show_notch_label_comp = "N",
    g_cut_loc_arr = [],
    g_undo_obj_arr = [],
    g_undo_supp_obj_arr = [],
    g_redo_supp_obj_arr = [],
    g_undoRedoAction,
    g_undo_details = [],
    g_delete_details = [],
    g_undo_all_obj_arr = [],
    g_cut_support_obj_arr = [],
    g_multi_drag_shelf_arr = [],
    g_multi_drag_item_arr = [],
    g_cut_copy_arr = [],
    g_redo_all_obj_arr = [],
    g_multi_copy_done = "N",
    g_redo_final_obj_arr = [],
    g_curr_canvas = 1,
    g_pog_index = -1,
    g_auto_fill_reg_open = "N",
    g_comp_view_code = "",
    g_comp_base_code = "",
    g_productselect = "N",
    g_scene_objects_backup = [],
    g_labelFont = 16,
    g_validationFlag = "Y",
    g_cut_action_done = "N",
    g_copy_action_done = "N",
    g_dup_action_done = "N",
    g_delete_action_done = "N",
    g_labelActualSize = 0.055,
    g_status_error_color,
    g_offset_z,
    g_pegbrd_auto_placing = "N",
    g_edited_item_index = -1,
    g_upload_file_flag = "N",
    g_drag_items_arr = [],
    g_itemDragZ = 0,
    g_allUndoObjectsInfo = [],
    g_dup_mod_list = [],
    g_pog_json_data = [],
    g_dft_max_merch = 0, //ASA1310_20240307 crush item onload
    //g_pegboard,global variables to be removed and changed to local
    //g_shelf,
    //g_module,
    //g_notches1,
    //g_notches2,
    g_temp_POG_arr,
    g_textbox_merge_pdf,
    g_auto_hangbar_facings,
    g_auto_apply_v_facings,
    g_auto_apply_d_facings,
    g_windowHeight,
    g_windowWidth,
    g_tanFOV,
    g_undo_final_obj_arr = [],
    g_rotation = 0,
    g_show_live_image = "N",
    g_show_item_desc = "N",
    g_module_obj_array = [],
    g_all_pog_flag = "N",
    g_temp_desc = "N",
    g_drag_x,
    g_drag_z,
    g_targetForDragging, // An invisible object that is used as the target for raycasting while
    g_dim_error_color,
    g_dbuDebugEnabled = sessionStorage.getItem("g_dbuDebugEnabled"),
    g_pogBackup = [],
    g_errorRaisedFlag = "N",
    g_openChooseColor = false,
    g_scene_pdf,
    g_camera_pdf,
    g_renderer_pdf,
    g_nonMovingItemColor = parseInt("#9F2B68".replace("#", "0x"), 16),
    g_pogcr_auto_hlite_non_mv_item,
    g_show_item_desc_comp = "N",
    g_show_live_image_comp = "N",
    g_raycaster, // A THREE.Raycaster for user mouse input.
    g_camera_comp,
    g_world_comp,
    g_show_desc_no_image,
    g_caption_text = "",
    g_intersected = [],
    g_notch_label_position,
    g_edit_pallet_mod_ind = -1,
    g_edit_pallet_shelf_ind = -1,
    g_open_productlist = "Y",
    g_delete_item_json = [],
    g_combinedShelfs = [], //ASA-1129
    g_combineItemModf = [], //ASA-1129
    g_overhung_validation,
    g_seqArr = [],
    g_seqArrDtl = {},
    g_renum_json = [],
    g_multi_pog_json = [],
    g_overhung_shelf_active = "N",
    g_ispog_savingerror = "N",
    g_counting = 0,
    g_pog_saving_error_msg = "N",
    g_canvas,
    g_canvas_region,
    g_scene,
    g_renderer,
    g_camera,
    g_select_color = 0x000000,
    g_orientation_json,
    g_start_pixel_ratio,
    g_selection,
    g_scene_objects = [],
    g_canvas_objects = [],
    g_json = [],
    g_world,
    g_pog_json = [],
    g_fixel_label = "N",
    g_vert_text_dis = 0,
    g_pog_list = [],
    g_objectHit_uuid,
    g_global_counter = 0,
    g_intersects,
    g_start_coorX,
    g_start_coorY,
    g_objectHit,
    g_chest_as_pegboard = "N",
    g_lastSelectedRow,
    g_dragItem,
    g_draftPogInd = "",
    g_finalY = -1,
    g_prevX = 0,
    g_recal_compare = "N", //asa-1170
    g_prevY = 0,
    g_isPogItemsSet = "N",
    g_colorBackup = "N",
    g_imagesShown = "N",
    g_imagesShownComp = "N",
    g_validationAlert = "N",
    g_prevKeyPressed = 0,
    g_max_facing_enabled = "N",
    g_item_index,
    g_current_div_index = "",
    g_incre_mod_index,
    g_incre_shelf_index,
    g_incre_item_index,
    g_status_bar = [],
    g_shelf_max_merch,
    g_itemDragX = -1,
    g_drag_inprogress = "N",
    g_module_X,
    g_module_cnt,
    g_module_edit_flag = "N",
    g_carpark_edit_flag = "N",
    g_show_max_merch = "N",
    g_show_item_color = "N",
    g_show_fixel_space,
    g_pog_refresh_msg = get_message("POG_SAVE_SUCCESS_MSG"),
    g_pog_draft_save_msg = get_message("SAVE_DRAFT_SUCESS_MSG"),
    g_delete_success_msg = get_message("DELETE_SUCCESS_MSG"),
    g_pog_success_msg = get_message("SAVE_POG_SUCESS_MSG"),
    g_atleast_one_pog = get_message("ATLEAST_ONE_POG"),
    g_expand_all_pog = get_message("POGCR_EXPAND_ALL_POG"),
    g_msg_na = get_message("POGCR_MSG_NA"), //ASA-1407 Task 1 -S
    g_msg_h = get_message("POGCR_MSG_H"),
    g_msg_w = get_message("POGCR_MSG_W"),
    g_msg_d = get_message("POGCR_MSG_D"),
    g_msg_Sq = get_message("POGCR_MSG_SQ"),
    g_msg_unit = get_message("POGCR_MSG_UNIT"),
    g_msg_dollar = get_message("POGCR_MSG_DOLLAR"), //ASA-1407 Task 1 -E
    g_itemSubLabelInd = "N",
    g_itemSubLabel = "",
    g_shelf_details = [],
    g_color_arr = [],
    g_highlightArr = [],
    g_duplicating = "N",
    g_autofill_edit = "N",
    g_show_error = true,
    g_invalidPosition = "N",
    g_pogcr_live_new_item = "N",
    g_shift_mutli_item_select = "N", //ASA-1422
    g_shift_multi_item_first = {}, //ASA-1422
    g_shift_multi_item_last = {}, //ASA-1422
    g_multi_select_offset_perc = 0, //ASA-1422
    g_hide_show_dos_label = "", //ASA-1427
    g_itemInfoFileIndex = 0, //ASA-1446
    g_sublabel_type = "", //ASA-1533
    g_toFixedValue, //ASA-1472
    g_show_plano_rate = "N", //ASA-1587
    g_product_list_blink = "N", //ASA-1640
    g_multi_cnvs_drag_conf = "N", //ASA-1640
    g_item_stack_valid = "Y", //ASA-1652
    g_item_shelf_updated_msg = get_message("POGCR_ITEM_FIXEL_UPD"), //ASA-1669
    g_is_pog_template_open = "N", //ASA-1694
    g_autofill_detail = {}, //ASA-1694
    g_wf_pog_approval_enabled = "", //Regression 5 20250217
    g_pogcr_pog_approval_for_new_pog = "", //Regression 5 20250217
    g_pogcr_enbl_oos_border, //ASA-1688
    g_pogcr_oos_border_color, //ASA-1688
    g_pogcr_enhance_textbox_fontsize, //ASA-1787 
    g_is_pog_maximize = "N", // ASA-1898 
    g_textbox_dragged = "N", // ASA-2000.15
    g_edit_textboxZ = ""; //ASA-2029.1.4
var g_autofillModInfo = [],
    g_autofillShelfInfo = []; //ASA-1697
    g_item_vertical_text_display = "Y", //ASA-1847 4.1
    g_item_text_center_align = "Y"; //ASA-1847 4.1
var g_DragMouseStart = new THREE.Vector2();
var g_DragMouseEnd = new THREE.Vector2();
var g_mouse = new THREE.Vector2();
var g_startMouse = new THREE.Vector2();
var g_prevMouse = new THREE.Vector2();
var g_nextMouse = new THREE.Vector2();
var g_allowItemSort = "Y"; //ASA-1970 Issue1

//Getting request animation frame for different browsers.
window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame;
//ASA-1472
//Global function to handle to Fixed and its defaulted to 5 decimal points now.
function wpdSetFixed(p_num) {
    try {
        if (typeof p_num == "string") {
            p_num = parseFloat(p_num);
        }
        return parseFloat(nvl(p_num).toFixed(g_toFixedValue));
    } catch (err) {
        error_handling(err);
    }
}
//ASA-1472
function wpdGetFixed(p_fixedValue) {
    try {
        g_toFixedValue = p_fixedValue;
    } catch (err) {
        error_handling(err);
    }
}
wpdGetFixed(5); //ASA-1472

//Setting mouse events on each canvas created in the screen. Setting all
function setUpMouseHander(p_element, p_mouseDownFunc, p_mouseDragFunc, p_mouseUpFunc, p_mouseDoubleclick, p_canvas) {
    logDebug("function : setUpMouseHander", "S");
    if (!p_element || !p_mouseDownFunc || !(typeof p_mouseDownFunc == "function")) {
        throw "Illegal arguments in setUpMouseHander";
    }
    if (typeof p_element == "string") {
        p_element = document.getElementById(p_element);
    }
    if (!p_element || !p_element.addEventListener) {
        throw "first argument in setUpMouseHander is not a valid element";
    }

    var startX, startY;
    var prevX, prevY;
    //var header = document.getElementById("t_Header");//not used in the function so commented.
    //var breadcrumb = document.getElementById("t_Body_title");
    //var top_bar = document.getElementById("top_bar");

    // ASA 1850
    var lastClickTime = 0;
    var clickThreshold = $v("P25_POG_DELAY_TIME_IN_MS");
    var moveThreshold = 10;
    var isClicking = false;
    var side_nav = document.getElementById("t_Body_nav");
    var button_cont = document.getElementById("side_bar");
    var devicePixelRatio = window.devicePixelRatio;
    g_start_pixel_ratio = devicePixelRatio;
    //var header_height = header.offsetHeight * devicePixelRatio;
    // var breadcrumb_height = breadcrumb.offsetHeight * devicePixelRatio;
    //var top_bar_height = top_bar.offsetHeight * devicePixelRatio;
    var side_nav_width = side_nav.offsetWidth * devicePixelRatio;
    var btn_cont_width = button_cont.offsetWidth * devicePixelRatio;

    function doMouseDown(evt) {
        if (g_dragging) {
            //When user is dragging any object mousedown should not work. only mousemove will work.
            return;
        }

        // ASA 1850
        var currentTime = Date.now();
        var timeDiff = currentTime - lastClickTime;
        isClicking = (timeDiff < clickThreshold);
        lastClickTime = currentTime;

        if (window.event.which == 1 && g_scene_objects.length > 0) {
            set_curr_canvas(evt); //set all the default values of global variables like g_pog_index, g_show_live_image etc for specific canvas selected.
            if (g_scene_objects.length > 0) {
                var r = p_canvas.getBoundingClientRect(); //getting mesurements of the canvas element where mouse is placed.
                //console.log("r.left", r.left, r.top);
                var start_x = r.left;
                var start_y = r.top;
                var x = evt.clientX - r.left; //  - (side_nav_width + btn_cont_width);
                var y = evt.clientY - r.top; //  - (header_height + breadcrumb_height + top_bar_height);
                //console.log("evt.clientX ", evt.clientX, evt.clientY, "r left ", r.left, r.top, " xy ", x, y, side_nav_width, btn_cont_width);
                prevX = startX = x;
                prevY = startY = y;

                //caling doMouseDown function, after mouse down when this function finds a object and recognise it and it is a valid object to be dragged, the g_dragging will be true.
                // ASA 1850 Start dragging if not in click-only mode
                if (!isClicking) {
                    g_dragging = p_mouseDownFunc(x, y, r.left, r.top, evt, p_canvas, "N", g_pog_index);
                }
            }
        }
    }

    function doMouseMove(evt) {
        if (isClicking) { return; } //ASA 1850  
        if (p_mouseDragFunc) {
            set_curr_canvas(evt); //set all the default values of global variables like g_pog_index, g_show_live_image etc for specific canvas selected.
            var jselector = p_canvas.getAttribute("id");
            var l_new_canvas = p_canvas;
            var pPogIndex = l_new_canvas.getAttribute("data-indx"); //getting the pog_index from the canvas element attribute.
            var new_camera = g_camera;

            if (evt.target.nodeName == "CANVAS" && typeof g_scene_objects[pPogIndex] !== "undefined") {
                l_new_canvas = evt.target;
                pPogIndex = l_new_canvas.getAttribute("data-indx");
                if (g_scene_objects.length > 0) {
                    new_camera = g_scene_objects[pPogIndex].scene.children[0];
                }
            } else {
                l_new_canvas = evt.target;
                pPogIndex = 0;
                new_camera = g_camera;
            }

            var r = l_new_canvas.getBoundingClientRect();
            var obj_height = r.height;
            var x = evt.clientX - r.left; // - (side_nav_width + btn_cont_width);
            var y = evt.clientY - r.top; // - (header_height + breadcrumb_height + top_bar_height);

            // ASA 1850 Only drag if movement exceeds threshold
            var dx = Math.abs(x - startX);
            var dy = Math.abs(y - startY);
            if (!g_dragging || dx > moveThreshold || dy > moveThreshold || g_pog_json.length > 1) { //ASA-1914 Issue6
                const fromX = g_dragging ? prevX : x;
                const fromY = g_dragging ? prevY : y;
                p_mouseDragFunc(x, y, evt, fromX, fromY, l_new_canvas, new_camera, jselector, pPogIndex);
            }
            prevX = x;
            prevY = y;
        }
    }
    //when user tries to drop a object in specific location or click on a item and want to perform some action or multi select and drop.
    function doMouseUp(evt) {
        if (g_dragging) {
            set_curr_canvas(evt);
            if (p_mouseUpFunc && g_scene_objects.length > 0) {
                var r = p_canvas.getBoundingClientRect();
                var x = evt.clientX - r.left;
                var y = evt.clientY - r.top;
                //double click event is used only to find the object on which user did double click and open its details in popup like product details, fixel details popup etc.
                p_mouseUpFunc(x, y, evt, prevX, prevY, p_canvas, g_camera, g_pog_index);
            }
            g_dragging = false;
        }
    }

    function doMouseDoubleclick(evt) {
        set_curr_canvas(evt);
        if (g_scene_objects.length > 0) {
            var r = p_canvas.getBoundingClientRect();
            var x = evt.clientX - r.left;
            var y = evt.clientY - r.top;
            p_mouseDoubleclick(x, y, startX, startY, evt, p_canvas, g_camera, g_pog_index);
        }
        isClicking = false; //  ASA 1850 reset after double click
    }
    //adding event listners to specific canvas. in WPD there can be multiple canvas opened in same screen.
    p_canvas.addEventListener("mousemove", doMouseMove);
    p_canvas.addEventListener("mouseup", doMouseUp);
    p_canvas.addEventListener("mousedown", doMouseDown);
    p_canvas.addEventListener("dblclick", doMouseDoubleclick);

    logDebug("function : setUpMouseHander", "E");
}


function limited_animate(p_scene, p_camera, p_pog_index) {
    try {
        if (g_counting < 5) {
            //We intend to call requestanimateframe only 5 times because requestanimationframe runs approx 170 frames per sec.
            g_counting = g_counting + 1; //increment with 1 so that function can stop calling when it reaches 5.
            if (g_renderer !== null && typeof p_pog_index !== "undefined") {
                //If we have p_pog_index then we need to render specific scene only.
                if (g_canvas_objects[p_pog_index].getContext("2d") !== null) {
                    //This inside block will use single renderer to render different canvases to avoid restriction on no of renderers in
                    //browser. we take the context of the canvas object and drawimage using the renderer.
                    var context = g_canvas_objects[p_pog_index].getContext("2d"); //Getting context of the specific canvas.
                    g_renderer.setPixelRatio(window.devicePixelRatio);
                    var canvas_width = g_canvas_objects[p_pog_index].width;
                    var canvas_height = g_canvas_objects[p_pog_index].height;

                    g_renderer.setSize(canvas_width, canvas_height);
                    g_scene_objects[p_pog_index].scene.children[0].aspect = canvas_width / canvas_height;
                    g_renderer.render(g_scene_objects[p_pog_index].scene, g_scene_objects[p_pog_index].scene.children[0]);
                    if (context !== null) {
                        context.drawImage(g_renderer.domElement, 0, 0, canvas_width, canvas_height); //this will draw the 3D objects on the canvas.
                    }
                    requestAnimationFrame(function () {
                        //This will call the same function again after first frame.
                        limited_animate(g_scene_objects[p_pog_index].scene, g_scene_objects[p_pog_index].scene.children[0], p_pog_index);
                    });
                } else if (g_renderer !== null) {
                    //if p_pog_index is not sent then only render the scene sent inside the function.
                    g_renderer.render(p_scene, p_camera);
                    requestAnimationFrame(function () {
                        limited_animate(p_scene, p_camera, p_pog_index);
                    });
                }
            } else if (g_renderer !== null) {
                //Directly render the scene which is been sent as parameter.
                g_renderer.render(p_scene, p_camera);
                requestAnimationFrame(function () {
                    limited_animate(p_scene, p_camera, p_pog_index);
                });
            }
        } else {
            g_counting = 0;
        }
    } catch (err) {
        error_handling(err);
    }
}

//this is basically used when we have images to be rendered. because when you call only render() function. image does not display at single rendering.
function animate_pog(p_pog_index) {
    try {
        if (typeof g_scene_objects !== undefined && g_scene_objects.length > 0) {
            requestAnimationFrame(function () {
                limited_animate(g_scene_objects[p_pog_index].scene, g_scene_objects[p_pog_index].scene.children[0], p_pog_index);
            });
        }
    } catch (err) {
        error_handling(err);
    }
}
//This function is used only in PDF generation example set_scene function.
function animate_pog_pdf() {
    try {
        requestAnimationFrame(function () {
            limited_animate(g_scene_pdf, g_camera_pdf);
        });
    } catch (err) {
        error_handling(err);
    }
}

//getting json from ajax the list of posible orientations of the item and its details.
async function load_orientation_json() {
    //task_26897 Regression 1
    logDebug("function : load_orientation_json");
    return new Promise(function (resolve, reject) {
        apex.server.process(
            "LOAD_ORIENTATION_JSON",
            {},
            {
                dataType: "text",
                success: function (pData) {
                    g_orientation_json = JSON.parse(pData);
                    resolve(g_orientation_json);
                },
            }
        );
    });
}
//This function is only used in "Where is it" screen and calling for each POG in loop. file (asw_common_additional.js)
function init_lib(p_renderer_ind, p_event_ind, p_window_evnt_ind, p_pog_index) {
    try {
        g_canvas_region = document.getElementById("drawing_region");
        g_selection = document.getElementById("selection");
        if (p_renderer_ind == "Y") {
            g_renderer = new THREE.WebGLRenderer({
                canvas: g_canvas, //g_canvas variable is already set from getelementbyid in page 27
                antialias: true,
                preserveDrawingBuffer: true,
            });
        }

        g_canvas_objects.push(g_canvas); //This array is used to hold all canvas when multiple pog opened in WPD.
    } catch (e) {
        document.getElementById("canvas-holder").innerHTML = "<p><b>Sorry, an error occurred:<br>" + e + "</b></p>";
        return;
    }
    createWorld(); //This function creats scene and camera and populate g_scene_objects array.
    g_raycaster = new THREE.Raycaster(); //This is a method that will trace the world object that hit on any specific point. to get the world coordinates.
    render(0);
    var devicePixelRatio = window.devicePixelRatio;
    g_start_pixel_ratio = devicePixelRatio;
    var windowWidth = window.innerWidth;
    g_windowHeight = window.innerHeight;
    if (p_event_ind == "Y") {
        //Mouse events are assigned to specific dom element events: mousedown, mousemove, mouseup, mousedoubleclick
        setUpMouseHander("maincanvas", doMouseMove, doMouseDown, doMouseUp, g_renderer, p_pog_index);
    }
    g_tanFOV = Math.tan(((Math.PI / 180) * g_camera.fov) / 2);
    g_initial_windowHeight = window.innerHeight;
    g_camera.aspect = windowWidth / g_windowHeight;

    // adjust the FOV based on the window height to fit the canvas inside the window.
    g_camera.fov = (360 / Math.PI) * Math.atan(g_tanFOV * (g_windowHeight / g_initial_windowHeight));

    g_camera.updateProjectionMatrix();
    g_renderer.setSize(windowWidth, g_windowHeight);
    render(0);
    if (p_window_evnt_ind == "Y") {
        //This even set to recreate the POG when browser is zoom in or out. based on new size the POG will be recreated.
        window.addEventListener("resize", onWindowResize_lib, false);
    }
    //We call this function which will only recreate any pog if the devicepixelratio of previous veiw is changed.
    onWindowResize_lib("F");
}

//This function is used to calculate suitable visible height of the camera so that POG is completely visible on the screen.
const visibleHeightAtZDepth = (depth, camera) => {
    // compensate for cameras not positioned at z=0
    const cameraOffset = camera.position.z;
    if (depth < cameraOffset) depth -= cameraOffset;
    else depth += cameraOffset;

    // vertical fov in radians
    const vFOV = (camera.fov * Math.PI) / 180;

    // Math.abs to ensure the result is always positive
    return 2 * Math.tan(vFOV / 2) * Math.abs(depth);
};
//This function is used to set_camera_z function to set suitable z position of the camera. so that POG is completely visible on screen.
const visibleWidthAtZDepth = (depth, camera) => {
    const height = visibleHeightAtZDepth(depth, camera);
    return height * camera.aspect;
};

//This function will return an arry
let findDuplicates = (arr) => arr.filter((item, index) => arr.indexOf(item) != index);

//This function is globally used to sort any array based on any key inside json in asc or desc order.
//Please note: variable with details of sorting to be set and passed when calling keySort. Example as below.
//var sorto = {
//    LocID: "asc",
//};
Array.prototype.keySort = function (keys) {
    keys = keys || {};
    var obLen = function (obj) {
        var size = 0,
            key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) size++;
        }
        return size;
    };
    var obIx = function (obj, ix) {
        var size = 0,
            key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (size == ix) return key;
                size++;
            }
        }
        return false;
    };

    var keySort = function (a, b, d) {
        d = d !== null ? d : 1;
        if (a == b) return 0;
        return a > b ? 1 * d : -1 * d;
    };

    var KL = obLen(keys);

    if (!KL) return this.sort(keySort);

    for (var k in keys) {
        // asc unless desc or skip
        keys[k] = keys[k] == "desc" || keys[k] == -1 ? -1 : keys[k] == "skip" || keys[k] === 0 ? 0 : 1;
    }

    this.sort(function (a, b) {
        var sorted = 0,
            ix = 0;
        while (sorted === 0 && ix < KL) {
            var k = obIx(keys, ix);
            if (k) {
                var dir = keys[k];
                sorted = keySort(a[k], b[k], dir);
                ix++;
            }
        }
        return sorted;
    });
    return this;
};

//This function is used in logDebug function to console log the time any function is called.
function getDateTime() {
    var today = new Date();
    var date = today.getFullYear() + "-" + (today.getMonth() + 1) + "-" + today.getDate();
    var l_time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds() + ":" + today.getMilliseconds();
    var dateTime = date + " " + l_time;
    return dateTime;
}

//This function is added in all the other function start and end. this will log messages in console when g_dbuDebugEnabled = 'Y'.
function logDebug(p_string, p_type) {
    var logType;
    if (p_type == "S") {
        logType = "Start";
    } else {
        logType = "End";
    }
    g_dbuDebugEnabled = "Y";
    if (g_dbuDebugEnabled == "Y") {
        // apex.debug.log(logType + " | " + p_string + " | " + getDateTime());
        console.log(logType + " | " + p_string + " | " + getDateTime());
    }
}

//This function will return the width of the text in pixels. basically used to create status bar.
String.prototype.visualLength = function (id) {
    try {
        var ruler = document.getElementById(id);
        ruler.style.fontSize = "large";
        ruler.innerHTML = this;
        return ruler.offsetWidth;
    } catch (err) {
        error_handling(err);
    }
};

//This function will return the height of the text in pixels. basically used to create status bar.
String.prototype.visualHeight = function (id) {
    try {
        var ruler = document.getElementById(id);
        ruler.style.fontSize = "large";
        ruler.innerHTML = this;
        return ruler.offsetHeight;
    } catch (err) {
        error_handling(err);
    }
};

//This function is used in create_pdf function because after recreate items with image. needs rendering time for items to be visible on screen and then create PDF
function timeout(p_ms) {
    try {
        return new Promise((resolve) => setTimeout(resolve, p_ms));
    } catch (err) {
        error_handling(err);
    }
}

//converting JavaScript strings to ArrayBuffers and vice-versa. Currently not used anywhere.
function s2ab(p_s) {
    var buf = new ArrayBuffer(p_s.length);
    var view = new Uint8Array(buf);
    for (var i = 0; i != p_s.length; ++i) view[i] = p_s.charCodeAt(i) & 0xff;
    return buf;
}

//This will give you current available heap space in browser. Currently not used anywhere.
function get_avail_heap() {
    return performance.memory.jsHeapSizeLimit - performance.memory.totalJSHeapSize;
}

// Validate dimensions for decimal with 2 places (Hardcoded to 2 decimal places as told by TerryI)
function validateDimensions(p_el, p_evt) {
    try {
        logDebug("function : validateDimensions", "S");
        var charCode = p_evt.which ? p_evt.which : event.keyCode;
        var number = p_el.value.split(".");
        if (charCode != 46 && charCode > 31 && charCode !== 45 && (charCode < 48 || charCode > 57)) {
            return false;
        }
        //just one dot
        if (number.length > 1 && charCode == 46) {
            return false;
        }
        //get the carat position
        var caratPos = getSelectionStart(p_el);
        var dotPos = p_el.value.indexOf(".");
        var sysPrmMeterageLength = 2;
        if (caratPos > dotPos && dotPos > -1 && number[1].length > sysPrmMeterageLength - 1) {
            return false;
        }
        logDebug("function : validateDimensions", "E");
        return true;
    } catch (err) {
        error_handling(err);
    }
}

//This function will return hex color value when 0x color code is passed. Currently not used anywhere.
function invertHex(p_hex) {
    try {
        return (Number(`0x1${p_hex}`) ^ 0xffffff).toString(16).substr(1).toUpperCase();
    } catch (err) {
        error_handling(err);
    }
}

//This function will return r,g,b color values when hex color is passed.
function hexToRgb(p_hex) {
    try {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(p_hex);
        return result
            ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16),
            }
            : null;
    } catch (err) {
        error_handling(err);
    }
}

//This function is used when page load to remove the parameters passed in the url, to avoid when again page reload those values are reset and pog which is created will be gone.
function removeParam(p_parameter) {
    try {
        logDebug("function : removeParam; parameter : " + p_parameter, "S");
        var l_url = document.location.href;
        if (l_url.includes("f?p")) {
            var urlparts = l_url.split("?");
            var next_url = "?p=" + $v("pFlowId") + ":" + $v("pFlowStepId") + ":" + $v("pInstance") + ":";

            if (urlparts.length >= 2) {
                window.history.pushState("", document.title, urlparts[0] + next_url);
            }
        } else {
            var matches = l_url.match(/[?](.*)&s/);
            if (matches !== null) {
                if (typeof matches[1] !== "undefined") {
                    var new_url = l_url.replace(matches[1] + "&", "");
                    window.history.pushState("", document.title, new_url);
                }
            }
        }

        logDebug("function : removeParam", "E");
        return l_url;
    } catch (err) {
        logDebug("function : removeParam", "E");
        error_handling(err);
    }
}

// Raise error is modified as it should thorw exception in order to return error message to caller function.
// Function in common JS should be modified after thorough testing
function raise_error(p_message, p_location = "page", p_page_item) {
    console.log("error message ", p_message);
    apex.message.clearErrors();
    var err = new Error();
    var l_prefix_message;
    if (typeof p_message == "string") {
        if (p_message.indexOf("ERROR:") == -1) l_prefix_message = "ERROR:";
        err.message = l_prefix_message + p_message;
        err.stack = l_prefix_message + p_message;
    } else {
        err = p_message;
        if (err.message.indexOf("ERROR:") == -1) l_prefix_message = "ERROR:";
        err.message = l_prefix_message + err.message;
        l_prefix_message = "";
        if (err.stack.indexOf("ERROR:") == -1) l_prefix_message = "ERROR:";
        err.stack = l_prefix_message + err.stack;
    }

    if (g_show_error) {
        if (typeof p_page_item !== "undefined")
            apex.message.showErrors([
                {
                    type: "error",
                    location: p_location,
                    message: p_message,
                },
            ]);
        else
            apex.message.showErrors([
                {
                    type: "error",
                    location: p_location,
                    pageItem: p_page_item,
                    message: p_message,
                },
            ]);
    }
    if (typeof regionloadWait !== "undefined" && typeof regionloadWait.remove == "function") {
        //Task_26601 always giving error when there is no active loading indicator
        removeLoadingIndicator(regionloadWait);
    }
    console.log("raise error function: ", p_message, g_show_error);
    throw err;
}

function isPromise(p) {
    return p && Object.prototype.toString.call(p) === "[object Promise]";
}

//This function is called in all the function in catch part to raise error on screen.
async function error_handling(p_error) {
    console.log("error ", p_error);
    var returnval = await get_format_error(p_error);

    if (returnval) {
        if (typeof returnval == "string") {
            raise_error(returnval);
        } else {
            var error_message;
            returnval
                .then(function (result) {
                    error_message = result;
                    raise_error(error_message);
                })
                .catch(function (result) {
                    error_message = result;
                    raise_error(error_message);
                });
        }
    } else {
        raise_error(p_error.stack);
    }
}

//Getting readable error message and print on screen.
async function get_format_error(p_err) {
    logDebug("function : get_format_error", "S");
    if (typeof p_err == "string") {
        return p_err;
    } else {
        var caller_line = p_err.stack.split("\n");
        var message,
            lineno_arr = [];
        for (i = 0; i < caller_line.length; i++) {
            if (i == 0) {
                var first = caller_line[i];
                message = first.slice(first.lastIndexOf(":") + 1, first.length);
                lineno_arr.push("Exception Occurred, Reverted to previous action.");
                lineno_arr.push(message);
            } else {
                var first = caller_line[i];
                var new_first = first.slice(0, first.lastIndexOf(":"));
                var location;
                var index = first.indexOf(".js");
                if (index !== -1) {
                    location = new_first.slice(new_first.lastIndexOf("/") + 1, new_first.lastIndexOf(":"));
                } else {
                    location = "Page 25";
                }
                lineno_arr.push(new_first.slice(0, new_first.indexOf("(") - 1) + " | " + location + " | " + new_first.slice(new_first.lastIndexOf(":") + 1, new_first.length));
            }
        }
        console.log("error", p_err.stack);
        var res = revertOnError(g_pogBackup, g_pog_index);
        logDebug("function : get_format_error", "E");
        return lineno_arr.join("<br>");
    }
}

//This below click event is used to show a custom drop down of colors.
//This will only work when click object has class t-Icon fa fa-eyedropper
window.addEventListener("click", function (event) {
    if (typeof $(event.path) !== "undefined") {
        logo_clicked = "N";
    }
    if (typeof $(event.target).attr("id") !== "undefined" && $(event.target).attr("class") !== "t-Icon fa fa-eyedropper") {
        if (!$(event.target).attr("id").startsWith("CUSTOM_COLOR")) {
            $("#co-color-list").slideUp("fast", function () {
                $("#co-color-list").css("display", "none");
                g_openChooseColor = false;
            });
        }
    } else if ($(event.target).attr("class") == "t-Icon fa fa-eyedropper") {
        $("#co-color-list").css("display", "block");
        g_openChooseColor = true;
    } else {
        $("#co-color-list").slideUp("fast", function () {
            $("#co-color-list").css("display", "none");
            g_openChooseColor = false;
        });
    }
});

function set_custom_color(p_page_item, p_set_item) {
    try {
        logDebug("function : set_custom_color ; ", "S");
        $.support.cors = true;
        const $button = $("#" + p_page_item);
        const $colorValue = $(".colorValue");
        const $colorDisplay = $(".colorDisplay");

        $($button).sbxColorChoice({
            selecionarCor: (color) => {
                $("#" + p_set_item).val(color);
                $("#" + p_set_item + "_CONTAINER .apex-item-color-picker-preview").css("background-color", color);
            },
            reseteCor: "#FFFFFF",
            event: event,
            setfocus: p_set_item,
        });
        logDebug("function : set_custom_color ; ", "E");
    } catch (err) {
        error_handling(err);
    }
}

//custom standard color picket.
$.fn.sbxColorChoice = function (params) {
    try {
        const { reseteCor, removePallet, event, setfocus, textResetColorButton, selecionarCor } = params;
        const $element = $("#co-color-list");
        //Function that close the component
        const closeChooseColor = (element) => {
            element.slideUp("fast", function () {
                element.css("display", "none");
                g_openChooseColor = false;
                apex.item(setfocus).setFocus();
            });
        };

        // Function that apply the color selected
        const chooseColor = (element, e) => {
            element.find("ul li").click(function () {
                const color = $(this).attr("data-color");
                closeChooseColor(element);
                selecionarCor(color, e);
            });
        };

        // Function that reset color
        const removePalletColor = () => {
            if (removePallet != "" && removePallet != undefined) {
                $("#co-color-list").find(removePallet).remove();
            }
        };

        // Function that add a custom text in reset color button
        const constumResetTextButton = (element) => {
            if (textResetColorButton) {
                element.find(".reset-color-button").html(textResetColorButton);
            }
        };

        // Function that create modal's effect
        const effectModal = (element) => {
            element.slideDown("fast", function () {
                element.focus();
            });
        };

        // Function that mark where the pallet will open
        const positionElement = (element, e) => {
            const $target = $(e.target);
            const $targetPosicao = $target.offset();
            const $targetHeight = $target.height();
            const $targetWdith = $target.width();
            const $screenHeight = $(window).height();
            const $screenWidth = $(window).width();
            const $elementHeight = $("#co-color-list").height();
            const $elementWidth = $("#co-color-list").width();

            let top, left;

            top = $targetPosicao.top - $targetHeight;
            var elementoPosicao = "co-color-list--bellow";

            left = $targetPosicao.left - $("#co-color-list").width() / 2;
            var elementoPosicao2 = "co-color-list--left";

            element.find("ul.color-reset li").attr("data-color", reseteCor);
            element
                .css({
                    top: top,
                    left: left,
                })
                .addClass([elementoPosicao, elementoPosicao2]);
        };
        positionElement($element, event);
        effectModal($element);
        chooseColor($element, event);
        removePalletColor();
        constumResetTextButton($element);
        g_openChooseColor = true;
    } catch (err) {
        error_handling(err);
    }
};

function backupPog(p_backupType, p_shelfIndex, p_moduleIndex, p_pog_index) {
    /*take backup to revert in case of error*/
    if (g_curr_canvas == 1) {
        if (typeof g_pog_json !== "undefined" && g_pog_json.length > 0) {
            g_pogBackup = [];
            backDetail = [];
            backDetail.backupType = p_backupType; //'F' full backup 'S' Shelf backup only
            if (p_backupType == "S") {
                backDetail.shelfIndex = p_shelfIndex;
                backDetail.moduleIndex = p_moduleIndex;
                backDetail.push(JSON.parse(JSON.stringify(g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex])));
            } else {
                backDetail.shelfIndex = -1;
                backDetail.moduleIndex = -1;
                backDetail.push(JSON.parse(JSON.stringify(g_pog_json[p_pog_index])));
            }
            g_pogBackup.push(backDetail);
        }
    }
}

async function revertOnError(p_backupJson, p_pog_index) {
    try {
        lIndex = 0;
        if (g_errorRaisedFlag == "N") {
            g_errorRaisedFlag = "Y";
            pogBackup = [];
        }
    } catch (err) {
        console.log("error");
    }
}

//Finding out the pixel width and height of any world object.
//this function is used to find out the text real size and create text box or create item borders when drag item from product list etc.
function get_visible_size(p_objectZ, p_obj_width, p_obj_height, p_canvas, p_camera) {
    try {
        logDebug("function : get_visible_size; objectZ : " + p_objectZ + "; obj_width : " + p_obj_width + "; obj_height : " + p_obj_height, "S");
        var dist = p_camera.position.z - p_objectZ;
        var vFOV = THREE.MathUtils.degToRad(p_camera.fov); // convert vertical fov to radians
        var height = 2 * Math.tan(vFOV / 2) * dist; // visible height
        var width = height * p_camera.aspect;
        var canvaswidth = p_canvas.width / window.devicePixelRatio;
        var canvasheight = p_canvas.height / window.devicePixelRatio;
        var pixel_width = canvaswidth * (p_obj_width / width);
        var pixel_height = canvasheight * (p_obj_height / height);
        logDebug("function : get_visible_size", "E");
        return [pixel_width, pixel_height];
    } catch (err) {
        logDebug("function : get_visible_size", "E");
        error_handling(err);
    }
}

function calculateSize(p_img, p_maxWidth, p_maxHeight) {
    try {
        logDebug("function : calculateSize; maxWidth : " + p_maxWidth + "; maxHeight : " + p_maxHeight, "E");
        let width = p_img.width;
        let height = p_img.height;

        // calculate the width and height, constraining the proportions
        if (width > height) {
            if (width > p_maxWidth) {
                height = Math.round((height * p_maxWidth) / width);
                width = p_maxWidth;
            }
        } else {
            if (height > p_maxHeight) {
                width = Math.round((width * p_maxHeight) / height);
                height = p_maxHeight;
            }
        }
        logDebug("function : calculateSize", "E");
        return [width, height];
    } catch (err) {
        logDebug("function : calculateSize", "E");
        error_handling(err);
    }
}

//This function return the size in proper readable format like 120 MB, 554 KB etc.
function readableBytes(p_bytes) {
    try {
        logDebug("function : readableBytes; bytes : " + p_bytes, "S");
        const i = Math.floor(Math.log(p_bytes) / Math.log(1024)),
            sizes = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
        logDebug("function : readableBytes", "E");
        return (p_bytes / Math.pow(1024, i)).toFixed(2) + " " + sizes[i];
    } catch (err) {
        logDebug("function : readableBytes", "E");
        error_handling(err);
    }
}
// ASA-1472 Issue 1
// function roundNumber(p_num, p_scale) {
//     try {
//         logDebug("function : roundNumber; num : " + p_num + "; scale : " + p_scale, "S");
//         if (!("" + p_num).includes("e")) {
//             logDebug("function : roundNumber", "E");
//             return + (Math.round(p_num + "e+" + p_scale) + "e-" + p_scale);
//         } else {
//             var arr = ("" + p_num).split("e");
//             var sig = "";
//             if (+arr[1] + p_scale > 0) {
//                 sig = "+";
//             }
//             logDebug("function : roundNumber", "E");
//             return + (Math.round(+arr[0] + "e" + sig + (+arr[1] + p_scale)) + "e-" + p_scale);
//         }
//     } catch (err) {
//         logDebug("function : roundNumber", "E");
//         error_handling(err);
//     }
// }
// get back the height and width of the text in pixels for creation of canvas.
function get_visible_text_dim(p_text, p_textHeight) {
    try {
        logDebug("function : get_visible_text_dim; text : " + p_text + "; textHeight : " + p_textHeight, "S");
        var ruler = document.getElementById("ruler");
        ruler.style.fontSize = p_textHeight + "px";
        ruler.innerHTML = p_text;
        width = ruler.offsetWidth + 10; //ASA-1677 issue 2 increased offset width.
        height = ruler.offsetHeight + 5;
        logDebug("function : get_visible_text_dim", "E");
        return [width, height];
    } catch (err) {
        logDebug("function : get_visible_text_dim", "E");
        error_handling(err);
    }
}

function clickInsideElement(p_event, p_className) {
    // logDebug('function : clickInsideElement', 'S');
    var el = p_event.srcElement || p_event.target;

    if (el.classList.contains(p_className)) {
        return el;
    } else {
        while ((el = el.parentNode)) {
            if (el.classList && el.classList.contains(p_className)) {
                return el;
            }
        }
    }
    return false;
}

//Returns true or false if any tag is having sent value. used for context menu.
function JsonContains(p_json, p_keyname, p_value) {
    try {
        if (typeof p_json !== "undefined" && p_json !== null) {
            return Object.keys(p_json).some((key) => {
                return typeof p_json[key] === "object" ? JsonContains(p_json[key], p_keyname, p_value) : key === p_keyname && p_json[key] === p_value;
            });
        }
    } catch (err) {
        error_handling(err);
    }
}

//ASA-1669 Start
//Function to compare multiple keys and values of JSON
//p_conditions -> pass key-values as an JS Object
function JsonContainsAll(arr, conditions) {
    try {
        if (!Array.isArray(arr)) return false;

        return arr.some((obj) => {
            return Object.entries(conditions).every(([key, value]) => obj[key] === value);
        });
    } catch (err) {
        console.error(err);
    }
    return false;
}

//ASA-1669 End

//Getting next alphabet passing current alphabet. this is used to generate new module name.
function nextLetter(p_s) {
    try {
        return p_s.replace(/([a-zA-Z])[^a-zA-Z]*$/, function (a) {
            var c = a.charCodeAt(0);
            switch (c) {
                case 90:
                    return "A";
                case 122:
                    return "a";
                default:
                    return String.fromCharCode(++c);
            }
        });
    } catch (err) {
        error_handling(err);
    }
}

//this function is only used on 3d View to create scene and camera for that screen.
function create3dWorld() {
    try {
        g_scene = new THREE.Scene();
        g_camera = new THREE.PerspectiveCamera(25, g_canvas.width / g_canvas.height, 0.1, 1000);
        g_camera.lookAt(new THREE.Vector3(0, 0, 0));
        g_renderer.setPixelRatio(window.devicePixelRatio);
        g_scene.add(g_camera);
        g_renderer.setClearColor(0xffffff);
        g_renderer.setSize(g_canvas.width, g_canvas.height);
        // Add lights
        var hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.61);
        hemiLight.position.set(0, 50, 0);
        // Add hemisphere light to scene
        g_scene.add(hemiLight);
        var dirLight = new THREE.DirectionalLight(0xffffff, 0.54);
        dirLight.position.set(-8, 12, 15);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        // Add directional Light to scene
        g_scene.add(dirLight);
        g_camera.aspect = g_canvas.width / g_canvas.height;
        g_camera.updateProjectionMatrix();

        var geo = new THREE.PlaneGeometry(g_json[0].CameraW + 1.5, 3, 1, 1);
        var material = new THREE.MeshPhongMaterial({
            color: 0xa69fa6,
            shininess: 0,
        });
        material.flatShading = true;
        geo.normalsNeedUpdate;
        geo.computeFaceNormals();

        var plane = new THREE.Mesh(geo, material);
        plane.rotation.x -= Math.PI / 2;
        if (g_json[0].CameraMinY < 0) {
            var camera_height = g_json[0].CameraH / 2 + (0 - g_json[0].CameraMinY);
        } else {
            var camera_height = g_json[0].CameraH / 2;
        }
        plane.position.y = 0 - camera_height;
        g_scene.add(plane);
        plane.receiveShadow = true;

        //An empty object3D created to put all other items into it.
        g_world = new THREE.Object3D();
        g_scene.add(g_world);

        //Invisible object to handle dragged coordinates.
        g_targetForDragging = new THREE.Mesh(new THREE.BoxGeometry(100, 100, 0.01), new THREE.MeshBasicMaterial());
        g_targetForDragging.material.visible = false;
        g_targetForDragging.material.transparent = true; // This was used for debugging
        g_targetForDragging.material.opacity = 0.1;
        g_targetForDragging.uuid = "drag_object";
    } catch (err) {
        error_handling(err);
    }
}

function createWorld() {
    try {
        g_scene = {};
        g_camera = {};
        g_world = {};
        g_scene = new THREE.Scene();
        g_camera = new THREE.PerspectiveCamera(25, g_canvas.width / 2 / g_canvas.height, 0.1, 1000);
        g_camera.lookAt(new THREE.Vector3(0, 0, 0));
        //ASA-1986 for safe Rerender setPixelRatio on reload POg  Start
        if (g_renderer && typeof g_renderer.setPixelRatio === 'function') {
        g_renderer.setPixelRatio(window.devicePixelRatio);
        } else if (typeof THREE !== 'undefined' && typeof g_canvas !== 'undefined' && g_canvas) {
            g_renderer = new THREE.WebGLRenderer({
                canvas: g_canvas,
                antialias: true,
                preserveDrawingBuffer: true,
            });
            if (typeof g_renderer.setPixelRatio === 'function') g_renderer.setPixelRatio(window.devicePixelRatio);
        }
        //ASA-1986 End
        g_camera.add(new THREE.PointLight(0xffffff, 0.2)); // point light at camera position
        g_scene.add(g_camera);
        if (g_renderer && typeof g_renderer.setClearColor === 'function') {   //ASA-1986 start
        g_renderer.setClearColor(0xffffff);
        }
        //ASA-1986 end
        var directionlight = new THREE.DirectionalLight(0xffffff, 1);
        directionlight.position.set(-1, 2, 4).normalize();
        g_scene.add(directionlight);
        g_camera.aspect = g_canvas.width / 2 / g_canvas.height;
        g_camera.updateProjectionMatrix();
        //resizeRendererToDisplaySize(renderer);
        //An empty object3D created to put all other items into it.
        g_world = new THREE.Object3D();
        g_scene.add(g_world);
        //Invisible object to handle dragged coordinates.
        g_targetForDragging = new THREE.Mesh(new THREE.BoxGeometry(100, 100, 0.01), new THREE.MeshBasicMaterial());
        g_targetForDragging.material.visible = false;
        g_targetForDragging.material.transparent = true; // This was used for debugging
        g_targetForDragging.material.opacity = 0.1;
        g_targetForDragging.uuid = "drag_object";
    } catch (err) {
        error_handling(err);
    }
}

function get_new_orientation_dim(p_orientation, p_item_width, p_item_height, p_item_depth) {
    try {
        logDebug("function : get_new_orientation_dim; orientation : " + p_orientation + "; item_width : " + p_item_width + "; item_height : " + p_item_height + "; item_depth : " + p_item_depth, "S");
        width_final = height_final = depth_final = 0;
        if (p_orientation == "1" || p_orientation == "3" || p_orientation == "13" || p_orientation == "15") {
            var new_width = p_item_width;
            var new_height = p_item_height;
            height_final = new_width;
            width_final = new_height;
            depth_final = p_item_depth;
            var heightVar = "W";
            var widthVar = "H";
            var depthVar = "D";
        } else if (p_orientation == "4" || p_orientation == "6" || p_orientation == "16" || p_orientation == "18") {
            var new_depth = p_item_depth;
            var new_height = p_item_height;
            width_final = p_item_width;
            height_final = new_depth;
            depth_final = new_height;
            var heightVar = "D";
            var widthVar = "W";
            var depthVar = "H";
        } else if (p_orientation == "5" || p_orientation == "7" || p_orientation == "17" || p_orientation == "19") {
            var new_depth = p_item_depth;
            var new_height = p_item_height;
            var new_width = p_item_width;
            height_final = new_width;
            width_final = new_depth;
            depth_final = new_height;
            var heightVar = "W";
            var widthVar = "D";
            var depthVar = "H";
        } else if (p_orientation == "8" || p_orientation == "10" || p_orientation == "20" || p_orientation == "22") {
            var new_depth = p_item_depth;
            var new_width = p_item_width;
            width_final = new_depth;
            height_final = p_item_height;
            depth_final = new_width;
            var heightVar = "H";
            var widthVar = "D";
            var depthVar = "W";
        } else if (p_orientation == "9" || p_orientation == "11" || p_orientation == "21" || p_orientation == "23") {
            var new_depth = p_item_depth;
            var new_height = p_item_height;
            var new_width = p_item_width;
            width_final = new_height;
            height_final = new_depth;
            depth_final = new_width;
            var heightVar = "D";
            var widthVar = "H";
            var depthVar = "W";
        } else {
            width_final = p_item_width;
            height_final = p_item_height;
            depth_final = p_item_depth;
            var heightVar = "H";
            var widthVar = "W";
            var depthVar = "D";
        }
        logDebug("function : get_new_orientation_dim", "E");
        return [width_final, height_final, depth_final, heightVar, widthVar, depthVar];
    } catch (err) {
        error_handling(err);
    }
}
//this function is used to add border black lines for all the objects.
function add_wireframe(p_object, p_linewidth) {
    try {
        logDebug("function : add_wireframe; linewidth : " + p_linewidth, "S");
        var geo = new THREE.EdgesGeometry(p_object.geometry);
        var mat = new THREE.LineBasicMaterial({
            color: 0x000000,
            linewidth: p_linewidth,
        });
        var wireframe = new THREE.LineSegments(geo, mat);
        wireframe.renderOrder = 1; // make sure wireframes are rendered 2nd
        wireframe.uuid = "wireframe";
        p_object.WireframeObj = wireframe;
        p_object.add(wireframe);
        logDebug("function : add_wireframe", "E");
        return wireframe.id;
    } catch (err) {
        error_handling(err);
    }
}

function add_wireframe_3d(p_object) {
    return add_wireframe(p_object, 2);
}

function set_camera_z(p_camera, p_x, p_y, p_width, p_height, p_offset, p_min_x, p_min_y, p_updateJSON = true, p_pog_index) {
    try {
        console.log("p_pog_index", p_pog_index);
        logDebug("function : set_camera_z; x : " + p_x + "; y : " + p_y + "; width : " + p_width + "; height : " + p_height + "; offset : " + p_offset + "; min_x : " + p_min_x + "; min_y : " + p_min_y, "S");
        /*if (p_min_y < 0) {
        var diff_height = 0;
        diff_height = 0 - parseFloat(p_min_y);
        var new_height = 0;
        new_height = p_height - diff_height;
        p_y = new_height / 2;
        p_offset = p_offset + 0.3;
        }*/
         //ASA-1986
         p_x = Number(p_x) || 0;
        p_y = Number(p_y) || 0;
        p_width = Number(p_width);
        if (!Number.isFinite(p_width) || p_width <= 0) p_width = 1;
        p_height = Number(p_height);
        if (!Number.isFinite(p_height) || p_height <= 0) p_height = 1;
        p_offset = Number(p_offset);
        if (!Number.isFinite(p_offset)) p_offset = 0;
        p_min_x = Number(p_min_x) || 0;
        p_min_y = Number(p_min_y) || 0;
      //ASA-1986
        p_camera.position.x = p_x;
        p_camera.position.y = p_y;
        p_camera.position.z = 0;
        console.log("camera.x", p_camera.position.x, p_x);
        var camera_z = 0.1;
        var calc_height = 0;
        var calc_width = 0;
        //This loop will check how far camera should be placed so that POG is completely visible.
        //this is finding the camera.position.z value based on POG height and width.
        for (i = 0; i < 1000; i++) {
            calc_height = visibleHeightAtZDepth(camera_z, p_camera);
            calc_width = visibleWidthAtZDepth(camera_z, p_camera);

            if (parseFloat(p_height) < calc_height && parseFloat(p_width) < calc_width) {
                break;
            } else {
                camera_z += 0.1;
            }
        }
        //p_offset is the standard value to give a little extra space on all sides.
        p_camera.position.z = p_offset + camera_z;
        if (p_updateJSON) {
            g_pog_json[p_pog_index].CameraX = p_x;
            g_pog_json[p_pog_index].CameraY = p_y;
            g_pog_json[p_pog_index].CameraZ = camera_z;
            g_pog_json[p_pog_index].CameraW = p_width;
            g_pog_json[p_pog_index].CameraH = p_height;
            g_pog_json[p_pog_index].CameraMinX = p_min_x;
            g_pog_json[p_pog_index].CameraMinY = p_min_y;
        }

        logDebug("function : set_camera_z", "E");
    } catch (err) {
        logDebug("function : set_camera_z", "E");
        error_handling(err);
    }
}

function set_camera_z_3d(p_camera, p_x, p_y, p_width, p_height, p_offset) {
    set_camera_z(p_camera, p_x, p_y, p_width, p_height, p_offset, 0, 0, false, g_pog_index);
}
//This function can be removed and merged with set_camera_z. both have same logic. but few change only.
function set_camera_z_offside(p_camera, p_x, p_y, p_width, p_height, p_offset, p_min_x, p_min_y) {
    try {
        /*if (p_min_y < 0) {
        var diff_height = 0;
        diff_height = 0 - parseFloat(p_min_y);
        var new_height = 0;
        new_height = p_height - diff_height;
        p_y = new_height / 2;
        p_offset = p_offset;
        }*/
         
         //ASA-1986

         p_x = Number(p_x) || 0;
        p_y = Number(p_y) || 0;
        p_width = Number(p_width);
        if (!Number.isFinite(p_width) || p_width <= 0) p_width = 1;
        p_height = Number(p_height);
        if (!Number.isFinite(p_height) || p_height <= 0) p_height = 1;
        p_offset = Number(p_offset);
        if (!Number.isFinite(p_offset)) p_offset = 0;
        p_min_x = Number(p_min_x) || 0;
        p_min_y = Number(p_min_y) || 0;
    //ASA-1986
        var camera_z = 0.1;
        var calc_height = 0;
        var calc_width = 0;
        for (i = 0; i < 1000; i++) {
            calc_height = visibleHeightAtZDepth(camera_z, p_camera);
            calc_width = visibleWidthAtZDepth(camera_z, p_camera);

            if (parseFloat(p_height) < calc_height && parseFloat(p_width) < calc_width) {
                break;
            } else {
                camera_z += 0.1; //ASA-1306 added beacuse in combine shelf the item should be cut so its should set to i
            }
        }

        return [p_offset + camera_z, p_y];
    } catch (err) {
        error_handling(err);
    }
}

function get_min_max_xy_module(p_mod_array, p_module_index, p_width, p_height, p_moduleX, p_pog_width, p_mod_count) {
    logDebug("function : get_min_max_xy_module; p_module_index : " + p_module_index + "; width : " + p_width + "; height : " + p_height + "; moduleX : " + p_moduleX, "S");
    try {
        var max_x = 0,
            min_x = 0,
            max_y = 0,
            min_y = 0,
            shelf_width = 0,
            shelf_height = 0,
            max_height_arr = [],
            max_height = 0,
            index_arr = [],
            mod_index = -1,
            shelf_ind = -1;

        if (p_height <= 0.2) {
            max_x = p_width;
            min_x = 0;
            max_y = p_height;
            min_y = 0;
            if (p_mod_array.ShelfInfo.length > 0) {
                var l_shelf_cnt = 0;
                for (const shelfs of p_mod_array.ShelfInfo) {
                    if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && ((shelfs.ObjType == "TEXTBOX" && shelfs.W < p_pog_width) || p_mod_count == 1 || (shelfs.ObjType !== "TEXTBOX" && p_mod_count > 1)) && shelfs.SplitChest == "N") {
                        //Task_26627
                        if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                            shelf_width = shelfs.ShelfRotateWidth;
                            shelf_height = shelfs.ShelfRotateHeight;
                        } else {
                            shelf_width = shelfs.W;
                            shelf_height = shelfs.H;
                        }
                        if (shelfs.ObjType == "TEXTBOX" && max_height < shelfs.H) {
                            max_height = shelfs.H;
                            mod_index = p_module_index;
                            shelf_ind = l_shelf_cnt;
                        }
                    }
                    var shelfX = shelfs.X - (p_moduleX - p_width / 2);
                    max_x = Math.max(max_x, shelfX + shelf_width / 2);
                    min_x = Math.min(min_x, shelfX - shelf_width / 2);
                    max_y = Math.max(max_y, shelfs.Y + shelf_height / 2);
                    min_y = Math.min(min_y, shelfs.Y - shelf_height / 2);
                    l_shelf_cnt++;
                }
            }
            //Start Task_26627 chestinfo is not considered in finding max height
            //ASA-1506 issue 1, 2
            if (nvl(p_mod_array.ChestInfo) !== 0 && p_mod_array.ChestInfo.length > 0) {
                var l_shelf_cnt = 0;
                for (const shelfs of p_mod_array.ChestInfo) {
                    if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                        shelf_width = shelfs.ShelfRotateWidth;
                        shelf_height = shelfs.ShelfRotateHeight;
                    } else {
                        shelf_width = shelfs.W;
                        shelf_height = shelfs.H;
                    }
                    if (shelfs.ObjType == "TEXTBOX" && max_height < shelfs.H) {
                        max_height = shelfs.H;
                        mod_index = p_module_index;
                        shelf_ind = l_shelf_cnt;
                    }
                    var shelfX = shelfs.X - (p_moduleX - p_width / 2);
                    max_x = Math.max(max_x, shelfX + shelf_width / 2);
                    min_x = Math.min(min_x, shelfX - shelf_width / 2);
                    max_y = Math.max(max_y, shelfs.Y + shelf_height / 2);
                    min_y = Math.min(min_y, shelfs.Y - shelf_height / 2);
                    l_shelf_cnt++;
                }
            }
            //End Task_26627

            var new_width = parseFloat(max_x) - parseFloat(min_x);
            var new_height = parseFloat(max_y) - parseFloat(min_y);
            if (mod_index !== -1 && shelf_ind !== -1) {
                var new_x = p_mod_array.ShelfInfo[shelf_ind].X - (p_moduleX - p_width / 2);
                var new_y = p_mod_array.ShelfInfo[shelf_ind].Y;
            } else {
                var new_x = new_width / 2;
                var new_y = new_height / 2;
            }
        } else {
            max_x = p_width;
            min_x = 0;
            max_y = p_height;
            min_y = 0;
            if (p_mod_array.ShelfInfo.length > 0) {
                var l_shelf_cnt = 0;
                for (const shelfs of p_mod_array.ShelfInfo) {
                    if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && ((shelfs.ObjType == "TEXTBOX" && shelfs.W < p_pog_width) || p_mod_count == 1 || (shelfs.ObjType !== "TEXTBOX" && p_mod_count > 1)) && shelfs.SplitChest == "N") {
                        //Task_26627
                        if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                            shelf_width = shelfs.ShelfRotateWidth;
                            shelf_height = shelfs.ShelfRotateHeight;
                        } else {
                            shelf_width = shelfs.W;
                            shelf_height = shelfs.H;
                        }
                        var shelfX = shelfs.X - (p_moduleX - p_width / 2);
                        max_x = Math.max(max_x, shelfX + shelf_width / 2);
                        min_x = Math.min(min_x, shelfX - shelf_width / 2);
                        max_y = Math.max(max_y, shelfs.Y + shelf_height / 2);
                        min_y = Math.min(min_y, shelfs.Y - shelf_height / 2);

                        var l_item_cnt = 0;
                        for (const items of shelfs.ItemInfo) {
                            var itemx = items.X - (p_moduleX - p_width / 2);
                            max_x = Math.max(max_x, itemx + items.W / 2);
                            min_x = Math.min(min_x, itemx - items.W / 2);
                            max_y = Math.max(max_y, items.Y + items.H / 2);
                            min_y = Math.min(min_y, items.Y - items.H / 2);
                            l_item_cnt++;
                        }
                    }
                    l_shelf_cnt++;
                }
            }
            //Start Task_26627 chestinfo is not considered in finding max height
            //ASA-1506 issue 1, 2
            if (nvl(p_mod_array.ChestInfo) !== 0 && p_mod_array.ChestInfo.length > 0) {
                var l_shelf_cnt = 0;
                for (const shelfs of p_mod_array.ChestInfo) {
                    if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                        shelf_width = shelfs.ShelfRotateWidth;
                        shelf_height = shelfs.ShelfRotateHeight;
                    } else {
                        shelf_width = shelfs.W;
                        shelf_height = shelfs.H;
                    }
                    var shelfX = shelfs.X - (p_moduleX - p_width / 2);
                    max_x = Math.max(max_x, shelfX + shelf_width / 2);
                    min_x = Math.min(min_x, shelfX - shelf_width / 2);
                    max_y = Math.max(max_y, shelfs.Y + shelf_height / 2);
                    min_y = Math.min(min_y, shelfs.Y - shelf_height / 2);

                    var l_item_cnt = 0;
                    for (const items of shelfs.ItemInfo) {
                        var itemx = items.X - (p_moduleX - p_width / 2);
                        max_x = Math.max(max_x, itemx + items.W / 2);
                        min_x = Math.min(min_x, itemx - items.W / 2);
                        max_y = Math.max(max_y, items.Y + items.H / 2);
                        min_y = Math.min(min_y, items.Y - items.H / 2);
                        l_item_cnt++;
                    }
                    l_shelf_cnt++;
                }
            }
            // ASA-1951  #Task-2 padding issue Start
            var padding = 1;
            min_x -= padding;
            max_x += padding;
            min_y -= padding;
            max_y += padding;

            //ASA-1951 end   

            //End Task_26627
            //var new_width = parseFloat(max_x) - parseFloat(min_x);
            //var new_height = parseFloat(max_y) - parseFloat(min_y);
            //var new_x = new_width / 2;
            //var new_y = new_height / 2;
            var new_width = parseFloat(max_x) - parseFloat(min_x);
            var new_height = parseFloat(max_y) - parseFloat(min_y);
            var new_x = parseFloat(min_x) + new_width / 2;
            var new_y = parseFloat(min_y) + new_height / 2;
        }
        logDebug("function : get_min_max_xy_module", "E");
        return new_width + "###" + new_height + "###" + new_x + "###" + new_y + "###" + min_x + "###" + min_y + "###" + max_x + "###" + max_y;
    } catch (err) {
        error_handling(err);
    }
}

//This function is used to find the modules x and y and used in duplicating module.
function get_actual_mod_xy(p_mod_array, p_width, p_height, p_mod_x) {
    logDebug("function : get_module_final_xy;   width : " + p_width + "; height : " + p_height + "S");
    try {
        console.log(p_mod_array, p_width, p_height, p_mod_x);
        var shelf_width = 0,
            shelf_height = 0,
            max_x = p_width,
            min_x = p_mod_x,
            max_y = p_height,
            min_y = 0;
        if (p_mod_array.ShelfInfo.length > 0) {
            var l_shelf_cnt = 0;
            for (const shelfs of p_mod_array.ShelfInfo) {
                if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER") {
                    if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                        shelf_width = shelfs.ShelfRotateWidth;
                        shelf_height = shelfs.ShelfRotateHeight;
                    } else {
                        shelf_width = shelfs.W;
                        shelf_height = shelfs.H;
                    }
                    var shelfX = shelfs.X;
                    max_x = Math.max(max_x, shelfX + shelf_width / 2);
                    min_x = Math.min(min_x, shelfX - shelf_width / 2);
                    max_y = Math.max(max_y, shelfs.Y + shelf_height / 2);
                    min_y = Math.min(min_y, shelfs.Y - shelf_height / 2);

                    var l_item_cnt = 0;
                    for (const items of shelfs.ItemInfo) {
                        var itemx = items.X;
                        max_x = Math.max(max_x, itemx + items.W / 2);
                        min_x = Math.min(min_x, itemx - items.W / 2);
                        max_y = Math.max(max_y, items.Y + items.H / 2);
                        min_y = Math.min(min_y, items.Y - items.H / 2);
                        l_item_cnt++;
                    }
                }
                l_shelf_cnt++;
            }
        }
        var new_width = parseFloat(max_x) - parseFloat(min_x);
        var new_height = parseFloat(max_y) - parseFloat(min_y);
        var new_x = new_width / 2;
        var new_y = new_height / 2;

        logDebug("function : get_module_final_xy", "E");
        return new_width + "###" + new_height + "###" + new_x + "###" + new_y + "###" + min_x + "###" + min_y + "###" + max_x + "###" + max_y;
    } catch (err) {
        error_handling(err);
    }
}

//This function is used in combine POG images in PDF. it will give x and y for combined modules.
function get_min_max_xy_combine(p_pog_json, p_mod_sub) {
    logDebug("function : get_min_max_xy", "S");
    try {
        var max_x = 0,
            min_x = 0,
            max_y = 0,
            min_y = 0,
            shelf_width = 0,
            shelf_height = 0,
            max_height_arr = [],
            max_height = 0,
            index_arr = [],
            mod_index = -1,
            shelf_ind = -1;
        if (typeof p_pog_json !== "undefined" && p_pog_json.length > 0) {
            if (p_pog_json[0].H <= 0.2) {
                console.log("if", p_pog_json[0].H);
                max_x = p_pog_json[0].W;
                min_x = 0;
                max_y = p_pog_json[0].H;
                min_y = 0;
                var l_mod_cnt = 0;
                for (const modules of p_pog_json[0].ModuleInfo) {
                    if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                        if (typeof p_pog_json[0].ModuleInfo[l_mod_cnt].Carpark !== "undefined" && p_pog_json[0].ModuleInfo[l_mod_cnt].Carpark !== null) {
                            if (p_pog_json[0].ModuleInfo[l_mod_cnt].Carpark.length > 0) {
                                var l_car_cnt = 0;
                                for (const shelfs of modules.Carpark) {
                                    if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                        shelf_width = typeof shelfs.ShelfRotateWidth == "undefined" ? shelfs.W : shelfs.ShelfRotateWidth;
                                        shelf_height = typeof shelfs.ShelfRotateHeight == "undefined" ? shelfs.W : shelfs.ShelfRotateHeight;
                                    } else {
                                        shelf_width = shelfs.W;
                                        shelf_height = shelfs.H;
                                    }
                                    if (shelfs.ObjType == "TEXTBOX" && max_height < shelfs.H) {
                                        max_height = shelfs.H;
                                        mod_index = l_mod_cnt;
                                        shelf_ind = l_car_cnt;
                                    }
                                    max_x = Math.max(max_x, shelfs.X + shelf_width / 2 - p_mod_sub);
                                    min_x = Math.min(min_x, shelfs.X - shelf_width / 2 - p_mod_sub);
                                    max_y = Math.max(max_y, shelfs.Y + shelf_height / 2);
                                    min_y = Math.min(min_y, shelfs.Y - shelf_height / 2);
                                    var l_item_cnt = 0;
                                    for (const items of shelfs.ItemInfo) {
                                        max_x = Math.max(max_x, items.X + items.W / 2 - p_mod_sub);
                                        min_x = Math.min(min_x, items.X - items.W / 2 - p_mod_sub);
                                        max_y = Math.max(max_y, items.Y + items.H / 2);
                                        min_y = Math.min(min_y, items.Y - items.H / 2);
                                        l_item_cnt = l_item_cnt++;
                                    }
                                    l_car_cnt = l_car_cnt++;
                                }
                            }
                        }
                        console.log("0", 0, l_mod_cnt);
                        if (p_pog_json[0].ModuleInfo[l_mod_cnt].ShelfInfo.length > 0) {
                            var l_shelf_cnt = 0;
                            for (const shelfs of modules.ShelfInfo) {
                                if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER") {
                                    if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                        shelf_width = typeof shelfs.ShelfRotateWidth == "undefined" ? shelfs.W : shelfs.ShelfRotateWidth;
                                        shelf_height = typeof shelfs.ShelfRotateHeight == "undefined" ? shelfs.W : shelfs.ShelfRotateHeight;
                                    } else {
                                        shelf_width = shelfs.W;
                                        shelf_height = shelfs.H;
                                    }
                                    if (shelfs.ObjType == "TEXTBOX" && max_height < shelfs.H) {
                                        max_height = shelfs.H;
                                        mod_index = l_mod_cnt;
                                        shelf_ind = l_shelf_cnt;
                                    }
                                }
                                max_x = Math.max(max_x, shelfs.X + shelf_width / 2 - p_mod_sub);
                                min_x = Math.min(min_x, shelfs.X - shelf_width / 2 - p_mod_sub);
                                max_y = Math.max(max_y, shelfs.Y + shelf_height / 2);
                                min_y = Math.min(min_y, shelfs.Y - shelf_height / 2);
                                l_shelf_cnt++;
                            }
                        }
                    }
                    //});
                    l_mod_cnt++;
                }
                var new_width = parseFloat(max_x) - parseFloat(min_x);
                var new_height = parseFloat(max_y) - parseFloat(min_y);
                if (mod_index !== -1 && shelf_ind !== -1) {
                    var new_x = p_pog_json[0].ModuleInfo[mod_index].ShelfInfo[shelf_ind].X;
                    var new_y = p_pog_json[0].ModuleInfo[mod_index].ShelfInfo[shelf_ind].Y;
                } else {
                    var new_x = parseFloat(min_x) + new_width / 2;
                    var new_y = parseFloat(min_y) + new_height / 2;
                }
            } else {
                max_x = p_pog_json[0].W;
                min_x = 0;
                max_y = p_pog_json[0].H;
                min_y = 0;
                var l_mod_cnt = 0;
                for (const modules of p_pog_json[0].ModuleInfo) {
                    if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                        if (typeof p_pog_json[0].ModuleInfo[l_mod_cnt].Carpark !== "undefined" && p_pog_json[0].ModuleInfo[l_mod_cnt].Carpark !== null) {
                            if (p_pog_json[0].ModuleInfo[l_mod_cnt].Carpark.length > 0) {
                                var l_car_cnt = 0;
                                for (const shelfs of modules.Carpark) {
                                    if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                        shelf_width = typeof shelfs.ShelfRotateWidth == "undefined" ? shelfs.W : shelfs.ShelfRotateWidth;
                                        shelf_height = typeof shelfs.ShelfRotateHeight == "undefined" ? shelfs.W : shelfs.ShelfRotateHeight;
                                    } else {
                                        shelf_width = shelfs.W;
                                        shelf_height = shelfs.H;
                                    }
                                    if (shelfs.ObjType == "TEXTBOX" && max_height < shelfs.H) {
                                        max_height = shelfs.H;
                                        mod_index = l_mod_cnt;
                                        shelf_ind = l_car_cnt;
                                    }
                                    max_x = Math.max(max_x, shelfs.X + shelf_width / 2 - p_mod_sub);
                                    min_x = Math.min(min_x, shelfs.X - shelf_width / 2 - p_mod_sub);
                                    max_y = Math.max(max_y, shelfs.Y + shelf_height / 2);
                                    min_y = Math.min(min_y, shelfs.Y - shelf_height / 2);
                                    var l_item_cnt = 0;
                                    for (const items of shelfs.ItemInfo) {
                                        max_x = Math.max(max_x, items.X + items.W / 2 - p_mod_sub);
                                        min_x = Math.min(min_x, items.X - items.W / 2 - p_mod_sub);
                                        max_y = Math.max(max_y, items.Y + items.H / 2);
                                        min_y = Math.min(min_y, items.Y - items.H / 2);
                                        l_item_cnt++;
                                    }
                                    l_car_cnt++;
                                }
                            }
                        }
                        if (p_pog_json[0].ModuleInfo[l_mod_cnt].ShelfInfo.length > 0) {
                            var l_shelf_cnt = 0;
                            for (const shelfs of modules.ShelfInfo) {
                                if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER") {
                                    if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                        shelf_width = typeof shelfs.ShelfRotateWidth == "undefined" ? shelfs.W : shelfs.ShelfRotateWidth;
                                        shelf_height = typeof shelfs.ShelfRotateHeight == "undefined" ? shelfs.W : shelfs.ShelfRotateHeight;
                                    } else {
                                        shelf_width = shelfs.W;
                                        shelf_height = shelfs.H;
                                    }
                                    max_x = Math.max(max_x, shelfs.X + shelf_width / 2 - p_mod_sub);
                                    min_x = Math.min(min_x, shelfs.X - shelf_width / 2 - p_mod_sub);
                                    max_y = Math.max(max_y, shelfs.Y + shelf_height / 2);
                                    min_y = Math.min(min_y, shelfs.Y - shelf_height / 2);
                                    var l_item_cnt = 0;
                                    if (shelfs.ObjType == "TEXTBOX") {
                                        shelfs.ItemInfo = [];
                                    }
                                    for (const items of shelfs.ItemInfo) {
                                        max_x = Math.max(max_x, items.X + items.W / 2 - p_mod_sub);
                                        min_x = Math.min(min_x, items.X - items.W / 2 - p_mod_sub);
                                        max_y = Math.max(max_y, items.Y + items.H / 2);
                                        min_y = Math.min(min_y, items.Y - items.H / 2);
                                        l_item_cnt++;
                                    }
                                }
                                l_shelf_cnt++;
                            }
                        }
                    }
                    l_mod_cnt++;
                }
                var new_width = parseFloat(max_x) - parseFloat(min_x);
                var new_height = parseFloat(max_y) - parseFloat(min_y);
                var new_x = parseFloat(min_x) + new_width / 2;
                var new_y = parseFloat(min_y) + new_height / 2;
            }
        }
        logDebug("function : get_min_max_xy", "E");
        return new_width + "###" + new_height + "###" + new_x + "###" + new_y + "###" + min_x + "###" + min_y;
    } catch (err) {
        error_handling(err);
    }
}

//This is used before calling set_camera_z. which will first find the min max xy of whole POG and send to set_camera_z.
function get_min_max_xy(p_pog_index) {
    logDebug("function : get_min_max_xy", "S");
    try {
        var max_x = 0,
            min_x = 0,
            max_y = 0,
            min_y = 0,
            shelf_width = 0,
            shelf_height = 0,
            max_height_arr = [],
            max_height = 0,
            index_arr = [],
            mod_index = -1,
            shelf_ind = -1;
        if (typeof g_pog_json !== "undefined" && g_pog_json.length > 0) {
            //This is POG where module height will be very less like a thing board in the bottom.
            //POG which has slopped shelfs on both side on a single text box standing in the center. will have this type.
            if (g_pog_json[p_pog_index].H <= 0.2) {
                console.log("if", g_pog_json[p_pog_index].H);
                max_x = g_pog_json[p_pog_index].W;
                min_x = 0;
                max_y = g_pog_json[p_pog_index].H;
                min_y = 0;
                var l_mod_cnt = 0;
                for (const modules of g_pog_json[p_pog_index].ModuleInfo) {
                    if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                        if (typeof g_pog_json[p_pog_index].ModuleInfo[l_mod_cnt].Carpark !== "undefined" && g_pog_json[p_pog_index].ModuleInfo[l_mod_cnt].Carpark !== null) {
                            if (g_pog_json[p_pog_index].ModuleInfo[l_mod_cnt].Carpark.length > 0) {
                                var l_car_cnt = 0;
                                for (const shelfs of modules.Carpark) {
                                    if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                        shelf_width = typeof shelfs.ShelfRotateWidth == "undefined" ? shelfs.W : shelfs.ShelfRotateWidth;
                                        shelf_height = typeof shelfs.ShelfRotateHeight == "undefined" ? shelfs.W : shelfs.ShelfRotateHeight;
                                    } else {
                                        shelf_width = shelfs.W;
                                        shelf_height = shelfs.H;
                                    }
                                    if (shelfs.ObjType == "TEXTBOX" && max_height < shelfs.H) {
                                        max_height = shelfs.H;
                                        mod_index = l_mod_cnt;
                                        shelf_ind = l_car_cnt;
                                    }
                                    max_x = Math.max(max_x, shelfs.X + shelf_width / 2);
                                    min_x = Math.min(min_x, shelfs.X - shelf_width / 2);
                                    max_y = Math.max(max_y, shelfs.Y + shelf_height / 2);
                                    min_y = Math.min(min_y, shelfs.Y - shelf_height / 2);
                                    var l_item_cnt = 0;
                                    for (const items of shelfs.ItemInfo) {
                                        max_x = Math.max(max_x, items.X + items.W / 2);
                                        min_x = Math.min(min_x, items.X - items.W / 2);
                                        max_y = Math.max(max_y, items.Y + items.H / 2);
                                        min_y = Math.min(min_y, items.Y - items.H / 2);
                                        l_item_cnt = l_item_cnt++;
                                    }
                                    l_car_cnt = l_car_cnt++;
                                }
                            }
                        }
                        console.log("p_pog_index", p_pog_index, l_mod_cnt);
                        if (g_pog_json[p_pog_index].ModuleInfo[l_mod_cnt].ShelfInfo.length > 0) {
                            var l_shelf_cnt = 0;
                            for (const shelfs of modules.ShelfInfo) {
                                if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER") {
                                    if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                        shelf_width = typeof shelfs.ShelfRotateWidth == "undefined" ? shelfs.W : shelfs.ShelfRotateWidth;
                                        shelf_height = typeof shelfs.ShelfRotateHeight == "undefined" ? shelfs.W : shelfs.ShelfRotateHeight;
                                    } else {
                                        shelf_width = shelfs.W;
                                        shelf_height = shelfs.H;
                                    }
                                    if (shelfs.ObjType == "TEXTBOX" && max_height < shelfs.H) {
                                        max_height = shelfs.H;
                                        mod_index = l_mod_cnt;
                                        shelf_ind = l_shelf_cnt;
                                    }
                                }
                                max_x = Math.max(max_x, shelfs.X + shelf_width / 2);
                                min_x = Math.min(min_x, shelfs.X - shelf_width / 2);
                                max_y = Math.max(max_y, shelfs.Y + shelf_height / 2);
                                min_y = Math.min(min_y, shelfs.Y - shelf_height / 2);
                                l_shelf_cnt++;
                            }
                        }
                    }
                    //});
                    l_mod_cnt++;
                }
                var new_width = parseFloat(max_x) - parseFloat(min_x);
                var new_height = parseFloat(max_y) - parseFloat(min_y);
                if (mod_index !== -1 && shelf_ind !== -1) {
                    var new_x = g_pog_json[p_pog_index].ModuleInfo[mod_index].ShelfInfo[shelf_ind].X;
                    var new_y = g_pog_json[p_pog_index].ModuleInfo[mod_index].ShelfInfo[shelf_ind].Y;
                } else {
                    var new_x = parseFloat(min_x) + new_width / 2;
                    var new_y = parseFloat(min_y) + new_height / 2;
                }
            } else {
                //This block is for normal POG.
                max_x = g_pog_json[p_pog_index].W;
                min_x = 0;
                max_y = g_pog_json[p_pog_index].H;
                min_y = 0;
                var l_mod_cnt = 0;
                for (const modules of g_pog_json[p_pog_index].ModuleInfo) {
                    if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                        if (typeof g_pog_json[p_pog_index].ModuleInfo[l_mod_cnt].Carpark !== "undefined" && g_pog_json[p_pog_index].ModuleInfo[l_mod_cnt].Carpark !== null) {
                            if (g_pog_json[p_pog_index].ModuleInfo[l_mod_cnt].Carpark.length > 0) {
                                var l_car_cnt = 0;
                                for (const shelfs of modules.Carpark) {
                                    if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                        shelf_width = typeof shelfs.ShelfRotateWidth == "undefined" ? shelfs.W : shelfs.ShelfRotateWidth;
                                        shelf_height = typeof shelfs.ShelfRotateHeight == "undefined" ? shelfs.W : shelfs.ShelfRotateHeight;
                                    } else {
                                        shelf_width = shelfs.W;
                                        shelf_height = shelfs.H;
                                    }
                                    if (shelfs.ObjType == "TEXTBOX" && max_height < shelfs.H) {
                                        max_height = shelfs.H;
                                        mod_index = l_mod_cnt;
                                        shelf_ind = l_car_cnt;
                                    }
                                    max_x = Math.max(max_x, shelfs.X + shelf_width / 2);
                                    min_x = Math.min(min_x, shelfs.X - shelf_width / 2);
                                    max_y = Math.max(max_y, shelfs.Y + shelf_height / 2);
                                    min_y = Math.min(min_y, shelfs.Y - shelf_height / 2);
                                    var l_item_cnt = 0;
                                    for (const items of shelfs.ItemInfo) {
                                        max_x = Math.max(max_x, items.X + items.W / 2);
                                        min_x = Math.min(min_x, items.X - items.W / 2);
                                        max_y = Math.max(max_y, items.Y + items.H / 2);
                                        min_y = Math.min(min_y, items.Y - items.H / 2);
                                        l_item_cnt++;
                                    }
                                    l_car_cnt++;
                                }
                            }
                        }
                        if (g_pog_json[p_pog_index].ModuleInfo[l_mod_cnt].ShelfInfo.length > 0) {
                            var l_shelf_cnt = 0;
                            for (const shelfs of modules.ShelfInfo) {
                                if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER") {
                                    if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                        shelf_width = typeof shelfs.ShelfRotateWidth == "undefined" ? shelfs.W : shelfs.ShelfRotateWidth;
                                        shelf_height = typeof shelfs.ShelfRotateHeight == "undefined" ? shelfs.W : shelfs.ShelfRotateHeight;
                                    } else {
                                        shelf_width = shelfs.W;
                                        shelf_height = shelfs.H;
                                    }
                                    max_x = Math.max(max_x, shelfs.X + shelf_width / 2);
                                    min_x = Math.min(min_x, shelfs.X - shelf_width / 2);
                                    max_y = Math.max(max_y, shelfs.Y + shelf_height / 2);
                                    min_y = Math.min(min_y, shelfs.Y - shelf_height / 2);
                                    var l_item_cnt = 0;
                                    if (shelfs.ObjType == "TEXTBOX") {
                                        shelfs.ItemInfo = [];
                                    }
                                    for (const items of shelfs.ItemInfo) {
                                        max_x = Math.max(max_x, items.X + items.W / 2);
                                        min_x = Math.min(min_x, items.X - items.W / 2);
                                        max_y = Math.max(max_y, items.Y + items.H / 2);
                                        min_y = Math.min(min_y, items.Y - items.H / 2);
                                        l_item_cnt++;
                                    }
                                }
                                l_shelf_cnt++;
                            }
                        }
                    }
                    l_mod_cnt++;
                }
                var new_width = parseFloat(max_x) - parseFloat(min_x);
                var new_height = parseFloat(max_y) - parseFloat(min_y);
                var new_x = parseFloat(min_x) + new_width / 2;
                var new_y = parseFloat(min_y) + new_height / 2;
            }
        }
        logDebug("function : get_min_max_xy", "E");
        return new_width + "###" + new_height + "###" + new_x + "###" + new_y + "###" + min_x + "###" + min_y;
    } catch (err) {
        error_handling(err);
    }
}

//This function is used when on off show live image or create PDF with item image.
async function recreate_image_items(p_show_live_ind, p_merchStyle, p_load_img_from, p_bu_id, p_item_num_lbl_color, p_item_num_lbl_pos, p_display_item_info, p_delist_item_dft_color, p_notch_head, p_pog_index, p_days_of_supply_show = "Y", p_daysofsuppFontSize = "N,0.018", p_itemDtlList) {
    logDebug("function : recreate_image_items; show_live_ind : " + p_show_live_ind, "S");
    try {
        console.log("live image called");
        g_world = g_scene_objects[p_pog_index].scene.children[2]; //ASA-1702
        var l = 0;
        var mod_arr = g_pog_json[p_pog_index].ModuleInfo;
        for (const modules of mod_arr) {
            if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                if (modules.ShelfInfo.length > 0) {
                    j = 0;
                    for (const shelfs of modules.ShelfInfo) {
                        if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX") {
                            x = 0;
                            for (const items of shelfs.ItemInfo) {
                                if (items.Item !== "DIVIDER") {
                                    //first remove the item object from world and then create it again.
                                    var selectedObject = g_world.getObjectById(items.ObjID);
                                    g_world.remove(selectedObject);
                                    if (p_show_live_ind == "Y" && items.MerchStyle != 3) {
                                        var details = g_orientation_json[items.Orientation];
                                        var details_arr = details.split("###");
                                        var objID = await add_items_with_image(items.ItemID, items.W, items.H, items.D, items.Color, items.X, items.Y, items.Z, l, j, x, items.BHoriz, items.BVert, items.Item, parseInt(details_arr[0]), parseInt(details_arr[1]), "N", "N", p_merchStyle, p_load_img_from, p_bu_id, p_item_num_lbl_color, p_item_num_lbl_pos, p_display_item_info, p_pog_index);
                                    } else {
                                        var objID = await add_items_prom(items.ItemID, items.W, items.H, items.D, items.Color, items.X, items.Y, items.Z, l, j, x, "N", "N", p_delist_item_dft_color, p_item_num_lbl_color, p_display_item_info, p_item_num_lbl_color, p_item_num_lbl_pos, p_pog_index);
                                    }
                                    g_pog_json[p_pog_index].ModuleInfo[l].ShelfInfo[j].ItemInfo[x].ObjID = objID;
                                    //below code is setting borders based on the condition. that means it will have different color.
                                    if (p_show_live_ind == "N") {
                                        var selectedObject = g_world.getObjectById(objID);
                                        if (items.DimUpdate == "E") {
                                            selectedObject.BorderColour = g_dim_error_color;
                                            selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                                        } else if (items.Status == "N") {
                                            selectedObject.BorderColour = g_status_error_color;
                                            selectedObject.Status = "N";
                                            selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                                        } else if (nvl(items.MovingItem) == "No" && g_pogcr_auto_hlite_non_mv_item == "Y") {
                                            selectedObject.BorderColour = g_nonMovingItemColor;
                                            selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                                        } else {
                                            if (nvl(items.OOSPerc) > 80 && g_pogcr_enbl_oos_border == "Y") {
                                                //ASA-1688
                                                selectedObject.BorderColour = g_pogcr_oos_border_color; //ASA-1688 Added to give blue border to item
                                                selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                                            } else {
                                                selectedObject.BorderColour = 0x000000;
                                            }
                                        }
                                    } else {
                                        if (items.DimUpdate == "E") {
                                            selectedObject.BorderColour = g_dim_error_color;
                                        } else if (items.Status == "N" && typeof selectedObject !== "undefined") {
                                            selectedObject.BorderColour = g_status_error_color;
                                            selectedObject.Status = "N";
                                        } else if (nvl(items.MovingItem) == "No" && g_pogcr_auto_hlite_non_mv_item == "Y" && nvl(selectedObject) !== 0) {
                                            selectedObject.BorderColour = g_nonMovingItemColor;
                                            selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                                        } else {
                                            if (nvl(items.OOSPerc) > 80 && g_pogcr_enbl_oos_border == "Y") {
                                                selectedObject.BorderColour = g_pogcr_oos_border_color; //ASA-1688 Added to give blue border to item
                                                selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                                            } else {
                                                selectedObject.BorderColour = 0x000000;
                                            }
                                            if (typeof selectedObject !== "undefined") {
                                                selectedObject.BorderColour = 0x000000;
                                            }
                                        }
                                    }
                                }
                                x++;
                            }
                            //the items which are stacked on top of another will have to be set the position y and x accordingly in this function.
                            if (shelfs.ObjType == "SHELF" || shelfs.ObjType == "PALLET") {
                                var returnval = reset_top_bottom_objects(l, j, "N", p_pog_index);
                            }
                        } else if (shelfs.TextImg !== "" && typeof shelfs.TextImg !== "undefined" && shelfs.ObjType == "TEXTBOX" && shelfs.TextImg !== null) {
                            //Text box also can have images saved in table. so expected is to show item in text box also when click live image.
                            var colorValue = parseInt(shelfs.Color.replace("#", "0x"), 16);
                            var hex_decimal = new THREE.Color(colorValue);
                            if (shelfs.Color.charAt(1) == "#" && shelfs.ObjType == "TEXTBOX") {
                                var bg_color = null;
                            } else {
                                var bg_color = colorValue;
                            }
                            if (p_show_live_ind == "Y" && shelfs.TextImg !== "" && typeof shelfs.TextImg !== "undefined" && shelfs.TextImg !== null) {
                                var return_val = await add_text_box_with_image(shelfs.Shelf, "TEXTBOX", shelfs.W, shelfs.H, shelfs.D, hex_decimal, shelfs.X, shelfs.Y, shelfs.Z, "Y", l, shelfs.InputText, bg_color, shelfs.WrapText, shelfs.ReduceToFit, shelfs.Color, j, shelfs.Rotation, shelfs.Slope, "N", shelfs.FStyle, shelfs.FSize, shelfs.FBold, p_notch_head, p_pog_index);
                            } else {
                                g_dblclick_objid = shelfs.SObjID;
                                g_shelf_index = j;
                                var return_val = add_text_box(shelfs.Shelf, "TEXTBOX", shelfs.W, shelfs.H, shelfs.D, hex_decimal, shelfs.X, shelfs.Y, shelfs.Z, "Y", l, shelfs.InputText, bg_color, shelfs.WrapText, shelfs.ReduceToFit, shelfs.Color, j, shelfs.Rotation, shelfs.Slope, "N", shelfs.FStyle, shelfs.FSize, shelfs.FBold, 2, p_pog_index, g_pogcr_enhance_textbox_fontsize, shelfs.TextDirection);
                            }
                            var child_module_index = -1;
                            var l_mod_cnt = 0;
                            for (const modules of g_pog_json[p_pog_index].ModuleInfo) {
                                if (modules.ParentModule !== null) {
                                    if (modules.Module == shelfs.Shelf) {
                                        child_module_index = l_mod_cnt;
                                    }
                                }
                                l_mod_cnt++;
                            }

                            if (child_module_index !== -1) {
                                g_pog_json[p_pog_index].ModuleInfo[child_module_index].ObjID = return_val;
                            }
                        }
                        j = j + 1;
                    }
                }
                //Carpark items should also have item image on as per below.
                if (typeof modules.Carpark[0] !== "undefined") {
                    if (modules.Carpark[0].ItemInfo.length > 0) {
                        k = 0;
                        for (const items of modules.Carpark[0].ItemInfo) {
                            var selectedObject = g_world.getObjectById(items.ObjID);
                            g_world.remove(selectedObject);

                            var details = g_orientation_json[items.Orientation];
                            var details_arr = details.split("###");

                            var objID = await add_carpark_item(items.ItemID, items.W, items.H, items.D, items.Color, items.X, items.Y, items.Z, l, 0, k, "Y", "N", p_show_live_ind, parseInt(details_arr[1]), p_pog_index);
                            g_pog_json[p_pog_index].ModuleInfo[l].Carpark[0].ItemInfo[k].ObjID = objID;
                            k = k + 1;
                        }
                    }
                }
            }
            l = l + 1;
        }
        //if days of supply is On, we need to add that label again.
        if (p_days_of_supply_show == "Y") {
            await showHideDaysOfSupplyLabel(g_show_days_of_supply, "N", p_pog_index, "Y", "N", p_daysofsuppFontSize, p_itemDtlList);
        }
        // $(".supply_days").removeClass("item_label_active");
        // g_show_days_of_supply = "N";
        logDebug("function : recreate_image_items", "E");
    } catch (err) {
        error_handling(err);
    }
}

//Below function is used when items are stacked on one another, this function will set the x and y accordingly so that. items are placed on top and set new ID references.
function reset_top_bottom_objects(p_module_index, p_shelf_index, p_reset_obj, p_pog_index) {
    logDebug("function : reset_top_bottom_objects; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index + "; reset_obj : " + p_reset_obj, "S");
    try {
        if (typeof g_pog_json[p_pog_index] !== "undefined" && typeof g_pog_json[p_pog_index].ModuleInfo[p_module_index] !== "undefined") {
            var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
            return new Promise(function (resolve, reject) {
                if (typeof shelfdtl !== "undefined") {
                    var item_Details = shelfdtl.ItemInfo;
                    var l_item_x_arr = [];
                    p = 0;
                    var shelf_top = shelfdtl.Y + shelfdtl.H / 2;
                    //remove the old object ID's as items are recreated and ID would be changed.
                    for (const items of item_Details) {
                        shelfdtl.ItemInfo[p].BottomObjID = "";
                        shelfdtl.ItemInfo[p].TopObjID = "";
                        p = p + 1;
                    }
                    var m = 0;
                    for (const items of item_Details) {
                        var top_bottom = "N";
                        var item_start = wpdSetFixed(items.X - items.W / 2);
                        var item_end = wpdSetFixed(items.X + items.W / 2);
                        p = 0;
                        //find the current object is a item on top on another item.
                        for (const fitems of item_Details) {
                            if (wpdSetFixed(fitems.X) == wpdSetFixed(items.X) && l_item_x_arr.indexOf(wpdSetFixed(items.X)) == -1 && m !== p) {
                                l_item_x_arr.push(wpdSetFixed(items.X));
                                top_bottom = "Y";
                                break;
                            }
                            p = p + 1;
                        }
                        if (top_bottom == "Y") {
                            var index_arr = [];
                            p = 0;
                            //find the Y position of bottom item and list of items in the same Y.
                            for (const fitems of item_Details) {
                                //ASA-2010 Issue1 Start
                                // if (wpdSetFixed(fitems.X) == wpdSetFixed(items.X) || (wpdSetFixed(fitems.X) > item_start && wpdSetFixed(fitems.X) < item_end)) {
                                if (shelfdtl.ObjType !== "PALLET"
                                    ? (
                                        wpdSetFixed(fitems.X) == wpdSetFixed(items.X) ||
                                        (wpdSetFixed(fitems.X) > item_start && wpdSetFixed(fitems.X) < item_end)
                                    )
                                    : (
                                        (
                                            wpdSetFixed(fitems.X) == wpdSetFixed(items.X) ||
                                            (wpdSetFixed(fitems.X) > item_start && wpdSetFixed(fitems.X) < item_end)
                                        ) &&
                                        wpdSetFixed(fitems.Z) == wpdSetFixed(items.Z)
                                    )
                                ) {
                                    //ASA-2010 Issue1 End
                                    var details = {};
                                    details["Y"] = fitems.Y;
                                    details["Index"] = p;
                                    index_arr.push(details);
                                }
                                p = p + 1;
                            }
                            var sorto = {
                                Y: "asc",
                            };
                            index_arr.keySort(sorto);
                            p = 0;
                            //this loop will set the Y and objID of the bottom and top items, so that it can be used in further processing.
                            for (const index of index_arr) {
                                if (p == 0) {
                                    shelfdtl.ItemInfo[index_arr[p].Index].Y = shelf_top + shelfdtl.ItemInfo[index_arr[p].Index].H / 2;
                                }
                                if (typeof index_arr[p + 1] !== "undefined") {
                                    if (typeof shelfdtl.ItemInfo[index_arr[p + 1].Index] !== "undefined") {
                                        shelfdtl.ItemInfo[index_arr[p + 1].Index].Y = shelfdtl.ItemInfo[index_arr[p].Index].Y + shelfdtl.ItemInfo[index_arr[p].Index].H / 2 + shelfdtl.ItemInfo[index_arr[p + 1].Index].H / 2;
                                        shelfdtl.ItemInfo[index_arr[p + 1].Index].BottomObjID = shelfdtl.ItemInfo[index_arr[p].Index].ObjID;
                                        shelfdtl.ItemInfo[index_arr[p].Index].TopObjID = shelfdtl.ItemInfo[index_arr[p + 1].Index].ObjID;

                                        total_height = get_y_distance(p_module_index, p_shelf_index, index_arr[p + 1].Index, shelfdtl.ItemInfo[index_arr[p + 1].Index].X, shelfdtl.ItemInfo[index_arr[p + 1].Index].Y, p_pog_index);
                                        shelfdtl.ItemInfo[index_arr[p + 1].Index].TotalHeight = total_height;
                                        // var selectObjects = g_scene_objects[p_pog_index].scene.children[2].getObjectById(shelfdtl.ItemInfo[index_arr[p + 1].Index].ObjID);
                                        // if (typeof selectObjects !== "undefined") {
                                        //     selectObjects.position.set(shelfdtl.ItemInfo[index_arr[p].Index].X, shelfdtl.ItemInfo[index_arr[p + 1].Index].Y, 0.001 + shelfdtl.D / 1000);
                                        // }
                                        if (p_reset_obj == "Y") {
                                            //setting the position of item object according to calculated value.
                                            var selectObjects = g_scene_objects[p_pog_index].scene.children[2].getObjectById(shelfdtl.ItemInfo[index_arr[p + 1].Index].ObjID);
                                            if (typeof selectObjects !== "undefined") {
                                                selectObjects.position.set(shelfdtl.ItemInfo[index_arr[p].Index].X, shelfdtl.ItemInfo[index_arr[p + 1].Index].Y, 0.001 + shelfdtl.D / 1000);
                                                if (shelfdtl.ObjType == "PEGBOARD") {
                                                    selectObjects.position.z = 0.016;
                                                } else {
                                                    //ASA-2010 Issue1 Start
                                                    // if (shelfdtl.ObjType == "PALLET") {
                                                    //     selectObjects.position.z = 0.001 + shelfdtl.D / 1000 + shelfdtl.ItemInfo[index_arr[p + 1].Index].D / 2;
                                                    // } else {
                                                    //     selectObjects.position.z = 0.001 + shelfdtl.D / 1000;
                                                    // }
                                                    if (shelfdtl.ObjType !== "PALLET") {
                                                        selectObjects.position.z = 0.001 + shelfdtl.D / 1000;
                                                    }
                                                    //ASA-2010 Issue1 End
                                                }
                                            }
                                        }
                                    }
                                }
                                p = p + 1;
                            }
                        }
                        m = m + 1;
                    }
                }
                resolve("SUCCES");
                logDebug("function : reset_top_bottom_objects", "E");
            });
        }
    } catch (err) {
        error_handling(err);
    }
}

async function create_module_from_json_lib(p_pog_json_arr, p_new_pog_ind, p_pog_type, p_product_open, p_pog_opened, p_recreate, p_create_json, p_vdate, p_PogDefaultColor, p_PogModuleDefaultColor, p_pog_version, p_CopyJsonInd, p_showSingleModule, p_org_mod_index, p_SpreadItem, p_HorizSpacing, p_VertiSpacing, p_BsktWallThickness, p_ChestWallThickness, p_AutoPlacing, p_WrapText, p_FSize, p_TextboxColor, p_ShelfColor, p_DivColor, p_SlotDivider, p_SlotOrientation, p_DividerFixed, p_ItemColor, p_ItemDelistColor, p_pegHolesActive, p_pogCarparkShelfDftColor, p_enlargeNo, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrDelistItemDftColor, p_pogcrItemNumLabelColor, p_pogcrDisplayItemInfo, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_notchHead, p_updateObjInd = "N", p_pDftBskFill, p_pDftBaskSprd, p_camera, p_pog_index, p_orgPogIndex, p_DefaultNotchStart, p_m_crush, p_crush_item, p_calc_dayofsupply) {
    //ASA-1310 KUSH FIX
    //Regression 29(Portal Issue) added p_calc_dayofsupply to handle in Portal > POG View and Module View, as day of supply calculation not required
    try {
        var HeadInfo = {};
        var x, y, p_cameraY, baseY;
        var carparkShelfCreated = "Y";
        g_show_live_image = g_show_item_desc == "Y" ? "N" : g_show_live_image;
        //g_show_live_image_comp = g_show_item_desc == "Y" ? "N" : g_show_live_image_comp;
        // we have called this function for 2 purposes. one to create json and create pog objects. another only to create json.
        //p_recreate - this means the POG skeleton to be created.
        // /p_create_json - json should be created and assigned to g_pog_json.
        if (p_create_json == "Y") {
            p_showSingleModule == "N" ? (p_pog_type = p_pog_json_arr[p_pog_index].DesignType) : "";
            var subdept;
            var module_details = p_pog_json_arr[p_pog_index].ModuleInfo;
            if (module_details == null) {
                p_pog_json_arr[p_pog_index].ModuleInfo = [];
                module_details = [];
            }
            i = 0;
            //setting empty array because some time very old json which was created can have array as null.
            for (const modules of module_details) {
                if (modules.ShelfInfo == null || typeof modules.ShelfInfo == "undefined") {
                    modules.ShelfInfo = [];
                }
                if (modules.ChestInfo == null || typeof modules.ChestInfo == "undefined") {
                    //Bug-26122 - splitting the chest
                    modules.ChestInfo = [];
                }

                if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                    if (modules.SubDept !== null && typeof modules.SubDept !== "undefined") {
                        subdept = modules.SubDept;
                    }

                    j = 0;

                    for (const shelfs of modules.ShelfInfo) {
                        if (typeof shelfs.ItemInfo == "undefined" || shelfs.ItemInfo == null) {
                            shelfs.ItemInfo = [];
                        }
                        j = j + 1;
                    }
                }

                i = i + 1;
            }
            HeadInfo["Action"] = "C";
            p_pog_json_arr[p_pog_index].GenrateCombineS = typeof p_pog_json_arr[p_pog_index].GenrateCombineS !== "undefined" && p_pog_json_arr[p_pog_index].GenrateCombineS !== null ? p_pog_json_arr[p_pog_index].GenrateCombineS : []; //ASA-1353 issue 3 --Task_27104 20240417
            p_pog_json_arr[p_pog_index].SubDept = typeof p_pog_json_arr[p_pog_index].SubDept == "undefined" || p_pog_json_arr[p_pog_index].SubDept == null ? subdept : p_pog_json_arr[p_pog_index].SubDept;

            HeadInfo["Version"] = p_pog_json_arr[p_pog_index].Version == "" && p_pog_version !== "" ? p_pog_version : p_pog_json_arr[p_pog_index].Version;
            //this below condition means the pog json is created from table data for first time. so need to set default values.
            if (p_new_pog_ind == "N" && p_pog_type == "F") {
                //Getting base height
                var module_hgt_arr = [];
                var module_details = p_pog_json_arr[p_pog_index].ModuleInfo;

                i = 0;
                for (const modules of module_details) {
                    if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                        module_hgt_arr.push(modules.H);
                    }
                }
                if (p_pog_json_arr[p_pog_index].BaseH == "undefined" || p_pog_json_arr[p_pog_index].BaseH == null || p_pog_json_arr[p_pog_index].BaseH == 0) {
                    //Start ASA-1310 prasanna ASA-1310_25890
                    var BaseHeight = parseFloat(Math.max.apply(Math, module_hgt_arr));
                    var final_height = parseFloat(p_pog_json_arr[p_pog_index].H - BaseHeight);
                    HeadInfo["BaseH"] = wpdSetFixed(final_height);
                } else {
                    HeadInfo["BaseH"] = wpdSetFixed(p_pog_json_arr[p_pog_index].BaseH);
                } //End ASA-1310 prasanna ASA-1310_25890

                HeadInfo["DesignType"] = "D";
                HeadInfo["DraftVersion"] = p_pog_json_arr[p_pog_index].draftVersion; //ASA-1912
                HeadInfo["BaseW"] = wpdSetFixed(p_pog_json_arr[p_pog_index].W);
                HeadInfo["BaseD"] = wpdSetFixed(p_pog_json_arr[p_pog_index].D);
                HeadInfo["BaseX"] = wpdSetFixed(HeadInfo["BaseW"] / 2);
                HeadInfo["BaseY"] = wpdSetFixed(HeadInfo["BaseH"] / 2);
                HeadInfo["NewPOG"] = p_pog_json_arr[p_pog_index].NewPOG;
                //---------------------------------------------------------------

                if (typeof p_pog_json_arr[p_pog_index].SubDept == "undefined") {
                    HeadInfo["SubDept"] = "";
                } else {
                    HeadInfo["SubDept"] = p_pog_json_arr[p_pog_index].SubDept;
                }
                HeadInfo["BackDepth"] = 0.01;
                HeadInfo["TrafficFlow"] = "LR";
                HeadInfo["HorzStart"] = 0;
                HeadInfo["HorzSpacing"] = 0;
                HeadInfo["VertStart"] = 0;
                HeadInfo["VertSpacing"] = 0;
                HeadInfo["AllowOverlap"] = "N";
                //var effdate = new Date(p_pog_json_arr[p_pog_index].EffStartDate).toLocaleDateString("en-ZA"); //ASA-1085 ISSUE 1
                //var effdate = new Date(p_pog_json_arr[p_pog_index].EffStartDate.replace(/^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)$/,'$4:$5:$6 $2/$3/$1'));
                //	var effdate = date.getFullYear() + "/" + (date.getMonth() + 1) + "/" + date.getDate();
                // if (p_pog_json_arr[p_pog_index].EffStartDate < p_vdate) {  
                // 	HeadInfo["EffStartDate"] = p_vdate;
                // } else {
                // 	HeadInfo["EffStartDate"] = p_pog_json_arr[p_pog_index].EffStartDate;
                // }
                if ($v('P25_POG_EFFECTIVE_START_DATE_UPD') == 'Y') {    //ASA-1953
                    if (p_pog_json_arr[p_pog_index].EffStartDate < p_vdate) {
                        HeadInfo["EffStartDate"] = p_vdate;
                    } else {
                        HeadInfo["EffStartDate"] = p_pog_json_arr[p_pog_index].EffStartDate;
                    }
                } 
                else if ($v('P25_POG_EFF_START_DATE_UPDATE') == 'Y') {      //ASA-1983 add else if
                    if (p_pog_json_arr[p_pog_index].EffStartDate > p_vdate+1) {
                        HeadInfo["EffStartDate"] = p_pog_json_arr[p_pog_index].EffStartDate;
                    } else {
                        HeadInfo["EffStartDate"] = p_vdate+1;
                    }        
                } else {
                    //HeadInfo["EffStartDate"] = p_pog_json_arr[p_pog_index].EffStartDate;
                    HeadInfo["EffStartDate"] = moment(p_pog_json_arr[p_pog_index].EffStartDate, get_js_date_format()).format('YYYYMMDD');
                }
            } else {
                //This means the json is coming from sm_pog_design which was already saved to this table.
                HeadInfo["DesignType"] = "D";
                HeadInfo["DraftVersion"] = p_pog_json_arr[p_pog_index].draftVersion; //ASA-1912
                HeadInfo["SubDept"] = p_pog_json_arr[p_pog_index].SubDept;
                HeadInfo["BackDepth"] = p_pog_json_arr[p_pog_index].BackDepth;
                HeadInfo["TrafficFlow"] = p_pog_json_arr[p_pog_index].TrafficFlow;
                HeadInfo["HorzStart"] = p_pog_json_arr[p_pog_index].HorzStart;
                HeadInfo["HorzSpacing"] = p_pog_json_arr[p_pog_index].HorzSpacing;
                HeadInfo["VertStart"] = p_pog_json_arr[p_pog_index].VertStart;
                HeadInfo["VertSpacing"] = p_pog_json_arr[p_pog_index].VertSpacing;
                HeadInfo["AllowOverlap"] = p_pog_json_arr[p_pog_index].AllowOverlap;
                HeadInfo["BaseH"] = wpdSetFixed(p_pog_json_arr[p_pog_index].BaseH);
                HeadInfo["BaseW"] = wpdSetFixed(p_pog_json_arr[p_pog_index].BaseW);
                HeadInfo["BaseD"] = wpdSetFixed(p_pog_json_arr[p_pog_index].BaseD);
                HeadInfo["BaseX"] = wpdSetFixed(p_pog_json_arr[p_pog_index].BaseX);
                HeadInfo["BaseY"] = wpdSetFixed(p_pog_json_arr[p_pog_index].BaseY);
                //var effdate = new Date(p_pog_json_arr[p_pog_index].EffStartDate).toLocaleDateString("en-ZA"); // ASA-1085 ISSUE 1
                HeadInfo["NewPOG"] = p_pog_json_arr[p_pog_index].NewPOG;
                //	var effdate = date.getFullYear() + "/" + (date.getMonth() + 1) + "/" + date.getDate();
                // if (p_pog_json_arr[p_pog_index].EffStartDate < p_vdate) {   
                // 	HeadInfo["EffStartDate"] = p_vdate;
                // } 
                // else {
                // 	HeadInfo["EffStartDate"] = p_pog_json_arr[p_pog_index].EffStartDate;
                // }
                if ($v('P25_POG_EFFECTIVE_START_DATE_UPD') == 'Y') {      //ASA-1953
                    if (p_pog_json_arr[p_pog_index].EffStartDate < p_vdate) {
                        HeadInfo["EffStartDate"] = p_vdate;
                    } else {
                        HeadInfo["EffStartDate"] = p_pog_json_arr[p_pog_index].EffStartDate;
                    }
                } else {
                    HeadInfo["EffStartDate"] = p_pog_json_arr[p_pog_index].EffStartDate;

                }

            }
            //HeadInfo["Version"] = p_pog_json_arr[p_pog_index].Version;
            HeadInfo["POGCode"] = p_pog_json_arr[p_pog_index].POGCode;
            HeadInfo["Opened"] = p_pog_opened;
            HeadInfo["Name"] = p_pog_json_arr[p_pog_index].Name;
            HeadInfo["Division"] = p_pog_json_arr[p_pog_index].Division;
            HeadInfo["Dept"] = p_pog_json_arr[p_pog_index].Dept;
            HeadInfo["Type"] = p_pog_json_arr[p_pog_index].Type;
            HeadInfo["H"] = wpdSetFixed(p_pog_json_arr[p_pog_index].H);
            HeadInfo["W"] = wpdSetFixed(p_pog_json_arr[p_pog_index].W);
            HeadInfo["D"] = wpdSetFixed(p_pog_json_arr[p_pog_index].D);
            HeadInfo["SegmentW"] = wpdSetFixed(p_pog_json_arr[p_pog_index].SegmentW);
            HeadInfo["NotchW"] = wpdSetFixed(p_pog_json_arr[p_pog_index].NotchW);
            var default_not_start = 0;
            if (p_DefaultNotchStart > -1 && p_pog_json_arr[p_pog_index].NotchStart == 0 && p_pog_json_arr[p_pog_index].NotchW > 0) {
                default_not_start = p_DefaultNotchStart / 100;
            } else {
                default_not_start = p_pog_json_arr[p_pog_index].NotchStart;
            }
            HeadInfo["NotchStart"] = default_not_start;
            HeadInfo["NotchSpacing"] = p_pog_json_arr[p_pog_index].NotchSpacing;
            HeadInfo["SpecialType"] = p_pog_json_arr[p_pog_index].SpecialType;
            HeadInfo["SpecialTypeDesc"] = p_pog_json_arr[p_pog_index].SpecialTypeDesc;
            HeadInfo["DisplayMeterage"] = p_pog_json_arr[p_pog_index].DisplayMeterage;
            HeadInfo["RPTMeterage"] = p_pog_json_arr[p_pog_index].RPTMeterage;
            HeadInfo["ModuleDIR"] = p_pog_json_arr[p_pog_index].ModuleDIR;
            HeadInfo["Direction"] = p_pog_json_arr[p_pog_index].Direction;
            HeadInfo["OrderType"] = p_pog_json_arr[p_pog_index].OrderType;
            HeadInfo["StartOneFixel"] = p_pog_json_arr[p_pog_index].StartOneFixel;
            HeadInfo["StartOneModuleLoc"] = p_pog_json_arr[p_pog_index].StartOneModuleLoc;
            HeadInfo["Ignore"] = p_pog_json_arr[p_pog_index].Ignore;
            HeadInfo["StartOneModuleFixel"] = p_pog_json_arr[p_pog_index].StartOneModuleFixel;
            HeadInfo["IncludeModName"] = p_pog_json_arr[p_pog_index].IncludeModName;
            HeadInfo["Separator"] = p_pog_json_arr[p_pog_index].Separator;
            HeadInfo["LeadingText"] = p_pog_json_arr[p_pog_index].LeadingText;
            HeadInfo["TrailingText"] = p_pog_json_arr[p_pog_index].TrailingText;
            //	HeadInfo["EffStartDate"] = p_pog_json_arr[p_pog_index].EffStartDate;
            HeadInfo["BrandGroupID"] = p_pog_json_arr[p_pog_index].BrandGroupID;
            HeadInfo["Remarks"] = p_pog_json_arr[p_pog_index].Remarks;
            HeadInfo["FixtureGeneration"] = p_pog_json_arr[p_pog_index].FixtureGeneration;
            HeadInfo["FixtureFamily"] = p_pog_json_arr[p_pog_index].FixtureFamily;
            HeadInfo["FixtureFamilyHidden"] = typeof p_pog_json_arr[p_pog_index].FixtureFamilyHidden == "undefined" ? p_pog_json_arr[p_pog_index].FixtureFamily : p_pog_json_arr[p_pog_index].FixtureFamilyHidden;
            HeadInfo["FixtureType"] = p_pog_json_arr[p_pog_index].FixtureType;
            HeadInfo["FixtureTypeDesc"] = typeof p_pog_json_arr[p_pog_index].FixtureTypeDesc == "undefined" ? p_pog_json_arr[p_pog_index].FixtureType : p_pog_json_arr[p_pog_index].FixtureTypeDesc;
            HeadInfo["FixtureCodes"] = typeof p_pog_json_arr[p_pog_index].FixtureCodes == "undefined" ? "" : p_pog_json_arr[p_pog_index].FixtureCodes; //ASA-1694
            HeadInfo["FixtureCount"] = typeof p_pog_json_arr[p_pog_index].FixtureCount == "undefined" ? "" : p_pog_json_arr[p_pog_index].FixtureCount; //ASA-1694
            HeadInfo["Flex_Text_1"] = p_pog_json_arr[p_pog_index].Flex_Text_1;
            HeadInfo["Flex_Text_2"] = p_pog_json_arr[p_pog_index].Flex_Text_2;
            HeadInfo["Flex_Text_3"] = p_pog_json_arr[p_pog_index].Flex_Text_3;
            HeadInfo["Flex_Text_4"] = p_pog_json_arr[p_pog_index].Flex_Text_4;
            HeadInfo["Flex_Text_11"] = p_pog_json_arr[p_pog_index].Flex_Text_11; //ASA-1531
            HeadInfo["Flex_Text_12"] = p_pog_json_arr[p_pog_index].Flex_Text_12; //ASA-1531
            HeadInfo["Flex_Text_13"] = p_pog_json_arr[p_pog_index].Flex_Text_13; //ASA-1531
            HeadInfo["Flex_Text_14"] = p_pog_json_arr[p_pog_index].Flex_Text_14; //ASA-1754
            HeadInfo["Flex_Text_15"] = (p_pog_json_arr[p_pog_index].Flex_Text_15 !== undefined && 
                                        p_pog_json_arr[p_pog_index].Flex_Text_15 !== null && 
                                        p_pog_json_arr[p_pog_index].Flex_Text_15 !== "")
                                            ? p_pog_json_arr[p_pog_index].Flex_Text_15
                                            : p_pog_json_arr[p_pog_index].FixtureGroup; //ASA-1754 // ASA-1990 Req 3
            HeadInfo["FixtureGroup"] = p_pog_json_arr[p_pog_index].FixtureGroup; //ASA-1754
            HeadInfo["Flex_Lov_1"] = p_pog_json_arr[p_pog_index].Flex_Lov_1;
            HeadInfo["Flex_Lov_2"] = p_pog_json_arr[p_pog_index].Flex_Lov_2;
            HeadInfo["Flex_Lov_3"] = p_pog_json_arr[p_pog_index].Flex_Lov_3;
            HeadInfo["Flex_Lov_4"] = p_pog_json_arr[p_pog_index].Flex_Lov_4;
            HeadInfo["Flex_Lov_5"] = p_pog_json_arr[p_pog_index].Flex_Lov_5;
            HeadInfo["Flex_Lov_6"] = p_pog_json_arr[p_pog_index].Flex_Lov_6;
            HeadInfo["StoreSegment"] = p_pog_json_arr[p_pog_index].StoreSegment;
            HeadInfo["Desc7"] = p_pog_json_arr[p_pog_index].Desc7;
            HeadInfo["Area"] = p_pog_json_arr[p_pog_index].Area;
            HeadInfo["PLNDept"] = p_pog_json_arr[p_pog_index].PLNDept;
            HeadInfo["CompBaseObjID"] = p_pog_json_arr[p_pog_index].CompBaseObjID;
            HeadInfo["CompCamX"] = p_pog_json_arr[p_pog_index].CompCamX;
            HeadInfo["CompCamY"] = p_pog_json_arr[p_pog_index].CompCamY;
            HeadInfo["CompCamWidth"] = p_pog_json_arr[p_pog_index].CompCamWidth;
            HeadInfo["CompCamHeight"] = p_pog_json_arr[p_pog_index].CompCamHeight;
            if (typeof p_pog_json_arr[p_pog_index].Color == "undefined") {
                HeadInfo["Color"] = p_PogDefaultColor;
            } else {
                HeadInfo["Color"] = p_pog_json_arr[p_pog_index].Color;
            }

            HeadInfo["BaseZ"] = wpdSetFixed(p_pog_json_arr[p_pog_index].BaseZ);
            HeadInfo["p_cameraX"] = p_pog_json_arr[p_pog_index].p_cameraX;
            HeadInfo["p_cameraY"] = p_pog_json_arr[p_pog_index].p_cameraY;
            HeadInfo["p_cameraZ"] = p_pog_json_arr[p_pog_index].p_cameraZ;
            HeadInfo["X"] = wpdSetFixed(p_pog_json_arr[p_pog_index].X);
            HeadInfo["Y"] = wpdSetFixed(p_pog_json_arr[p_pog_index].Y);
            HeadInfo["Category"] = p_pog_json_arr[p_pog_index].Category;
            HeadInfo["SubCategory"] = p_pog_json_arr[p_pog_index].SubCategory;
            HeadInfo["GenrateCombineS"] = p_pog_json_arr[p_pog_index].GenrateCombineS; //ASA-1353 issue 3 --Task_27104 20240417
            if (typeof p_pog_json_arr[p_pog_index].SalesInfo !== "undefined" && p_pog_json_arr[p_pog_index].SalesInfo.length > 0) {
                //ASA-1400-S
                HeadInfo["SalesInfo"] = p_pog_json_arr[p_pog_index].SalesInfo;
            } else {
                HeadInfo["SalesInfo"] = [];
            } //ASA-1400-E
            HeadInfo["MassUpdate"] = typeof p_pog_json_arr[p_pog_index].MassUpdate !== "undefined" && p_pog_json_arr[p_pog_index].MassUpdate !== null && p_pog_json_arr[p_pog_index].MassUpdate !== "" ? p_pog_json_arr[p_pog_index].MassUpdate : "N"; //TASK 25959 added due to mass update for pegboard loction Y not has been changed //--20240415 Rregression issue 12

            if (typeof p_pog_json_arr[p_pog_index].PromStartDt == "undefined") {
                HeadInfo["PromStartDt"] = "";
            } else {
                HeadInfo["PromStartDt"] = p_pog_json_arr[p_pog_index].PromStartDt; //ASA-1202
            }
            if (typeof p_pog_json_arr[p_pog_index].PromEndDt == "undefined") {
                HeadInfo["PromEndDt"] = "";
            } else {
                HeadInfo["PromEndDt"] = p_pog_json_arr[p_pog_index].PromEndDt; //ASA-1202
            }
            if (typeof p_pog_json_arr[p_pog_index].PromName == "undefined") {
                HeadInfo["PromName"] = "";
            } else {
                HeadInfo["PromName"] = p_pog_json_arr[p_pog_index].PromName; //ASA-1202
            }
            if (typeof p_pog_json_arr[p_pog_index].PDFTemplateName == "undefined") {
                HeadInfo["PDFTemplateName"] = "";
            } else {
                HeadInfo["PDFTemplateName"] = p_pog_json_arr[p_pog_index].PDFTemplateName; //ASA-1876
            }
            if (typeof p_pog_json_arr[p_pog_index].ComparePogVersion == "undefined") {
                HeadInfo["ComparePogVersion"] = "";
            } else {
                HeadInfo["ComparePogVersion"] = p_pog_json_arr[p_pog_index].ComparePogVersion; //ASA-2009
            }
            if (typeof p_pog_json_arr[p_pog_index].StoreFormat == "undefined") {
                HeadInfo["StoreFormat"] = "";
            } else {
                HeadInfo["StoreFormat"] = p_pog_json_arr[p_pog_index].StoreFormat; // ASA-1990 Req 3
            }
            HeadInfo["SalesRrshDtl"] = p_pog_json_arr[p_pog_index].SalesRrshDtl;

            if (typeof p_pog_json_arr[p_pog_index].PreVersion !== "undefined") {
                HeadInfo["PreVersion"] = p_pog_json_arr[p_pog_index].PreVersion;
            } else {
                HeadInfo["PreVersion"] = "N";
            }
            HeadInfo["ModuleInfo"] = [];
            if (p_pog_json_arr[p_pog_index].DeleteItems != null && typeof p_pog_json_arr[p_pog_index].DeleteItems !== "undefined") {
                HeadInfo["DeleteItems"] = p_pog_json_arr[p_pog_index].DeleteItems;
            } else {
                HeadInfo["DeleteItems"] = [];
            }
            if (p_pog_json_arr[p_pog_index].MassDelistedItem != null && typeof p_pog_json_arr[p_pog_index].MassDelistedItem !== "undefined") { //ASA-1999
                HeadInfo["MassDelistedItem"] = p_pog_json_arr[p_pog_index].MassDelistedItem;
            } else {
                HeadInfo["MassDelistedItem"] = [];
            }
            g_pog_json[p_pog_index] = HeadInfo;
            HeadInfo["X"] = wpdSetFixed(x);
            HeadInfo["Y"] = wpdSetFixed(y);
        } else {
            HeadInfo = g_pog_json[p_pog_index];
        }
        //this below function will create the g_combineShelfs array used for combined shelfs for creating combinations again and used for crush too.
        create_g_combine_shelfs(p_pog_json_arr, p_pog_index); //ASA-1353 issue 3 --Task_27104 20240417

        x = wpdSetFixed(HeadInfo["W"] / 2);
        y = wpdSetFixed(HeadInfo["H"] / 2 + HeadInfo["BaseH"]);

        p_cameraY = HeadInfo["H"] / 2;
        baseY = parseFloat(HeadInfo["BaseH"]) / 2;
        var colorValue = parseInt(HeadInfo["Color"].replace("#", "0x"), 16);
        var hex_decimal = new THREE.Color(colorValue);
        //set camera z before creating a POG is done because until now position of camera is not set.
        if (p_recreate == "Y") {
            var details = get_min_max_xy(p_pog_index);
            var details_arr = details.split("###");
            set_camera_z(p_camera, parseFloat(details_arr[2]), parseFloat(details_arr[3]), parseFloat(details_arr[0]), parseFloat(details_arr[1]), g_offset_z, parseFloat(details_arr[4]), parseFloat(details_arr[5]), true, p_pog_index);
        }

        //create base
        if (HeadInfo["BaseH"] > 0 && p_recreate == "Y") {
            var return_val = await add_base("BASE1", HeadInfo["BaseW"], HeadInfo["BaseH"], HeadInfo["BaseD"], hex_decimal, HeadInfo["BaseX"], HeadInfo["BaseY"], "N", p_pog_index);
        }
        var copyJson = [];
        if (p_CopyJsonInd) {
            copyJson = JSON.parse(JSON.stringify(p_pog_json_arr));
            //if (p_new_pog_ind == 'N' && p_pog_type == 'F') {
            var i = 0;
            var prev_index = -1;
            for (const modules of copyJson[p_pog_index].ModuleInfo) {
                if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                    if (prev_index == -1) {
                        x = wpdSetFixed(modules.W / 2);
                        y = wpdSetFixed(modules.H / 2 + HeadInfo["BaseH"]);
                    } else {
                        x = wpdSetFixed(copyJson[p_pog_index].ModuleInfo[prev_index].X + copyJson[p_pog_index].ModuleInfo[prev_index].W / 2 + modules.W / 2);
                        y = wpdSetFixed(modules.H / 2 + HeadInfo["BaseH"]);
                    }
                    copyJson[p_pog_index].ModuleInfo[i].X = x;
                    copyJson[p_pog_index].ModuleInfo[i].Y = y;
                    prev_index = i;
                    var j = 0;
                    var l_shelf_details = modules.ShelfInfo;
                    l_shelf_details.sort((a, b) => (a.Y > b.Y && a.ObjType !== "NOTCH" && a.ObjType !== "BASE" ? 1 : -1));
                    if (p_new_pog_ind == "N" && p_pog_type == "F") {
                        for (const shelfs of modules.ShelfInfo) {
                            copyJson[p_pog_index].ModuleInfo[i].ShelfInfo[j].X = wpdSetFixed(shelfs.X + parseFloat(shelfs.W) / 2);
                            copyJson[p_pog_index].ModuleInfo[i].ShelfInfo[j].Y = wpdSetFixed(shelfs.Y + parseFloat(shelfs.H) / 2);
                            j = j + 1;
                        }
                    }
                }
                i++;
                //  };
            }
        }
        if (typeof p_pog_json_arr[p_pog_index].ModuleInfo !== "undefined") {
            if (p_pog_json_arr[p_pog_index].ModuleInfo.length > 0) {
                var module_details = p_pog_json_arr[p_pog_index].ModuleInfo;
                //module_details.sort((a, b) => (a.SeqNo > b.SeqNo && typeof a.ParentModule !== 'undefined' && a.ParentModule !== null) ? 1 : -1);
                var sorto = {
                    SeqNo: "asc",
                };
                module_details.keySort(sorto);
                if (typeof g_json !== "undefined" && g_json.length > 0) {
                    //Start ASA-1418 //ASA-1420 Issue 2
                    var g_json_mod_dtl = g_json[0].ModuleInfo;
                    g_json_mod_dtl.keySort(sorto);

                    var i = 0;
                    for (const modules of g_json_mod_dtl) {
                        if (modules.ShelfInfo.length > 0) {
                            $.each(modules.ShelfInfo, function (k, shelfs) {
                                if (typeof shelfs !== "undefined") {
                                    if (shelfs.ObjType == "BASE") {
                                        g_json[0].ModuleInfo[i].ShelfInfo.splice(k, 1);
                                    }
                                }
                            });
                        }
                        i++;
                    }
                } //End ASA-1418
                var i = 0;
                var module_ind = -1;
                for (const modules of module_details) {
                    if (modules.ShelfInfo.length > 0) {
                        $.each(modules.ShelfInfo, function (k, shelfs) {
                            if (typeof shelfs !== "undefined") {
                                if (shelfs.ObjType == "BASE") {
                                    p_pog_json_arr[p_pog_index].ModuleInfo[i].ShelfInfo.splice(k, 1);
                                }
                            }
                        });
                    }

                    var ModuleInfo = {};
                    if (p_create_json == "Y") {
                        if (p_new_pog_ind == "N" && p_pog_type == "F") {
                            if (typeof modules.SubDept == "undefined") {
                                ModuleInfo["SubDept"] = "";
                            } else {
                                ModuleInfo["SubDept"] = modules.SubDept;
                            }
                            ModuleInfo["Rotation"] = 0;
                            ModuleInfo["HorzStart"] = 0;
                            ModuleInfo["HorzSpacing"] = 0;
                            ModuleInfo["VertStart"] = 0;
                            ModuleInfo["VertSpacing"] = 0;
                            ModuleInfo["AllowOverlap"] = "N";
                            ModuleInfo["LNotch"] = 0;
                            ModuleInfo["Backboard"] = 1;
                            ModuleInfo["RNotch"] = 0;
                            ModuleInfo["LastCount"] = 0;
                            ModuleInfo["EditFlag"] = "N";
                            if (typeof modules.Carpark !== "undefined" && modules.Carpark !== null && typeof modules.Carpark[0] !== "undefined") {
                                if (modules.Carpark[0].ItemInfo == null) {
                                    ModuleInfo["Carpark"] = [];
                                } else if (typeof modules.Carpark[0].ItemInfo !== "undefined") {
                                    if (modules.Carpark[0].ItemInfo.length > 0) {
                                        ModuleInfo["Carpark"] = modules.Carpark;
                                    } else {
                                        ModuleInfo["Carpark"] = [];
                                    }
                                } else if (modules.Carpark.length > 0) {
                                    ModuleInfo["Carpark"] = modules.Carpark;
                                } else {
                                    ModuleInfo["Carpark"] = [];
                                }
                            } else {
                                ModuleInfo["Carpark"] = [];
                            }
                            //ModuleInfo["Carpark"] = typeof modules.Carpark !== 'undefined' ? modules.Carpark : [];
                        } else {
                            ModuleInfo["SubDept"] = modules.SubDept;
                            ModuleInfo["Rotation"] = modules.Rotation;
                            ModuleInfo["HorzStart"] = modules.HorzStart;
                            ModuleInfo["HorzSpacing"] = modules.HorzSpacing;
                            ModuleInfo["VertStart"] = modules.VertStart;
                            ModuleInfo["VertSpacing"] = modules.VertSpacing;
                            ModuleInfo["AllowOverlap"] = modules.AllowOverlap;
                            ModuleInfo["LNotch"] = modules.LNotch;
                            ModuleInfo["Backboard"] = modules.Backboard;
                            ModuleInfo["RNotch"] = modules.RNotch;
                            ModuleInfo["LastCount"] = modules.LastCount;
                            ModuleInfo["EditFlag"] = typeof modules.EditFlag !== "undefined" ? modules.EditFlag : "N";
                            if (typeof modules.Carpark !== "undefined" && modules.Carpark !== null && typeof modules.Carpark[0] !== "undefined") {
                                if (modules.Carpark[0].ItemInfo == null) {
                                    ModuleInfo["Carpark"] = [];
                                } else if (typeof modules.Carpark[0].ItemInfo !== "undefined") {
                                    if (modules.Carpark[0].ItemInfo.length > 0) {
                                        ModuleInfo["Carpark"] = modules.Carpark;
                                    } else {
                                        ModuleInfo["Carpark"] = [];
                                    }
                                } else if (modules.Carpark.length > 0) {
                                    ModuleInfo["Carpark"] = modules.Carpark;
                                } else {
                                    ModuleInfo["Carpark"] = [];
                                }
                            } else {
                                ModuleInfo["Carpark"] = [];
                            }
                            //ModuleInfo["Carpark"] = typeof modules.Carpark !== 'undefined' ? modules.Carpark : [];
                        }
                        ModuleInfo["SeqNo"] = modules.SeqNo;
                        ModuleInfo["Module"] = modules.Module;
                        if (typeof modules.ParentModule == "undefined") {
                            ModuleInfo["ParentModule"] = null;
                        } else {
                            ModuleInfo["ParentModule"] = modules.ParentModule;
                        }
                        ModuleInfo["ParentModuleIndex"] = modules.ParentModuleIndex;
                        ModuleInfo["POGModuleName"] = modules.ModuleName;
                        ModuleInfo["Remarks"] = modules.Remarks;
                        ModuleInfo["H"] = wpdSetFixed(modules.H);
                        ModuleInfo["W"] = wpdSetFixed(modules.W);
                        ModuleInfo["D"] = wpdSetFixed(modules.D);
                        if (typeof modules.Color == "undefined") {
                            ModuleInfo["Color"] = p_PogModuleDefaultColor;
                        } else {
                            ModuleInfo["Color"] = modules.Color;
                        }

                        ModuleInfo["NotchW"] = modules.NotchW;
                        var default_not_start = 0;
                        if (p_DefaultNotchStart > -1 && modules.NotchStart == 0 && modules.NotchW > 0) {
                            default_not_start = p_DefaultNotchStart / 100;
                        } else {
                            default_not_start = modules.NotchStart;
                        }
                        ModuleInfo["NotchStart"] = default_not_start;
                        ModuleInfo["NotchSpacing"] = modules.NotchSpacing;
                        ModuleInfo["CompMObjID"] = modules.CompMObjID;
                        if (modules.NotchW > 0) {
                            g_pog_json[p_pog_index].NotchW = modules.NotchW;
                            g_pog_json[p_pog_index].NotchStart = modules.NotchStart;
                            g_pog_json[p_pog_index].NotchSpacing = modules.NotchSpacing;
                        }

                        if (i == 0) {
                            x = wpdSetFixed(ModuleInfo["W"] / 2);
                            y = wpdSetFixed(ModuleInfo["H"] / 2 + g_pog_json[p_pog_index].BaseH);
                        } else {
                            x = wpdSetFixed(g_pog_json[p_pog_index].ModuleInfo[g_pog_json[p_pog_index].ModuleInfo.length - 1].X + ModuleInfo["W"] / 2);
                            y = wpdSetFixed(ModuleInfo["H"] / 2 + g_pog_json[p_pog_index].BaseH);
                        }

                        ModuleInfo["X"] = x;
                        ModuleInfo["Y"] = y;
                        ModuleInfo["Z"] = 0;
                        ModuleInfo["ChestInfo"] = modules.ChestInfo !== null && typeof modules.ChestInfo !== "undefined" && modules.ChestInfo !== "" ? modules.ChestInfo : []; //Bug-26122 - splitting the chest
                        //ASA-1994
                        ModuleInfo["SvnCode"] = modules.SvnCode;
                        ModuleInfo["EgtCode"] = modules.EgtCode;
                        //ends
                        ModuleInfo["ShelfInfo"] = [];
                        g_pog_json[p_pog_index].ModuleInfo.push(ModuleInfo);
                        module_ind = g_pog_json[p_pog_index].ModuleInfo.length - 1;
                    } else {
                        ModuleInfo = modules;
                        x = wpdSetFixed(modules.X);
                        y = wpdSetFixed(modules.Y);
                        module_ind = i;
                    }

                    if ((typeof modules.ParentModule == "undefined" || modules.ParentModule == null) && p_recreate == "Y") {
                        g_pog_json[p_pog_index].SegmentW = modules.W;
                        var colorValue = parseInt(ModuleInfo["Color"].replace("#", "0x"), 16);
                        var hex_decimal = new THREE.Color(colorValue);
                        var return_val = await add_module_lib(modules.Module, modules.W, modules.H, modules.D, hex_decimal, x, y, "N", "Y", modules.VertStart, modules.VertSpacing, modules.HorzStart, modules.HorzSpacing, "Y", p_camera, module_ind, p_SpreadItem, p_HorizSpacing, p_VertiSpacing, p_BsktWallThickness, p_ChestWallThickness, p_AutoPlacing, p_WrapText, p_FSize, p_TextboxColor, p_ShelfColor, p_DivColor, p_SlotDivider, p_SlotOrientation, p_DividerFixed, p_ItemColor, p_ItemDelistColor, p_pegHolesActive, p_pogCarparkShelfDftColor, p_enlargeNo, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrDelistItemDftColor, p_pogcrItemNumLabelColor, p_pogcrDisplayItemInfo, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_notchHead, p_updateObjInd, p_pog_index, p_pDftBskFill, p_pDftBaskSprd, p_m_crush);
                    }
                    if (typeof modules.Carpark !== "undefined" && modules.Carpark !== null) {
                        if (modules.Carpark.length > 0) {
                            carparkShelfCreated = "N";
                            var return_val = await create_shelf_edit_pog_lib(i, modules.Carpark, modules.W, "Y", p_new_pog_ind, p_pog_type, "Y", p_recreate, p_create_json, p_AutoPlacing, p_ShelfColor, p_DivColor, p_SlotDivider, p_SlotOrientation, p_DividerFixed, p_ItemColor, p_ItemDelistColor, p_pogCarparkShelfDftColor, p_enlargeNo, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrDelistItemDftColor, p_pogcrItemNumLabelColor, p_pogcrDisplayItemInfo, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_notchHead, p_updateObjInd, p_camera, p_pog_index, p_orgPogIndex, p_m_crush);
                        }
                    }

                    if (p_pog_json_arr[p_pog_index].ModuleInfo[i].ShelfInfo.length > 0) {
                        var return_val = await create_shelf_from_json_lib(i, p_pog_json_arr, modules.W, "Y", p_new_pog_ind, p_pog_type, p_recreate, p_create_json, p_CopyJsonInd, copyJson, p_showSingleModule, p_org_mod_index, p_SpreadItem, p_HorizSpacing, p_VertiSpacing, p_BsktWallThickness, p_ChestWallThickness, p_AutoPlacing, p_WrapText, p_FSize, p_TextboxColor, p_ShelfColor, p_ItemColor, p_ItemDelistColor, p_pogCarparkShelfDftColor, p_enlargeNo, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrDelistItemDftColor, p_pogcrItemNumLabelColor, p_pogcrDisplayItemInfo, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_updateObjInd, p_notchHead, p_pDftBskFill, p_pDftBaskSprd, p_camera, p_pog_index, p_orgPogIndex, p_m_crush, p_crush_item); //ASA-1310 KUSH FIX
                    }
                    //}
                    i = i + 1;
                }

                mod_details = g_pog_json[p_pog_index].ModuleInfo;
                temp_mod_details = g_pog_json[p_pog_index].ModuleInfo;

                var c = 0;
                //Start ASA-1349 issue 14
                for (const modules of mod_details) {
                    if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                        var i = 0;
                        for (shelfs of modules.ShelfInfo) {
                            console.log(shelfs.AutoDepthCalc, shelfs.SMassUpdate, "values");
                            var j = 0;
                            var recreate_shelf = "N";
                            for (items of shelfs.ItemInfo) {
                                /*if (typeof shelfs.SMassUpdate !== 'undefined' && shelfs.SMassUpdate == 'Y') {//ASA-1350 issue 6 // 20240415 Rregression issue 12 20240430 commented because new crushitem can get max merch based on g_json and crush height
                                    var retval = crushItem(p_pog_index, c, i, j, "H", "Y", [items.D], [j], 'Y');//ASA-1383 issue 8
                                    if (retval == 'Y' && g_show_live_image == 'N') {
                                        recreate_shelf = 'Y';
                                    }
                                }*/
                                if (typeof shelfs.AutoDepthCalc !== "undefined" && shelfs.AutoDepthCalc == "Y") {
                                    //ASA-1351 //ASA-1350 issue 6
                                    var temp_cal_depth_fac = g_auto_cal_depth_fac;
                                    g_auto_cal_depth_fac = "Y";
                                    maximizeItemDepthFacings("D", c, i, j, p_pog_index); // ASA-1170
                                    g_auto_cal_depth_fac = temp_cal_depth_fac;
                                }
                                j++;
                            }
                            /*if (recreate_shelf == 'Y') {20240415 Rregression issue 12 20240430 commented because new crushitem can get max merch based on g_json and crush height
                                await recreate_all_items(c, i, shelfs.ObjType, "Y", -1, -1, shelfs.ItemInfo.length, "N", "N", -1, -1, p_pog_index, "", p_pog_index, p_pogcrDelistItemDftColor, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, 'Y');//ASA-1350 issue 6 adding params////ASA-1353 issue 3 regression issue 20240428
                            }*/
                            if (shelfs.ObjType == "TEXTBOX") {
                                var j = 0;
                                for (tmp_mod of temp_mod_details) {
                                    if (typeof tmp_mod.ParentModule !== "undefined" && tmp_mod.ParentModule !== null && tmp_mod.Module == shelfs.Shelf) {
                                        g_pog_json[p_pog_index].ModuleInfo[j].ObjID = shelfs.SObjID;
                                    }
                                    j++;
                                }
                            }
                            i++;
                        }
                    }
                    c = c + 1;
                }
                //End ASA-1349 issue 14
            }
        }
        if (p_recreate == "Y") {
            var details = get_min_max_xy(p_pog_index);
            var details_arr = details.split("###");
            set_camera_z(p_camera, parseFloat(details_arr[2]), parseFloat(details_arr[3]), parseFloat(details_arr[0]), parseFloat(details_arr[1]), g_offset_z, parseFloat(details_arr[4]), parseFloat(details_arr[5]), true, p_pog_index);
        }
        if (p_recreate == "Y") {
            update_rotate_shelfs(p_pog_index);
        }
        g_multi_pog_json[p_pog_index] = g_pog_json[p_pog_index];
        //ASA-1157
        if (typeof g_pog_json !== "undefined" && g_pog_json.length > 0 && p_recreate == "Y") {
            //ASA-1353 issue 3 --Task_27104 20240417
            var m = 0;
            // g_combinedShelfs = []; ASA-1443 //needed to reset as data from DB should be reset again.
            // Regression issue 9, 10, 11 20241007

            for (let i = 0; i < g_combinedShelfs.length; i++) {
                if (g_combinedShelfs[i][0]["PIndex"] == p_pog_index) {
                    g_combinedShelfs.splice(i, 1);
                    i--; // Adjust index after splice
                }
            }
            var moduleCombInfo = g_pog_json[p_pog_index].ModuleInfo;
            for (g_module of moduleCombInfo) {
                var s = 0;
                var shelfCombInfo = g_pog_json[p_pog_index].ModuleInfo[m].ShelfInfo;
                for (shelf_info of shelfCombInfo) {
                    //ASA-1350 issue 6 variable name change
                    if ((shelf_info.ObjType == "SHELF" || shelf_info.ObjType == "HANGINGBAR") && shelf_info.Combine !== "N") {
                        await generateCombinedShelfs(p_pog_index, m, s, p_pogcrDelistItemDftColor, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemNumLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, "Y", p_calc_dayofsupply, "Y"); //ASA-1350 issue 6 added parameters //Regression 29(Portal Issue) added p_calc_dayofsupply
                    }
                    s++;
                }
                m++;
            }
        }
        render(p_pog_index);
    } catch (err) {
        error_handling(err);
    }
    return "SUCCESS";
}

function add_base(p_uuid, p_width, p_height, p_depth, p_color, p_x, p_y, p_edit_ind, p_pog_index) {
    logDebug("function : add_base; uuid : " + p_uuid + "; width : " + p_width + "; height : " + p_height + "; depth : " + p_depth + "; color : " + p_color + "; x : " + p_x + "; y : " + p_y + "; p_edit_ind : " + p_edit_ind, "S");
    try {
        return new Promise(function (resolve, reject) {
            if (p_edit_ind == "Y") {
                var selectedObject = g_scene_objects[p_pog_index].scene.children[2].getObjectById(g_pog_json[p_pog_index].BaseObjID);
                g_scene_objects[p_pog_index].scene.children[2].remove(selectedObject);
            }

            var l_pog_base = new THREE.Mesh( //Fix to removed global variable
                new THREE.BoxGeometry(p_width, p_height, 0.001),
                new THREE.MeshStandardMaterial({
                    color: p_color,
                })
            );
            var l_wireframe_id = add_wireframe(l_pog_base, 2);
            l_pog_base.position.x = p_x;
            l_pog_base.position.y = p_y;
            l_pog_base.position.z = 0;
            l_pog_base.uuid = p_uuid;
            g_world.add(l_pog_base);
            g_pog_json[p_pog_index].BaseObjID = l_pog_base.id;
            g_pog_json[p_pog_index].BaseX = p_x;
            g_pog_json[p_pog_index].BaseY = p_y;
            g_pog_json[p_pog_index].BaseZ = 0;
            g_pog_json[p_pog_index].WFrameID = l_wireframe_id;
            resolve("SUCCESS");
            logDebug("function : add_base", "E");
        });
    } catch (err) {
        error_handling(err);
    }
}

function add_notches(p_uuid, p_width, p_height, p_start, p_spacing, p_color, p_edit_ind, p_module_width, p_module_count, p_module_object, p_pog_index) {
    try {
        logDebug("function : add_notches; uuid : " + p_uuid + "; width : " + p_width + "; height : " + p_height + "; start : " + p_start + "; spacing : " + p_spacing + "; color : " + p_color + "; p_edit_ind : " + p_edit_ind + "; p_module_width : " + p_module_width + "; module_count : " + p_module_count, "S");
        var z = 0.0002; //0.0001 //ASA-1950 Issue5

        var l_notches1 = new THREE.Mesh(
            new THREE.BoxGeometry(p_width, p_height, 0.001),
            new THREE.MeshStandardMaterial({
                color: p_color,
            })
        );

        var l_notches2 = new THREE.Mesh(
            new THREE.BoxGeometry(p_width, p_height, 0.001),
            new THREE.MeshStandardMaterial({
                color: p_color,
            })
        );
        var wireframe_id1 = add_wireframe(l_notches1, 2);
        var wireframe_id2 = add_wireframe(l_notches2, 2);

        var l_notch_horz_start = 0 - parseFloat(p_width) / 2;
        var l_notch_vert_start = 0 - parseFloat(p_height) / 2 + parseFloat(p_start);
        var l_notch_horz_end = 0 + parseFloat(p_width) / 2;
        var l_notch_vert_end = 0 + parseFloat(p_height) / 2;

        var curr_vert_value = l_notch_vert_start;
        var verti_values = [];

        verti_values.push(curr_vert_value);
        for (var i = 0; i < 1000; i++) {
            curr_vert_value += parseFloat(p_spacing);
            if (curr_vert_value < l_notch_vert_end) verti_values.push(curr_vert_value);
            else break;
        }

        //var geometry = new THREE.Geometry();
        var points = [];

        for (i = 0; i < verti_values.length; i++) {
            points.push(new THREE.Vector3(l_notch_horz_start, verti_values[i], 0));
            points.push(new THREE.Vector3(l_notch_horz_end, verti_values[i], 0));
        }
        let geometry = new THREE.BufferGeometry().setFromPoints(points);
        var material = new THREE.LineBasicMaterial({
            color: 0x000000,
        });

        var line1 = new THREE.LineSegments(geometry, material);
        var line2 = new THREE.LineSegments(geometry, material);

        line1.position.z = 0.0005; // 0.0006 //ASA-1608 Issue 2
        line2.position.z = 0.0005; //0.0006 //ASA-1608 Issue 2
        l_notches1.add(line1);
        l_notches2.add(line2);
        var notch1_x = 0 - parseFloat(p_module_width) / 2 + parseFloat(p_width) / 2;
        var notch2_x = 0 - parseFloat(p_module_width) / 2 + (parseFloat(p_module_width) - parseFloat(p_width) / 2);
        l_notches1.position.x = notch1_x;
        l_notches1.position.y = 0;
        l_notches1.position.z = z;
        l_notches2.position.x = notch2_x;
        l_notches2.position.y = 0;
        l_notches2.position.z = z;
        p_module_object.add(l_notches1);
        p_module_object.add(l_notches2);

        l_notches1.uuid = p_uuid + 1;
        l_notches2.uuid = p_uuid + 2;
        g_pog_json[p_pog_index].ModuleInfo[p_module_count].Notch1X = notch1_x;
        g_pog_json[p_pog_index].ModuleInfo[p_module_count].Notch1Y = 0;
        g_pog_json[p_pog_index].ModuleInfo[p_module_count].Notch1Z = z;
        g_pog_json[p_pog_index].ModuleInfo[p_module_count].Notch1ObjID = l_notches1.id;
        g_pog_json[p_pog_index].ModuleInfo[p_module_count].Notch2X = notch2_x;
        g_pog_json[p_pog_index].ModuleInfo[p_module_count].Notch2Y = 0;
        g_pog_json[p_pog_index].ModuleInfo[p_module_count].Notch2Z = z;
        g_pog_json[p_pog_index].ModuleInfo[p_module_count].Notch2ObjID = l_notches2.id;
        logDebug("function : add_notches", "E");
    } catch (err) {
        error_handling(err);
    }
}

function add_chest_dots_array(p_width, p_height, p_vert_start, p_vert_spacing, p_horz_start, p_horz_spacing, p_shelf_cnt, p_module_index, p_pog_index) {
    var dot_center = 0;
    var l_horz_start = 0 - p_width / 2 + dot_center;
    var l_vert_start = 0 + p_height / 2 - dot_center;
    var l_horz_end = 0 + p_width / 2 - dot_center;
    var l_vert_end = 0 - p_height / 2 + dot_center;

    var horiz_values = [],
        vert_values = [];
    var curr_vert_value = l_vert_start;
    var curr_horiz_value = l_horz_start;

    vert_values.push(curr_vert_value);
    for (var i = 0; i < 1000; i++) {
        curr_vert_value -= p_vert_spacing;
        if (curr_vert_value > l_vert_end) vert_values.push(curr_vert_value);
        else break;
    }

    horiz_values.push(curr_horiz_value);
    for (var i = 0; i < 1000; i++) {
        curr_horiz_value += parseFloat(p_horz_spacing);
        if (curr_horiz_value < l_horz_end) horiz_values.push(curr_horiz_value);
        else break;
    }

    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_cnt].peg_vert_values = vert_values;
    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_cnt].peg_horiz_values = horiz_values;
}

function add_dots_to_object(p_width, p_height, p_z, p_vert_start, p_vert_spacing, p_horz_start, p_horz_spacing, p_object, p_object_type, p_shelf_cnt, p_edit_module_index, p_pegHolesActive, p_ViewInd3D = "N", p_pog_index) {
    try {
        logDebug("function : add_dots_to_object", "S");
        var dot_center = 0.01;
        var l_horz_start = 0 - p_width / 2 + p_horz_start + dot_center;
        var l_vert_start = 0 + p_height / 2 - p_vert_start - dot_center;
        var l_horz_end = 0 + p_width / 2 - dot_center;
        var l_vert_end = 0 - p_height / 2 + dot_center;

        var horiz_values = [],
            vert_values = [];
        var curr_vert_value = l_vert_start;
        var curr_horiz_value = l_horz_start;

        vert_values.push(curr_vert_value);
        for (var i = 0; i < 1000; i++) {
            curr_vert_value -= p_vert_spacing;
            if (curr_vert_value > l_vert_end) vert_values.push(curr_vert_value);
            else break;
        }

        horiz_values.push(curr_horiz_value);
        for (var i = 0; i < 1000; i++) {
            curr_horiz_value += parseFloat(p_horz_spacing);
            if (curr_horiz_value < l_horz_end) horiz_values.push(curr_horiz_value);
            else break;
        }
        var points = [];

        for (i = 0; i < vert_values.length; i++) {
            for (j = 0; j < horiz_values.length; j++) {
                points.push(new THREE.Vector3(horiz_values[j], vert_values[i], -0.0001));
            }
        }
        let dotGeometry = new THREE.BufferGeometry().setFromPoints(points);

        var dotMaterial = new THREE.PointsMaterial({
            size: 0.03,
            color: 0x000000,
        });

        var dot = new THREE.Points(dotGeometry, dotMaterial);
        if (p_ViewInd3D == "N") {
            if (p_pegHolesActive == "N") {
                dot.position.z = 0.0006;
            } else {
                dot.position.z = p_z;
            }
        } else {
            dot.position.z = p_z / 2;
        }

        p_object.add(dot);
        if (p_ViewInd3D == "N") {
            dot.uuid = "pegdots";
            if (p_object_type == "PEGBOARD") {
                g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].ShelfInfo[p_shelf_cnt].peg_vert_values = vert_values;
                g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].ShelfInfo[p_shelf_cnt].peg_horiz_values = horiz_values;
            } else {
                g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].peg_vert_values = vert_values;
                g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].peg_horiz_values = horiz_values;
            }
        }
        logDebug("function : add_dots_to_object", "E");
        return p_object;
    } catch (err) {
        logDebug("function : add_dots_to_object", "E");
        error_handling(err);
    }
}

function add_dots_to_object_3d(p_width, p_height, p_z, p_vert_start, p_vert_spacing, p_horz_start, p_horz_spacing, p_object, p_object_type, p_shelf_cnt, p_edit_module_index) {
    return add_dots_to_object(p_width, p_height, p_z, p_vert_start, p_vert_spacing, p_horz_start, p_horz_spacing, p_object, p_object_type, p_shelf_cnt, p_edit_module_index, null, null, "Y", g_pog_index);
}

async function create_shelf_from_json_lib(p_mod_index, p_json_array, p_module_width, p_draft_ind, p_new_pog_ind, p_pog_type, p_recreate, p_create_json, p_CopyJsonInd, p_copyJson, p_showSingleModule, p_org_mod_index, p_SpreadItem, p_HorizSpacing, p_VertiSpacing, p_BsktWallThickness, p_ChestWallThickness, p_AutoPlacing, p_WrapText, p_FSize, p_TextboxColor, p_ShelfColor, p_ItemColor, p_ItemDelistColor, p_pogCarparkShelfDftColor, p_enlargeNo, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrDelistItemDftColor, p_pogcrItemNumLabelColor, p_pogcrDisplayItemInfo, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_updateObjInd = "N", p_notchHead, p_pDftBskFill, p_pDftBaskSprd, p_camera, p_pog_index, p_orgPogIndex, p_m_crush = "N", p_crush_item = "N") {
    //ASA1310 KUSH FIX
    logDebug("function : create_shelf_from_json_lib; mod_index : " + p_mod_index + "; p_module_width : " + p_module_width + "; draft_ind : " + p_draft_ind + "; new_pog_ind : " + p_new_pog_ind + "; pog_type : " + p_pog_type + "; recreate : " + p_recreate, "S");
    try {
        var total_mod_width = 0;
        if (p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.length > 0 && p_draft_ind == "N" && p_recreate == "Y") {
            g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.splice(0);
            var l_shelf_cnt = 0;
            for (const shelfs of p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo) {
                var selectedObject = g_world.getObjectById(shelfs.SObjID);
                g_world.remove(selectedObject);
                l_shelf_cnt++;
            }
        }

        if (p_showSingleModule == "Y") {
            total_mod_width = p_json_array[p_pog_index].TotalModWidth;
        }
        if (typeof p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo !== "undefined") {
            if (p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.length > 0) {
                l_shelf_details = p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo;
                l_shelf_details.sort((a, b) => (a.Y > b.Y ? 1 : -1));
                if (p_CopyJsonInd == "Y") {
                    copy_shelf = p_copyJson[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo;
                    copy_shelf.sort((a, b) => (a.Y > b.Y ? 1 : -1));
                }
                if (g_json.length > 0) {
                    //ASA-1418
                    g_json_shelf = g_json[0].ModuleInfo[p_mod_index].ShelfInfo;
                    g_json_shelf.sort((a, b) => (a.Y > b.Y ? 1 : -1));
                }
                var i = 0;
                for (const shelfs of l_shelf_details) {
                    //p_new_pog_ind == "N" && p_pog_type == "F" -- means its json created from table data or coming from mass update.
                    //this code below will create a divider ItemInfo. this is needed because we treat divider as an item in the screen. so we will have
                    //one ItemInfo for each divider which will also have a ShelfInfo. Note: we will always update the details of ShelfInfo and ItemInfo
                    //if any divider is edited or moved.
                    if (((shelfs.ObjType == "DIVIDER" && p_new_pog_ind == "N" && p_pog_type == "F") || (shelfs.ObjType == "DIVIDER" && p_new_pog_ind == "T" && p_pog_type == "D")) && p_create_json == "Y") {
                        var shelf_arr = p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo;
                        var min_distance_arr = [];
                        var min_index_arr = [];
                        var l_shelf_cnt = 0;
                        //below code is checking the nearest shelf below the dividers Y axis. that means in which shelf it was placed.
                        for (const shelfs_detail of shelf_arr) {
                            if (shelfs_detail.ObjType !== "BASE" && shelfs_detail.ObjType !== "NOTCH" && shelfs_detail.ObjType !== "DIVIDER" && shelfs_detail.ObjType !== "TEXTBOX") {
                                if (p_new_pog_ind == "N" && p_pog_type == "F") {
                                    var shelf_x = wpdSetFixed(shelfs_detail.X + shelfs_detail.W / 2);
                                } else {
                                    var shelf_x = wpdSetFixed(shelfs_detail.X);
                                }
                                if (wpdSetFixed(shelfs_detail.Y) < wpdSetFixed(shelfs.Y) && wpdSetFixed(shelf_x - shelfs_detail.W) <= wpdSetFixed(shelfs.X - shelfs.W / 2) && wpdSetFixed(shelf_x + shelfs_detail.W) >= wpdSetFixed(shelfs.X + shelfs.W / 2)) {
                                    //ASA-1171
                                    min_distance_arr.push(wpdSetFixed(shelfs.Y - shelfs_detail.Y));
                                    min_index_arr.push(l_shelf_cnt);
                                }
                            }
                            l_shelf_cnt++;
                        }

                        if (min_distance_arr.length > 0) {
                            var min_distance = Math.min.apply(Math, min_distance_arr);
                            var index = min_distance_arr.findIndex(function (number) {
                                return number == min_distance;
                            });
                            div_shelf_index = min_index_arr[index];
                        } else {
                            div_shelf_index = 0;
                        }
                        if (p_CopyJsonInd == "Y") {
                            var copy_index = -1;
                            var p = 0;
                            for (const copy_details of copy_shelf) {
                                if (copy_details.Shelf == p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[div_shelf_index].Shelf) {
                                    CopyShelf = shelfs;
                                    copy_index = p;
                                    break;
                                }
                                p++;
                            }
                        }
                        console.log("div_shelf_index,", div_shelf_index, min_distance_arr, min_index_arr);
                        //Item Info for that divider is added in the shelf found above.
                        var ItemInfo = {};
                        ItemInfo["ItemID"] = shelfs.Shelf;
                        ItemInfo["Item"] = shelfs.ObjType;
                        ItemInfo["W"] = wpdSetFixed(shelfs.W);
                        ItemInfo["H"] = wpdSetFixed(shelfs.H);
                        ItemInfo["D"] = wpdSetFixed(shelfs.D);
                        ItemInfo["Color"] = shelfs.Color;
                        ItemInfo["DimT"] = "";
                        ItemInfo["Desc"] = shelfs.Desc;
                        ItemInfo["Barcode"] = "";
                        ItemInfo["LocID"] = "";
                        ItemInfo["PegID"] = "";
                        ItemInfo["PegSpread"] = "";
                        ItemInfo["PegPerFacing"] = "";
                        ItemInfo["Fixed"] = "N";
                        ItemInfo["CapStyle"] = "";
                        /*ASA-1170, Start*/
                        ItemInfo["CapFacing"] = "";
                        ItemInfo["CapMerch"] = "";
                        ItemInfo["CapOrientaion"] = "";
                        ItemInfo["CapHeight"] = "";
                        /*ASA-1170, End*/
                        ItemInfo["CapHorz"] = ""; //ASA-1179
                        ItemInfo["CapDepth"] = ""; //ASA-1179
                        ItemInfo["CapTotalCount"] = ""; //ASA-1179
                        ItemInfo["Rotation"] = shelfs.Rotation;
                        ItemInfo["BHoriz"] = 1;
                        ItemInfo["BVert"] = 1;
                        ItemInfo["BaseD"] = 1;
                        ItemInfo["CrushHoriz"] = 0;
                        ItemInfo["CrushVert"] = 0;
                        ItemInfo["CrushD"] = 0;
                        ItemInfo["Orientation"] = "0";
                        ItemInfo["MerchStyle"] = "0";
                        ItemInfo["Supplier"] = "";
                        ItemInfo["Brand"] = "";
                        ItemInfo["BrandType"] = "";
                        ItemInfo["Group"] = "";
                        ItemInfo["Dept"] = "";
                        ItemInfo["Class"] = "";
                        ItemInfo["SubClass"] = "";
                        ItemInfo["StdUOM"] = "";
                        ItemInfo["SizeDesc"] = "";
                        ItemInfo["Price"] = "";
                        ItemInfo["Cost"] = "";
                        ItemInfo["RegMovement"] = "";
                        ItemInfo["RegMovementInd"] = "";
                        ItemInfo["DaysOfSupplyInd"] = "";
                        ItemInfo["MoveBasis"] = "";
                        ItemInfo["AvgSales"] = "";
                        ItemInfo["AvgSalesInd"] = "";
                        ItemInfo["ItemStatus"] = "";
                        ItemInfo["CDTLvl1"] = ""; //ASA-1130
                        ItemInfo["CDTLvl2"] = ""; //ASA-1130
                        ItemInfo["CDTLvl3"] = ""; //ASA-1130
                        ItemInfo["ActualDPP"] = ""; //ASA-1277-(3)
                        ItemInfo["StoreSOH"] = ""; //ASA-1277-(3)
                        ItemInfo["StoreNo"] = ""; //ASA-1277-(3)
                        ItemInfo["WeeksOfInventory"] = ""; //ASA-1277-(3)
                        ItemInfo["DPPLoc"] = ""; //ASA-1308 Task-3
                        ItemInfo["CHPerc"] = 0;
                        ItemInfo["CWPerc"] = 0;
                        ItemInfo["CDPerc"] = 0;
                        ItemInfo["ItemNesting"] = 0;
                        ItemInfo["NVal"] = 0;
                        ItemInfo["ItemContain"] = 0;
                        ItemInfo["CnVal"] = 0;
                        ItemInfo["IsContainer"] = "N";
                        ItemInfo["BsktFactor"] = 0;
                        ItemInfo["OverHang"] = 0;
                        ItemInfo["HorizGap"] = 0;
                        ItemInfo["VertGap"] = 0;
                        ItemInfo["UW"] = 0;
                        ItemInfo["UH"] = 0;
                        ItemInfo["UD"] = 0;
                        ItemInfo["CW"] = 0;
                        ItemInfo["CH"] = 0;
                        ItemInfo["CD"] = 0;
                        ItemInfo["TW"] = 0;
                        ItemInfo["TH"] = 0;
                        ItemInfo["TD"] = 0;
                        ItemInfo["DW"] = 0;
                        ItemInfo["DH"] = 0;
                        ItemInfo["DD"] = 0;
                        ItemInfo["CnW"] = 0;
                        ItemInfo["CnH"] = 0;
                        ItemInfo["CnD"] = 0;
                        ItemInfo["NW"] = 0;
                        ItemInfo["NH"] = 0;
                        ItemInfo["ND"] = 0;
                        ItemInfo["OrgUW"] = 0;
                        ItemInfo["OrgUH"] = 0;
                        ItemInfo["OrgUD"] = 0;
                        ItemInfo["OrgCW"] = 0;
                        ItemInfo["OrgCH"] = 0;
                        ItemInfo["OrgCD"] = 0;
                        ItemInfo["OrgTW"] = 0;
                        ItemInfo["OrgTH"] = 0;
                        ItemInfo["OrgTD"] = 0;
                        ItemInfo["OrgDW"] = 0;
                        ItemInfo["OrgDH"] = 0;
                        ItemInfo["OrgDD"] = 0;
                        ItemInfo["OrgCHPerc"] = 0;
                        ItemInfo["OrgCWPerc"] = 0;
                        ItemInfo["OrgCDPerc"] = 0;
                        ItemInfo["OrgCnW"] = 0;
                        ItemInfo["OrgCnH"] = 0;
                        ItemInfo["OrgCnD"] = 0;
                        ItemInfo["OrgNW"] = 0;
                        ItemInfo["OrgNH"] = 0;
                        ItemInfo["OrgND"] = 0;
                        ItemInfo["SIndex"] = div_shelf_index;
                        ItemInfo["Dragged"] = "N";
                        ItemInfo["Quantity"] = 1;
                        ItemInfo["X"] = wpdSetFixed(shelfs.X - p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[div_shelf_index].X); //shelfs.X;Task-02_25977 prasanna 20240215 divider iteminfo is now set with start point from shelf start.
                        ItemInfo["Y"] = wpdSetFixed(shelfs.Y);
                        ItemInfo["Z"] = 0.001;
                        ItemInfo["SlotDivider"] = "N";
                        ItemInfo["ImgExists"] = "N";
                        ItemInfo["CapCount"] = 0;
                        ItemInfo["Exists"] = "E";
                        ItemInfo["OW"] = wpdSetFixed(ItemInfo["W"]);
                        ItemInfo["OH"] = wpdSetFixed(ItemInfo["H"]);
                        ItemInfo["OD"] = wpdSetFixed(ItemInfo["D"]);
                        ItemInfo["Distance"] = wpdSetFixed(shelfs.X - p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[div_shelf_index].X);
                        ItemInfo["YDistance"] = wpdSetFixed(shelfs.Y - (p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[div_shelf_index].Y + p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[div_shelf_index].H / 2));
                        ItemInfo["SpreadItem"] = 0;
                        ItemInfo["MHorizCrushed"] = "N";
                        ItemInfo["MVertCrushed"] = "N";
                        ItemInfo["MDepthCrushed"] = "N";
                        ItemInfo["MCapTopFacing"] = "N"; //ASA-1170
                        ItemInfo["RW"] = wpdSetFixed(ItemInfo["W"]);
                        ItemInfo["RH"] = wpdSetFixed(ItemInfo["H"]);
                        ItemInfo["RD"] = wpdSetFixed(ItemInfo["D"]);
                        ItemInfo["LObjID"] = -1;
                        ItemInfo["SubLblObjID"] = -1; //ASA-1182
                        ItemInfo["DimUpdate"] = "N";
                        ItemInfo["TopObjID"] = "";
                        ItemInfo["BottomObjID"] = "";
                        ItemInfo["SecondTier"] = "";
                        ItemInfo["CompItemObjID"] = "";
                        ItemInfo["SellingPrice"] = "";
                        //ASA-2013 Start
                        ItemInfo["ShelfPrice"] = "";
                        ItemInfo["PromoPrice"] = "";
                        ItemInfo["DiscountRate"] = "";
                        ItemInfo["PriceChangeDate"] = "";
                        ItemInfo["WeeksOfInventory"] = "";
                        ItemInfo["Qty"] = "";
                        ItemInfo["WhStock"] = "";
                        ItemInfo["StoreStock"] = "";
                        ItemInfo["StockIntransit"] = "";
                        //ASA-2013 End
                        ItemInfo["SalesUnit"] = "";
                        ItemInfo["NetSales"] = "";
                        ItemInfo["CogsAdj"] = "";
                        ItemInfo["CogsAdjInd"] = "";
                        ItemInfo["GrossProfit"] = "";
                        ItemInfo["GrossProfitInd"] = "";
                        ItemInfo["WeeksCount"] = "";
                        ItemInfo["WeeksCountInd"] = "";
                        ItemInfo["MovingItem"] = "";
                        ItemInfo["Profit"] = "";
                        ItemInfo["TotalMargin"] = "";
                        ItemInfo["MHorizFacings"] = -1;
                        ItemInfo["MVertFacings"] = -1;
                        ItemInfo["MPogDepthFacings"] = ""; //ASA-1408
                        ItemInfo["MPogHorizFacings"] = ""; //ASA-1408
                        ItemInfo["MPogVertFacings"] = ""; //ASA-1408
                        ItemInfo["MDepthFacings"] = -1;
                        ItemInfo["OrientationDesc"] = "Front 0";
                        ItemInfo["StoreCnt"] = "";
                        ItemInfo["CapMaxH"] = "";
                        ItemInfo["MaxHCapStyle"] = "";
                        ItemInfo["NewYN"] = "";
                        ItemInfo["Delist"] = "N";
                        ItemInfo["DescSecond"] = "";
                        ItemInfo["NewPegId"] = "";
                        ItemInfo["OverhungItem"] = "N"; //ASA-1138
                        ItemInfo["AutoDiv"] = "N"; //ASA-1406
                        ItemInfo["UDA751"] = ""; //ASA-1407 Task 1 -S
                        ItemInfo["UDA755"] = ""; //ASA-1407 Task 1 -E
                        ItemInfo["DivHeight"] = wpdSetFixed(shelfs.DivHeight); //Start Task_27734
                        ItemInfo["DivWidth"] = wpdSetFixed(shelfs.DivWidth);
                        ItemInfo["DivPst"] = shelfs.DivPst;
                        ItemInfo["DivPed"] = shelfs.DivPed;
                        ItemInfo["DivPbtwFace"] = shelfs.DivPbtwFace;
                        ItemInfo["DivStX"] = isNaN(shelfs.DivStX) ? 0 : shelfs.DivStX; //Task_27734
                        ItemInfo["DivSpaceX"] = isNaN(shelfs.DivSpaceX) ? 0 : shelfs.DivSpaceX; //Task_27734
                        ItemInfo["DivFillCol"] = shelfs.DivFillCol;
                        ItemInfo["NoDivIDShow"] = shelfs.NoDivIDShow; // End Task_27734
                        //ASA-1640 Start
                        ItemInfo["ItemCondition"] = "";
                        ItemInfo["AUR"] = "";
                        ItemInfo["ItemRanking"] = "";
                        ItemInfo["WeeklySales"] = "";
                        ItemInfo["WeeklyNetMargin"] = "";
                        ItemInfo["WeeklyQty"] = "";
                        ItemInfo["NetMarginPercent"] = "";
                        ItemInfo["CumulativeNM"] = "";
                        ItemInfo["TOP80B2"] = "";
                        ItemInfo["ItemBrandC"] = "";
                        ItemInfo["ItemPOGDept"] = "";
                        ItemInfo["ItemRemark"] = "";
                        ItemInfo["RTVStatus"] = "";
                        ItemInfo["Pusher"] = "";
                        ItemInfo["Divider"] = "";
                        ItemInfo["BackSupport"] = "";
                        //ASA-1640 End
                        ItemInfo["OOSPerc"] = ""; //ASA-1688 Added for OOS%
                        ItemInfo["InitialItemDesc"] = ""; //ASA-1734 Issue 1
                        ItemInfo["InitialBrand"] = ""; //ASA-1787 Request #6
                        ItemInfo["InitialBarcode"] = ""; //ASA-1787 Request #6

                        p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[div_shelf_index].ItemInfo.push(ItemInfo);
                        if (p_CopyJsonInd == "Y") {
                            p_copyJson[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[copy_index].ItemInfo.splice(0, 0, ItemInfo);
                        }
                        if (g_json.length > 0) {
                            //ASA-1418 //20240722 - Regression Issue 6
                            if (g_json[0].ModuleInfo[p_mod_index].ShelfInfo[div_shelf_index].ObjType !== "BASE" && g_json[0].ModuleInfo[p_mod_index].ShelfInfo[div_shelf_index].ObjType !== "NOTCH" && g_json[0].ModuleInfo[p_mod_index].ShelfInfo[div_shelf_index].ObjType !== "TEXTBOX" && g_json[0].ModuleInfo[p_mod_index].ShelfInfo[div_shelf_index].ObjType !== "DIVIDER") {
                                //ASA-1418 Task 2 ,//Regression issue 2 20242507 change i to div_shelf_index in divider and textbox check
                                if (g_json[0].ModuleInfo[p_mod_index].ShelfInfo[div_shelf_index].ItemInfo == null || typeof g_json[0].ModuleInfo[p_mod_index].ShelfInfo[div_shelf_index].ItemInfo == 'undefined') {
                                    g_json[0].ModuleInfo[p_mod_index].ShelfInfo[div_shelf_index].ItemInfo = []; //ASA-1809
                                }
                                g_json[0].ModuleInfo[p_mod_index].ShelfInfo[div_shelf_index].ItemInfo.splice(0, 0, ItemInfo);
                            }
                        }
                    }
                }
            }
        }
        /*  //ASA-1530 S
          if (typeof p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo !== "undefined") {
              for (var i = 0; i < p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.length; i++) {
                  var divider = p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[i];
                  if (divider.ObjType == "DIVIDER") {
                      for (var shelf of p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo) {
                          if (shelf.ObjType !== "BASE" && shelf.ObjType !== "NOTCH" && shelf.ObjType !== "DIVIDER" && shelf.ObjType !== "TEXTBOX" &&
                              (typeof g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ParentModule == "undefined" || g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ParentModule == null)) {
                              var isItemFound = false;
  
                              for (var divitem of shelf.ItemInfo) {
                                  if (divitem.ItemID == divider.Shelf) {
                                      isItemFound = true;
                                      break;
                                  }
                              }
                              if (!isItemFound) {
                                  p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.splice(i, 1);
                                  i--;
                                  break;
                              }
                          }
                      }
                  }
              }
          }//ASA-1530 E
          */
        if (typeof p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo !== "undefined") {
            if (p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.length > 0) {
                l_shelf_details = p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo;
                l_shelf_details.sort((a, b) => (a.Y > b.Y && a.ObjType !== "NOTCH" && a.ObjType !== "BASE" ? 1 : -1));

                if (g_json.length > 0) {
                    //ASA-1418 Task 2
                    l_json_shelf_details = g_json[0].ModuleInfo[p_mod_index].ShelfInfo; //Regression Issue 3
                    l_json_shelf_details.sort((a, b) => (a.Y > b.Y && a.ObjType !== "NOTCH" && a.ObjType !== "BASE" ? 1 : -1));
                }

                if (p_CopyJsonInd == "Y") {
                    copy_shelf = p_copyJson[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo;
                    copy_shelf.sort((a, b) => (a.Y > b.Y && a.ObjType !== "NOTCH" && a.ObjType !== "BASE" ? 1 : -1));
                }
                var i = 0;
                var shelf_ind = -1;
                var CopyShelf = {};
                for (const shelfs of l_shelf_details) {
                    if (p_CopyJsonInd == "Y") {
                        var copy_index = -1;
                        var p = 0;
                        for (const copy_details of copy_shelf) {
                            if (copy_details.Shelf == shelfs.Shelf) {
                                CopyShelf = shelfs;
                                copy_index = p;
                                break;
                            }
                            p++;
                        }
                    }
                    var ShelfInfo = {};
                    if (p_create_json == "Y") {
                        //this below if is true when json is created from tables or from mass update.
                        if (p_new_pog_ind == "N" && p_pog_type == "F") {
                            ShelfInfo["GrillH"] = 0;
                            ShelfInfo["LOverhang"] = shelfs.LOverhang !== null && shelfs.LOverhang !== "" && typeof shelfs.LOverhang !== "undefined" ? shelfs.LOverhang : 0; //ASA-1310
                            ShelfInfo["ROverhang"] = shelfs.ROverhang !== null && shelfs.ROverhang !== "" && typeof shelfs.ROverhang !== "undefined" ? shelfs.ROverhang : 0; //ASA-1310
                            ShelfInfo["SpacerThick"] = 0;
                            ShelfInfo["HorizGap"] = shelfs.HorizGap !== null && shelfs.HorizGap !== "" && typeof shelfs.HorizGap !== "undefined" ? shelfs.HorizGap : 0; //ASA-1902
                            ShelfInfo["SpreadItem"] = shelfs.SpreadItem !== null && shelfs.SpreadItem !== "" && typeof shelfs.SpreadItem !== "undefined" ? shelfs.SpreadItem : p_SpreadItem; //ASA-1310
                            ShelfInfo["Combine"] = shelfs.Combine !== null && shelfs.Combine !== "" && typeof shelfs.Combine !== "undefined" ? shelfs.Combine : "N"; //ASA-1310;
                            ShelfInfo["AllowAutoCrush"] = shelfs.AllowAutoCrush !== null && shelfs.AllowAutoCrush !== "" && typeof shelfs.AllowAutoCrush !== "undefined" ? shelfs.AllowAutoCrush : "N"; //ASA-1310;
                            ShelfInfo["AutoPlacing"] = shelfs.AutoPlacing !== null && shelfs.AutoPlacing !== "" && typeof shelfs.AutoPlacing !== "undefined" ? shelfs.AutoPlacing : p_AutoPlacing; //ASA-1310 prasanna ASA-1310_25890
                            ShelfInfo["AutoDepthCalc"] = shelfs.AutoDepthCalc !== null && shelfs.AutoDepthCalc !== "" && typeof shelfs.AutoDepthCalc !== "undefined" ? shelfs.AutoDepthCalc : "N"; // ASA-1351
                            ShelfInfo["MSpreadItem"] = shelfs.MSpreadItem !== null && shelfs.MSpreadItem !== "" && typeof shelfs.MSpreadItem !== "undefined" ? shelfs.MSpreadItem : "N"; // ASA-1350
                            ShelfInfo["SMassUpdate"] = shelfs.SMassUpdate !== null && shelfs.SMassUpdate !== "" && typeof shelfs.SMassUpdate !== "undefined" ? shelfs.SMassUpdate : "N"; // ASA-1349 issue 14
                            ShelfInfo["HorizSlotStart"] = 0;
                            if (shelfs.ObjType == "PEGBOARD") {
                                ShelfInfo["HorizSpacing"] = p_HorizSpacing;
                                ShelfInfo["VertiSpacing"] = p_VertiSpacing;
                            } else {
                                ShelfInfo["HorizSpacing"] = 0;
                                ShelfInfo["VertiSpacing"] = 0;
                            }
                            ShelfInfo["HorizSlotSpacing"] = 0;
                            ShelfInfo["HorizStart"] = 0;
                            ShelfInfo["UOverHang"] = 0;
                            ShelfInfo["LoOverHang"] = 0;
                            ShelfInfo["VertiStart"] = 0;
                            ShelfInfo["BsktFill"] = p_pDftBskFill;
                            ShelfInfo["BsktSpreadProduct"] = p_pDftBaskSprd;
                            ShelfInfo["SnapTo"] = "N";
                            if (shelfs.ObjType == "BASKET" || shelfs.ObjType == "CHEST") {
                                if (shelfs.BsktWallH !== 0 && typeof shelfs.BsktWallH !== "undefined") {
                                    //ASA-1310 KUSH FIX added because if value is 0 in crush height then set wall height else maxmerch
                                    ShelfInfo["BsktWallH"] = shelfs.BsktWallH;
                                } else {
                                    ShelfInfo["BsktWallH"] = shelfs.MaxMerch;
                                }
                                ShelfInfo["BsktBaseH"] = shelfs.H;
                                if (shelfs.ObjType == "BASKET") {
                                    ShelfInfo["BsktWallThickness"] = p_BsktWallThickness;
                                } else {
                                    ShelfInfo["BsktWallThickness"] = p_ChestWallThickness;
                                }
                            } else {
                                ShelfInfo["BsktWallH"] = 0;
                                ShelfInfo["BsktBaseH"] = 0;
                                ShelfInfo["BsktWallThickness"] = 0;
                            }
                            ShelfInfo["DSlotStart"] = 0;
                            ShelfInfo["DSlotSpacing"] = 0;
                            ShelfInfo["DGap"] = 0;
                            ShelfInfo["FrontOverHang"] = 0;
                            ShelfInfo["BackOverHang"] = 0;
                            ShelfInfo["SlotDivider"] = "N";
                            ShelfInfo["AllowOverLap"] = "N";
                            ShelfInfo["AutoFillPeg"] = shelfs.AutoFillPeg; //ASA-1109
                            ShelfInfo["SlotOrientation"] = "";
                            ShelfInfo["DividerFixed"] = "N";
                            ShelfInfo["AvlSpace"] = 0;
                            if (p_showSingleModule == "Y") {
                                ShelfInfo["X"] = wpdSetFixed(shelfs.X + parseFloat(shelfs.W) / 2 - total_mod_width);
                            } else {
                                ShelfInfo["X"] = wpdSetFixed(shelfs.X + parseFloat(shelfs.W) / 2);
                            }
                            ShelfInfo["Y"] = wpdSetFixed(shelfs.Y + parseFloat(shelfs.H) / 2);
                            ShelfInfo["Z"] = wpdSetFixed(shelfs.Z + parseFloat(shelfs.D) / 2 + g_pog_json[p_pog_index].BackDepth);
                            ShelfInfo["WrapText"] = shelfs.WrapText !== null && shelfs.WrapText !== "" ? shelfs.WrapText : p_WrapText;  //ASA-2030
                            ShelfInfo["ReduceToFit"] = shelfs.ReduceToFit !== null && shelfs.ReduceToFit !== "" ? shelfs.ReduceToFit : "Y";  //ASA-2030
                            ShelfInfo["TextDirection"] = shelfs.TextDirection !== null && shelfs.TextDirection !== "" ? shelfs.TextDirection : "H"; //1797 Issue 1
                            ShelfInfo["FStyle"] = "Arial";
                            ShelfInfo["FSize"] = shelfs.FSize !== null && shelfs.FSize !== "" && shelfs.FSize !== 0 ? shelfs.FSize : p_FSize; //ASA-1950 p_FSize;
                            ShelfInfo["FBold"] = shelfs.Fbold;    //ASA-2030
                            ShelfInfo["canvasW"] = null;
                            ShelfInfo["canvasH"] = null;
                            ShelfInfo["peg_vert_values"] = [];
                            ShelfInfo["peg_horiz_values"] = [];
                            ShelfInfo["DivHeight"] = shelfs.DivHeight; //ASA-1387 Issue 3
                            ShelfInfo["DivWidth"] = shelfs.DivWidth; //ASA-1387 Issue 3
                            ShelfInfo["DivPst"] = shelfs.DivPst; //ASA-1387 Issue 3
                            ShelfInfo["DivPed"] = shelfs.DivPed; //ASA-1387 Issue 3
                            ShelfInfo["DivPbtwFace"] = shelfs.DivPbtwFace; //ASA-1387 Issue 3
                            ShelfInfo["DivStX"] = isNaN(shelfs.DivStX) ? 0 : shelfs.DivStX; //Task_27734 shelfs.DivStX; //ASA-1387 Issue 3
                            ShelfInfo["DivSpaceX"] = isNaN(shelfs.DivSpaceX) ? 0 : shelfs.DivSpaceX; //Task_27734 shelfs.DivSpaceX; //ASA-1387 Issue 3
                            ShelfInfo["DivFillCol"] = shelfs.DivFillCol; //ASA-1387 Issue 3
                            ShelfInfo["NoDivIDShow"] = typeof shelfs.NoDivIDShow == "undefined" && shelfs.NoDivIDShow !== "" ? "N" : shelfs.NoDivIDShow; //ASA-1406 //Task_27734
                            ShelfInfo["Overhung"] = typeof shelfs.Overhung == "undefined" && shelfs.Overhung !== "" ? "N" : shelfs.Overhung; //ASA-1138
                        } else {
                            //p_showSingleModule == 'Y' when opening POG from module view.
                            if (p_showSingleModule == "Y") {
                                ShelfInfo["X"] = wpdSetFixed(shelfs.X - total_mod_width);
                            } else {
                                ShelfInfo["X"] = wpdSetFixed(shelfs.X);
                            }
                            ShelfInfo["Y"] = wpdSetFixed(shelfs.Y); //parseFloat((shelfs.Y).toFixed(4)); //task_26589
                            ShelfInfo["Z"] = wpdSetFixed(shelfs.Z);
                            ShelfInfo["GrillH"] = shelfs.GrillH;
                            ShelfInfo["LOverhang"] = shelfs.LOverhang;
                            ShelfInfo["ROverhang"] = shelfs.ROverhang;
                            ShelfInfo["SpacerThick"] = shelfs.SpacerThick;
                            ShelfInfo["HorizGap"] = shelfs.HorizGap !== null && shelfs.HorizGap !== "" && typeof shelfs.HorizGap !== "undefined" ? shelfs.HorizGap : 0; //ASA-1902
                            ShelfInfo["SpreadItem"] = shelfs.SpreadItem;
                            ShelfInfo["Combine"] = shelfs.Combine;
                            ShelfInfo["AllowAutoCrush"] = shelfs.AllowAutoCrush;
                            ShelfInfo["HorizSlotStart"] = shelfs.HorizSlotStart;
                            ShelfInfo["HorizSlotSpacing"] = shelfs.HorizSlotSpacing;
                            ShelfInfo["HorizStart"] = shelfs.HorizStart;
                            ShelfInfo["HorizSpacing"] = shelfs.HorizSpacing;
                            ShelfInfo["UOverHang"] = shelfs.UOverHang;
                            ShelfInfo["LoOverHang"] = typeof shelfs.LoOverHang == "undefined" ? 0 : shelfs.LoOverHang;
                            ShelfInfo["VertiStart"] = shelfs.VertiStart;
                            ShelfInfo["VertiSpacing"] = shelfs.VertiSpacing;
                            ShelfInfo["BsktFill"] = shelfs.BsktFill;
                            ShelfInfo["BsktSpreadProduct"] = shelfs.BsktSpreadProduct;
                            ShelfInfo["SnapTo"] = shelfs.SnapTo;
                            ShelfInfo["BsktWallH"] = shelfs.BsktWallH;
                            ShelfInfo["BsktBaseH"] = shelfs.BsktBaseH;
                            ShelfInfo["BsktWallThickness"] = shelfs.BsktWallThickness;
                            ShelfInfo["DSlotStart"] = shelfs.DSlotStart;
                            ShelfInfo["DSlotSpacing"] = shelfs.DSlotSpacing;
                            ShelfInfo["DGap"] = shelfs.DGap;
                            ShelfInfo["FrontOverHang"] = shelfs.FrontOverHang;
                            ShelfInfo["BackOverHang"] = shelfs.BackOverHang;
                            ShelfInfo["SlotDivider"] = shelfs.SlotDivider;
                            ShelfInfo["AllowOverLap"] = shelfs.AllowOverLap;
                            ShelfInfo["AutoPlacing"] = typeof shelfs.AutoPlacing !== "undefined" && shelfs.AutoPlacing !== "" ? shelfs.AutoPlacing : "";
                            ShelfInfo["AutoFillPeg"] = typeof shelfs.AutoFillPeg !== "undefined" && shelfs.AutoFillPeg !== "" ? shelfs.AutoFillPeg : ""; //ASA-1109
                            ShelfInfo["AvlSpace"] = shelfs.W + shelfs.LOverhang + shelfs.ROverhang;
                            ShelfInfo["WrapText"] = shelfs.WrapText;
                            ShelfInfo["ReduceToFit"] = shelfs.ReduceToFit;
                            ShelfInfo["TextDirection"] = shelfs.TextDirection;
                            ShelfInfo["SlotOrientation"] = shelfs.SlotOrientation;
                            ShelfInfo["DividerFixed"] = shelfs.DividerFixed;
                            ShelfInfo["FStyle"] = shelfs.FStyle;
                            ShelfInfo["FSize"] = shelfs.FSize;
                            ShelfInfo["FBold"] = shelfs.FBold;
                            ShelfInfo["canvasW"] = shelfs.canvasW;
                            ShelfInfo["canvasH"] = shelfs.canvasH;
                            ShelfInfo["peg_vert_values"] = shelfs.peg_vert_values;
                            ShelfInfo["peg_horiz_values"] = shelfs.peg_horiz_values;
                            ShelfInfo["DivHeight"] = shelfs.DivHeight; //ASA-1265
                            ShelfInfo["DivWidth"] = shelfs.DivWidth; //ASA-1265
                            ShelfInfo["DivPst"] = shelfs.DivPst; //ASA-1265
                            ShelfInfo["DivPed"] = shelfs.DivPed; //ASA-1265
                            ShelfInfo["DivPbtwFace"] = shelfs.DivPbtwFace; //ASA-1265
                            ShelfInfo["DivStX"] = isNaN(shelfs.DivStX) ? 0 : shelfs.DivStX; //Task_27734 shelfs.DivStX; //ASA-1265
                            ShelfInfo["DivSpaceX"] = isNaN(shelfs.DivSpaceX) ? 0 : shelfs.DivSpaceX; //Task_27734 shelfs.DivSpaceX; //ASA-1265
                            ShelfInfo["DivFillCol"] = shelfs.DivFillCol; //ASA-1265
                            ShelfInfo["NoDivIDShow"] = shelfs.NoDivIDShow; //ASA-1406
                            ShelfInfo["Overhung"] = typeof shelfs.Overhung !== "undefined" && shelfs.Overhung !== "" ? shelfs.Overhung : "N"; //ASA-1138
                        }
                        ShelfInfo["ShelfDivObjID"] = shelfs.ShelfDivObjID;
                        ShelfInfo["ManualCrush"] = typeof shelfs.ManualCrush !== "undefined" && shelfs.ManualCrush !== "" ? shelfs.ManualCrush : p_m_crush; //ASA-1300
                        ShelfInfo["SplitChest"] = typeof shelfs.SplitChest !== "undefined" && shelfs.SplitChest !== "" ? shelfs.SplitChest : "N"; //Task_26627
                        ShelfInfo["Shelf"] = shelfs.Shelf;
                        ShelfInfo["POGCode"] = g_pog_json[p_pog_index].POGCode; //ASA-1243
                        ShelfInfo["Version"] = g_pog_json[p_pog_index].Version; //ASA-1243

                        ShelfInfo["ObjType"] = shelfs.ObjType;
                        ShelfInfo["Desc"] = shelfs.Desc;
                        ShelfInfo["MaxMerch"] = shelfs.MaxMerch;
                        ShelfInfo["LObjID"] = shelfs.LObjID;
                        ShelfInfo["OldObjID"] = shelfs.SObjID;
                        ShelfInfo["NotchNo"] = shelfs.NotchNo;
                        if (shelfs.TextImg == "" || typeof shelfs.TextImg == "undefined" || shelfs.TextImg == null) {
                            ShelfInfo["TextImg"] = "";
                            ShelfInfo["TextImgName"] = "";
                            ShelfInfo["TextImgMime"] = "";
                        } else {
                            ShelfInfo["TextImg"] = shelfs.TextImg;
                            ShelfInfo["TextImgName"] = shelfs.TextImgName; //ASA-1650 issue 10
                            ShelfInfo["TextImgMime"] = shelfs.TextImgMime; //ASA-1650 issue 10
                        }
                        if (shelfs.ObjType == "BASE") {
                            ShelfInfo["H"] = g_pog_json[p_pog_index].BaseH;
                            ShelfInfo["W"] = g_pog_json[p_pog_index].BaseW;
                            ShelfInfo["D"] = g_pog_json[p_pog_index].BaseD;
                            ShelfInfo["Color"] = g_pog_json[p_pog_index].Color;
                        } else if (shelfs.ObjType == "NOTCH") {
                            ShelfInfo["H"] = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].H;
                            ShelfInfo["W"] = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].NotchW;
                            ShelfInfo["D"] = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].D;
                            ShelfInfo["Color"] = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Color;
                        } else {
                            ShelfInfo["H"] = wpdSetFixed(shelfs.H);
                            ShelfInfo["W"] = wpdSetFixed(shelfs.W);
                            ShelfInfo["D"] = wpdSetFixed(shelfs.D);
                            if (shelfs.Color !== null) {
                                if (typeof shelfs.Color == "undefined" || shelfs.Color == "#0" || shelfs.Color.charAt(1) == "#") {
                                    if (ShelfInfo["ObjType"] == "TEXTBOX") {
                                        ShelfInfo["Color"] = p_TextboxColor;
                                    } else {
                                        ShelfInfo["Color"] = p_ShelfColor;
                                    }
                                } else {
                                    ShelfInfo["Color"] = shelfs.Color == "#FFFF" ? "#FFFFFF" : shelfs.Color;
                                }
                            } else {
                                if (ShelfInfo["ObjType"] == "TEXTBOX") {
                                    ShelfInfo["Color"] = p_TextboxColor;
                                } else {
                                    ShelfInfo["Color"] = p_ShelfColor;
                                }
                            }
                        }
                        if (shelfs.Rotation == null || typeof shelfs.Rotation == "undefined") {
                            ShelfInfo["Rotation"] = 0;
                        } else {
                            ShelfInfo["Rotation"] = shelfs.Rotation;
                        }
                        if (shelfs.Slope == null || typeof shelfs.Slope == "undefined") {
                            ShelfInfo["Slope"] = 0;
                        } else {
                            ShelfInfo["Slope"] = shelfs.Slope;
                        }

                        ShelfInfo["LiveImage"] = shelfs.LiveImage;
                        ShelfInfo["CompShelfObjID"] = shelfs.CompShelfObjID;
                        ShelfInfo["ManualZupdate"] = shelfs.ManualZupdate;
                        ShelfInfo["InputText"] = typeof shelfs.InputText !== "undefined" && shelfs.InputText !== null ? shelfs.InputText : "";
                        ShelfInfo["ChestEdit"] = shelfs.ChestEdit !== null && shelfs.ChestEdit !== "" && typeof shelfs.ChestEdit !== "undefined" ? shelfs.ChestEdit : "N"; //Bug-26122 - splitting the chest
                        ShelfInfo["ItemInfo"] = [];
                        ShelfInfo["InsidePegboard"] = shelfs.InsidePegboard; //ASA - 1544 Issue 1
                        g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.push(ShelfInfo);
                        shelf_ind = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.length - 1;
                    } else {
                        ShelfInfo = shelfs;
                        shelf_ind = i;
                    }

                    var final_height = 0;

                    if (typeof g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ParentModule == "undefined" || (g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ParentModule == null && p_recreate == "Y")) {
                        var colorValue = parseInt(ShelfInfo["Color"].replace("#", "0x"), 16);
                        var hex_decimal = new THREE.Color(colorValue);
                        if (ShelfInfo["ObjType"] == "PEGBOARD") {
                            var return_val = add_pegboard(ShelfInfo["Shelf"], ShelfInfo["W"], ShelfInfo["H"], ShelfInfo["D"], hex_decimal, ShelfInfo["X"], ShelfInfo["Y"], 0.004, "N", ShelfInfo["VertiStart"], ShelfInfo["VertiSpacing"], ShelfInfo["HorizStart"], ShelfInfo["HorizSpacing"], p_mod_index, shelf_ind, ShelfInfo["Rotation"], ShelfInfo["Slope"], "N", p_pogcrDelistItemDftColor, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_pog_index); //ASA-1350 issue 6 added parameters
                        } else if (ShelfInfo["ObjType"] == "TEXTBOX") {
                            //Start ASA-1371_26842 Prod issue text box image not printed in PDF when live image is on and generate PDF.
                            if (ShelfInfo["Color"].charAt(1) == "#" && ShelfInfo["ObjType"] == "TEXTBOX") {
                                var bg_color = null;
                            } else {
                                var bg_color = colorValue;
                            }
                            if (g_show_live_image == "Y" && ShelfInfo["TextImg"] !== "" && typeof ShelfInfo["TextImg"] !== "undefined" && ShelfInfo["TextImg"] !== null) {
                                var return_val = await add_text_box_with_image(ShelfInfo["Shelf"], "TEXTBOX", ShelfInfo["W"], ShelfInfo["H"], ShelfInfo["D"], hex_decimal, ShelfInfo["X"], ShelfInfo["Y"], ShelfInfo["Z"], "N", p_mod_index, ShelfInfo["InputText"], bg_color, ShelfInfo["WrapText"], ShelfInfo["ReduceToFit"], ShelfInfo["Color"], shelf_ind, ShelfInfo["Rotation"], ShelfInfo["Slope"], "N", ShelfInfo["FStyle"], ShelfInfo["FSize"], ShelfInfo["FBold"], p_notchHead, p_pog_index);
                            } else {
                                var return_val = add_text_box(ShelfInfo["Shelf"], "TEXTBOX", ShelfInfo["W"], ShelfInfo["H"], ShelfInfo["D"], hex_decimal, ShelfInfo["X"], ShelfInfo["Y"], ShelfInfo["Z"], "N", p_mod_index, ShelfInfo["InputText"], bg_color, ShelfInfo["WrapText"], ShelfInfo["ReduceToFit"], ShelfInfo["Color"], shelf_ind, ShelfInfo["Rotation"], ShelfInfo["Slope"], "N", ShelfInfo["FStyle"], ShelfInfo["FSize"], ShelfInfo["FBold"], p_enlargeNo, p_pog_index, g_pogcr_enhance_textbox_fontsize, ShelfInfo["TextDirection"]);
                            }
                            //End ASA-1371_26842
                        } else if (ShelfInfo["ObjType"] == "ROD") {
                            var colorValue = parseInt(ShelfInfo["Color"].replace("#", "0x"), 16);
                            var hex_decimal = new THREE.Color(colorValue);
                            var return_val = add_rod(ShelfInfo["Shelf"], "SHELF", ShelfInfo["W"], ShelfInfo["H"], ShelfInfo["D"], hex_decimal, ShelfInfo["X"], ShelfInfo["Y"], 0.004, "N", p_mod_index, shelf_ind, p_pog_index);
                        } else if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && (typeof g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ParentModule == "undefined" || g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ParentModule == null)) {
                            if (ShelfInfo["ObjType"] == "BASKET" || ShelfInfo["ObjType"] == "CHEST") {
                                if (g_chest_as_pegboard == "Y" && ShelfInfo["ObjType"] == "CHEST") {
                                    final_height = wpdSetFixed(ShelfInfo["D"]);
                                    ShelfInfo["H"] = wpdSetFixed(ShelfInfo["D"]);
                                } else {
                                    final_height = wpdSetFixed(ShelfInfo["BsktBaseH"]);
                                    ShelfInfo["H"] = wpdSetFixed(ShelfInfo["BsktBaseH"]);
                                }
                            } else {
                                final_height = wpdSetFixed(ShelfInfo["H"]);
                            }
                            var [return_val, shelf_cnt] = await add_shelf(ShelfInfo["Shelf"], "SHELF", ShelfInfo["W"], final_height, ShelfInfo["D"], hex_decimal, ShelfInfo["X"], ShelfInfo["Y"], 0.005, "N", p_mod_index, ShelfInfo["Rotation"], ShelfInfo["Slope"], shelf_ind, "N", "N", "Y", -1, p_pogCarparkShelfDftColor, p_notchHead, p_pogcrDelistItemDftColor, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_pog_index, p_json_array /*20241223 Reg 2*/); //ASA-1350 issue 6 added parameters
                            //this function will only be called from page 25. this will update the undo redo array
                            if (p_updateObjInd == "Y") {
                                var res = updateObjID(ShelfInfo["OldObjID"], return_val, "S");
                            }
                        }
                    }

                    if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX" && (typeof g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ParentModule == "undefined" || g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ParentModule == null)) {
                        /* //ASA-1418 Task 2
                        if (typeof p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo !== "undefined" && p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo !== null) {
                            if (p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo.length > 0) {
                                item_Details = p_json_array[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo;*/
                        if (typeof shelfs.ItemInfo !== "undefined" && shelfs.ItemInfo !== null) {
                            if (shelfs.ItemInfo.length > 0) {
                                item_Details = shelfs.ItemInfo;
                                var sorto = {
                                    X: "asc",
                                    Y: "asc",
                                };
                                item_Details.keySort(sorto);
                                if (p_CopyJsonInd == "Y") {
                                    copy_items = p_copyJson[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[copy_index].ItemInfo;
                                    copy_items.keySort(sorto);
                                }
                                if (g_json.length > 0) {
                                    //ASA-1418
                                    g_json_shelf = g_json[0].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo;
                                    g_json_shelf.keySort(sorto);
                                }

                                var shelf_start = ShelfInfo["X"] - ShelfInfo["W"] / 2;
                                var j = 0;
                                var l_item_crush = "N"; //ASA-1349 issue 2-3
                                for (const items of item_Details) {
                                    if (p_draft_ind == "N") {
                                        var selectedObject = g_world.getObjectById(items.ObjID);
                                        g_world.remove(selectedObject);
                                    }

                                    var ItemInfo = {};
                                    var item_ind = -1;
                                    var items_cnt = 0; // ASA-1273-3

                                    if (p_create_json == "Y") { 
                                        //this below if is true when json is created from tables or from mass update.
                                        if (p_new_pog_ind == "N" && p_pog_type == "F") {
                                            ItemInfo["DimT"] = items.MerchStyle;
                                            ItemInfo["PegID"] = "";
                                            ItemInfo["PegSpread"] = "";
                                            ItemInfo["PegPerFacing"] = "";
                                            ItemInfo["Fixed"] = "N";
                                            ItemInfo["CapStyle"] = items.CapStyle !== null && items.CapStyle !== "" && typeof items.CapStyle !== "undefined" ? items.CapStyle : "0"; //ASA-1310;"0";
                                            /*ASA-1170, Start*/
                                            ItemInfo["CapFacing"] = items.CapFacing !== null && items.CapFacing !== "" && typeof items.CapFacing !== "undefined" ? items.CapFacing : ""; //ASA-1310;
                                            ItemInfo["CapMerch"] = items.CapMerch !== null && items.CapMerch !== "" && typeof items.CapMerch !== "undefined" ? items.CapMerch : ""; //ASA-1310;
                                            ItemInfo["CapOrientaion"] = items.CapOrientaion !== null && items.CapOrientaion !== "" && typeof items.CapOrientaion !== "undefined" ? items.CapOrientaion : ""; //ASA-1310
                                            /*ASA-1170, End*/
                                            /*Start ASA-1310 prasanna ASA-1310_25890*/
                                            ItemInfo["CapHeight"] = items.CapHeight !== null && items.CapHeight !== "" && typeof items.CapHeight !== "undefined" ? items.CapHeight : "";
                                            ItemInfo["CapHorz"] = items.CapHorz !== null && items.CapHorz !== "" && typeof items.CapHorz !== "undefined" ? items.CapHorz : "";
                                            ItemInfo["CapDepth"] = items.CapDepth !== null && items.CapDepth !== "" && typeof items.CapDepth !== "undefined" ? items.CapDepth : "";
                                            ItemInfo["CapTotalCount"] = items.CapTotalCount !== null && items.CapTotalCount !== "" && typeof items.CapTotalCount !== "undefined" ? items.CapTotalCount : "";
                                            ItemInfo["CapMaxH"] = items.CapMaxH !== null && items.CapMaxH !== "" && typeof items.CapMaxH !== "undefined" ? items.CapMaxH : "";
                                            ItemInfo["CapCount"] = items.CapCount !== null && items.CapCount !== "" && typeof items.CapCount !== "undefined" ? items.CapCount : "";
                                            ItemInfo["CapDepthChanged"] = items.CapDepthChanged !== null && items.CapDepthChanged !== "" && typeof items.CapDepthChanged !== "undefined" ? items.CapDepthChanged : "N";
                                            /*END ASA-1310 prasanna ASA-1310_25890*/
                                            ItemInfo["MaxHCapStyle"] = "3";
                                            ItemInfo["Rotation"] = 0;
                                            ItemInfo["CrushHoriz"] = items.CrushHoriz !== null && items.CrushHoriz !== "" && typeof items.CrushHoriz !== "undefined" ? items.CrushHoriz : 0; //ASA-1310;;
                                            ItemInfo["CrushVert"] = items.CrushVert !== null && items.CrushVert !== "" && typeof items.CrushVert !== "undefined" ? items.CrushVert : 0; //ASA-1310;
                                            ItemInfo["CrushD"] = items.CrushD !== null && items.CrushD !== "" && typeof items.CrushD !== "undefined" ? items.CrushD : 0; //ASA-1310;
                                            ItemInfo["Price"] = "";
                                            ItemInfo["Cost"] = "";
                                            ItemInfo["RegMovement"] = "";
                                            ItemInfo["RegMovementInd"] = "";
                                            ItemInfo["DaysOfSupplyInd"] = "";
                                            ItemInfo["AvgSales"] = "";
                                            ItemInfo["ItemStatus"] = "";
                                            ItemInfo["CDTLvl1"] = ""; //ASA-1130
                                            ItemInfo["CDTLvl2"] = ""; //ASA-1130
                                            ItemInfo["CDTLvl3"] = ""; //ASA-1130
                                            ItemInfo["ActualDPP"] = ""; //ASA-1277-(3)
                                            ItemInfo["StoreSOH"] = ""; //ASA-1277-(3)
                                            ItemInfo["StoreNo"] = ""; //ASA-1277-(3)
                                            ItemInfo["WeeksOfInventory"] = ""; //ASA-1277-(3)
                                            //ASA-2013 Start
                                            ItemInfo["ShelfPrice"] = "";
                                            ItemInfo["PromoPrice"] = "";
                                            ItemInfo["DiscountRate"] = "";
                                            ItemInfo["PriceChangeDate"] = "";
                                            ItemInfo["WeeksOfInventory"] = "";
                                            ItemInfo["Qty"] = "";
                                            ItemInfo["WhStock"] = "";
                                            ItemInfo["StoreStock"] = "";
                                            ItemInfo["StockIntransit"] = "";
                                            //ASA-2013 End
                                            ItemInfo["DPPLoc"] = ""; //ASA-1308 Task-3
                                            ItemInfo["MoveBasis"] = "";
                                            ItemInfo["IsContainer"] = "N";
                                            ItemInfo["BsktFactor"] = 0;
                                            ItemInfo["OverHang"] = 0;
                                            ItemInfo["VertGap"] = 0;
                                            ItemInfo["BHoriz"] = items.BHoriz == null ? 1 : items.BHoriz;
                                            ItemInfo["BVert"] = items.BVert == null ? 1 : items.BVert;
                                            ItemInfo["BaseD"] = items.BaseD == null || items.BaseD == 0 ? 1 : items.BaseD; //ASA-1349 issue 6
                                            //getting dimension according to orientation.
                                            if (((g_json.length > 0 || typeof g_json[0] !== 'undefined') && g_json[0].DesignType == "D") && g_pog_json[p_pog_index].DesignType == "D" && g_pog_json[p_pog_index].MassUpdate == "Y") {
                                                var [item_width, item_height, item_depth, actualHeight, actualWidth, actualDepth] = get_new_orientation_dim("0", items.W, items.H, items.D);
                                            } else {
                                                var [item_width, item_height, item_depth, actualHeight, actualWidth, actualDepth] = get_new_orientation_dim(items.Orientation, items.W, items.H, items.D);
                                            }
                                            ItemInfo["W"] = item_width;
                                            if (items.CapCount !== null && items.CapCount !== "" && typeof items.CapCount !== "undefined" && items.CapStyle !== "0" && typeof items.CapStyle !== "undefined" && items.CapStyle !== null) {
                                                //TASK-25959 Kush added DUE TO AFTER MASS UPDATE WE NEED CAPHEIGHT TO BE ADDED
                                                ItemInfo["H"] = wpdSetFixed(item_height * items.BVert + items.CapHeight * items.CapCount);
                                            } else {
                                                ItemInfo["H"] = wpdSetFixed(item_height * items.BVert);
                                            }
                                            ItemInfo["D"] = item_depth;
                                            if (ShelfInfo["ObjType"] == "BASKET" && items.Item !== "DIVIDER") {
                                                ItemInfo["W"] = wpdSetFixed(ShelfInfo["W"]);
                                                ItemInfo["H"] = wpdSetFixed(items.D * items.Quantity);
                                                ItemInfo["D"] = wpdSetFixed(items.D * ItemInfo["BaseD"]);
                                                ItemInfo["RW"] = wpdSetFixed(items.W);
                                                ItemInfo["RH"] = wpdSetFixed(items.H);
                                                ItemInfo["RD"] = wpdSetFixed(items.D);
                                            } else {
                                                ItemInfo["W"] = ItemInfo["W"] * ItemInfo["BHoriz"];
                                                if (items.CapCount !== null && items.CapCount !== "" && typeof items.CapCount !== "undefined" && items.CapStyle !== "0" && typeof items.CapStyle !== "undefined" && items.CapStyle !== null) {
                                                    //TASK-25959 Kush added DUE TO AFTER MASS UPDATE WE NEED CAPHEIGHT TO BE ADDED
                                                    ItemInfo["H"] = wpdSetFixed(item_height * items.BVert + items.CapHeight * items.CapCount);
                                                } else {
                                                    ItemInfo["H"] = wpdSetFixed(item_height * items.BVert);
                                                } //END //TASK-25959
                                                ItemInfo["D"] = wpdSetFixed(ItemInfo["D"] * ItemInfo["BaseD"]);
                                                ItemInfo["RW"] = wpdSetFixed(ItemInfo["W"]);
                                                ItemInfo["RH"] = wpdSetFixed(item_height * items.BVert); //TASK-25959 kush FOR CAPPING
                                                ItemInfo["RD"] = wpdSetFixed(ItemInfo["D"]);
                                            }

                                            ItemInfo["OW"] = wpdSetFixed(items.W);
                                            ItemInfo["OH"] = wpdSetFixed(items.H);
                                            ItemInfo["OD"] = wpdSetFixed(items.D);
                                            ItemInfo["LObjID"] = items.LObjID;
                                            ItemInfo["SubLblObjID"] = items.SubLblObjID; //ASA-1182
                                            ItemInfo["Dragged"] = "N";
                                            ItemInfo["SpreadItem"] = typeof items.SpreadItem !== "undefined" && items.SpreadItem !== null && items.SpreadItem !== "" ? items.SpreadItem : 0; //--20240415 Rregression issue 12
                                            ItemInfo["MHorizCrushed"] = items.MHorizCrushed !== null && items.MHorizCrushed !== "" && typeof items.MHorizCrushed !== "undefined" ? items.MHorizCrushed : "N"; //ASA-1310 prasanna ASA-1310_25890
                                            ItemInfo["MVertCrushed"] = items.MVertCrushed !== null && items.MVertCrushed !== "" && typeof items.MVertCrushed !== "undefined" ? items.MVertCrushed : "N"; //ASA-1310 prasanna ASA-1310_25890
                                            ItemInfo["MDepthCrushed"] = items.MDepthCrushed !== null && items.MDepthCrushed !== "" && typeof items.MDepthCrushed !== "undefined" ? items.MDepthCrushed : "N"; //ASA-1310 prasanna ASA-1310_25890
                                            ItemInfo["MCapTopFacing"] = "N"; //ASA-1170
                                            /*if (items.Item == "DIVIDER") {Task-02_25977 prasanna 20240215 divider iteminfo is now set with start point from shelf start.
                                            ItemInfo["X"] = items.X + items.W / 2;
                                            } else {*/
                                            ItemInfo["X"] = ShelfInfo["X"] - ShelfInfo["W"] / 2 + items.X + ItemInfo["W"] / 2;
                                            //}
                                            if (ShelfInfo["ObjType"] == "PEGBOARD") {
                                                if (p_json_array[p_pog_index].MassUpdate == "Y") {
                                                    //ASA-25959 didnot minus the base height after mass update
                                                    ItemInfo["Y"] = wpdSetFixed(items.Y - ItemInfo["H"] / 2);
                                                } else {
                                                    ItemInfo["Y"] = wpdSetFixed(items.Y - ItemInfo["H"] / 2 - g_pog_json[p_pog_index].BaseH);
                                                }
                                            } else if (ShelfInfo["ObjType"] == "HANGINGBAR") {
                                                ItemInfo["Y"] = wpdSetFixed(ShelfInfo["Y"] - ItemInfo["H"] / 2);
                                            } else {
                                                if (g_pog_json[p_pog_index].DesignType == "D" && g_pog_json[p_pog_index].MassUpdate == "Y" && ShelfInfo["ObjType"] == "SHELF") {
                                                    ItemInfo["Y"] = wpdSetFixed(ShelfInfo["Y"] + ShelfInfo["H"] / 2 + ItemInfo["H"] / 2);
                                                } else {
                                                    ItemInfo["Y"] = wpdSetFixed(items.Y + ItemInfo["H"] / 2);
                                                }
                                            }
                                            ItemInfo["SlotDivider"] = "N";
                                            // ItemInfo["CapCount"] = 0; Task 25959 kush
                                            ItemInfo["Distance"] = wpdSetFixed(ItemInfo["X"] - ItemInfo["W"] / 2 - shelf_start);
                                            ItemInfo["YDistance"] = wpdSetFixed(ItemInfo["Y"] - ShelfInfo["Y"] + ShelfInfo["H"] / 2);
                                            if (ShelfInfo["ObjType"] == "PEGBOARD") {
                                                ItemInfo["PegBoardX"] = wpdSetFixed(ItemInfo["X"] - ItemInfo["W"] / 2 - shelf_start);
                                                ItemInfo["PegBoardY"] = wpdSetFixed(ItemInfo["Y"] - ItemInfo["H"] / 2 - (ShelfInfo["Y"] - ShelfInfo["H"] / 2));
                                            }
                                            ItemInfo["NewPegId"] = "";
                                            ItemInfo["AutoDiv"] = "N"; //ASA-1406
                                            ItemInfo["MassCrushH"] = typeof items.MassCrushH !== "undefined" && items.MassCrushH !== null ? items.MassCrushH : ""; //Task-02_25977 KUSH FOR MASS UPDATE FOR AUTO CRUSH IN CHEST--20240415 Rregression issue 12
                                            ItemInfo["MassCrushV"] = typeof items.MassCrushV !== "undefined" && items.MassCrushV !== null ? items.MassCrushV : ""; //Task-02_25977 KUSH FOR MASS UPDATE FOR AUTO CRUSH IN CHEST--20240415 Rregression issue 12
                                            ItemInfo["MassCrushD"] = typeof items.MassCrushD !== "undefined" && items.MassCrushD !== null ? items.MassCrushD : ""; //Task-02_25977 KUSH FOR MASS UPDATE FOR AUTO CRUSH IN CHEST--20240415 Rregression issue 12
                                            // ASA-2010.2                                        
                                            if (ShelfInfo["ObjType"] == "PALLET") {
                                                ItemInfo["Z"] = wpdSetFixed(items.Z + ItemInfo["D"] / 2);
                                            } else {
                                                ItemInfo["Z"] = items.Z == 0 ? wpdSetFixed(items.Z + items.D / 2) : wpdSetFixed(items.Z);     
                                            } 
                                        } else {
                                            ItemInfo["DimT"] = items.DimT;
                                            ItemInfo["PegID"] = items.PegID;
                                            ItemInfo["PegSpread"] = items.PegSpread;
                                            ItemInfo["PegPerFacing"] = items.PegPerFacing;
                                            ItemInfo["Fixed"] = items.Fixed;
                                            ItemInfo["CapStyle"] = items.CapStyle;
                                            /*ASA-1170, Start*/
                                            ItemInfo["CapFacing"] = items.CapFacing !== null && items.CapFacing !== "" && typeof items.CapFacing !== "undefined" ? items.CapFacing : 0;
                                            ItemInfo["CapMerch"] = items.CapMerch;
                                            ItemInfo["CapOrientaion"] = items.CapOrientaion;
                                            ItemInfo["CapHeight"] = items.CapHeight;
                                            /*ASA-1170, End*/
                                            ItemInfo["CapHorz"] = items.CapHorz !== null && items.CapHorz !== "" && typeof items.CapHorz !== "undefined" ? items.CapHorz : 0; //asa-1341
                                            ItemInfo["CapDepth"] = items.CapDepth !== null && items.CapDepth !== "" && typeof items.CapDepth !== "undefined" ? items.CapDepth : 0; //asa-1341
                                            ItemInfo["CapTotalCount"] = items.CapTotalCount; //ASA-1179
                                            ItemInfo["CapMaxH"] = typeof items.CapMaxH !== "undefined" && items.CapMaxH !== null ? items.CapMaxH : 0;
                                            ItemInfo["MaxHCapStyle"] = typeof items.MaxHCapStyle !== "undefined" && items.MaxHCapStyle !== null ? items.MaxHCapStyle : "3";
                                            ItemInfo["Rotation"] = items.Rotation;
                                            ItemInfo["CrushHoriz"] = items.CrushHoriz;
                                            ItemInfo["CrushVert"] = items.CrushVert;
                                            ItemInfo["CrushD"] = items.CrushD;
                                            ItemInfo["Price"] = items.Price;
                                            ItemInfo["Cost"] = items.Cost;
                                            ItemInfo["RegMovement"] = items.RegMovement;
                                            ItemInfo["RegMovementInd"] = typeof items.RegMovementInd !== "undefined" ? items.RegMovementInd : "";
                                            ItemInfo["DaysOfSupplyInd"] = typeof items.DaysOfSupplyInd !== "undefined" ? items.DaysOfSupplyInd : "";
                                            ItemInfo["AvgSales"] = typeof items.AvgSales !== "undefined" && items.AvgSales != null && items.AvgSales != "" ? Math.floor(items.AvgSales * 100) / 100 : ""; //ASA-1243
                                            ItemInfo["ItemStatus"] = typeof items.ItemStatus !== "undefined" ? items.ItemStatus : "";
                                            ItemInfo["CDTLvl1"] = typeof items.CDTLvl1 !== "undefined" ? items.CDTLvl1 : ""; //ASA-1130
                                            ItemInfo["CDTLvl2"] = typeof items.CDTLvl2 !== "undefined" ? items.CDTLvl2 : ""; //ASA-1130
                                            ItemInfo["CDTLvl3"] = typeof items.CDTLvl3 !== "undefined" ? items.CDTLvl3 : ""; //ASA-1130
                                            ItemInfo["ActualDPP"] = typeof items.ActualDPP !== "undefined" ? items.ActualDPP : ""; //ASA-1277-(3)
                                            ItemInfo["StoreSOH"] = typeof items.StoreSOH !== "undefined" ? items.StoreSOH : ""; //ASA-1277-(3)
                                            ItemInfo["StoreNo"] = typeof items.StoreNo !== "undefined" ? items.StoreNo : ""; //ASA-1277-(3)
                                            ItemInfo["DPPLoc"] = items.DPPLoc; //ASA-1308 Task-3
                                            ItemInfo["WeeksOfInventory"] = typeof items.WeeksOfInventory !== "undefined" ? items.WeeksOfInventory : ""; //ASA-1277-(3)
                                            //ASA-2013 Start
                                            ItemInfo["ShelfPrice"] = typeof items.ShelfPrice !== "undefined" ? items.ShelfPrice : "";
                                            ItemInfo["PromoPrice"] = typeof items.PromoPrice !== "undefined" ? items.PromoPrice : "";
                                            ItemInfo["DiscountRate"] = typeof items.DiscountRate !== "undefined" ? items.DiscountRate : "";
                                            ItemInfo["PriceChangeDate"] = typeof items.PriceChangeDate !== "undefined" ? items.PriceChangeDate : "";
                                            ItemInfo["WeeksOfInventory"] = typeof items.WeeksOfInventory !== "undefined" ? items.WeeksOfInventory : "";
                                            ItemInfo["Qty"] = typeof items.Qty !== "undefined" ? items.Qty : "";
                                            ItemInfo["WhStock"] = typeof items.WhStock !== "undefined" ? items.WhStock : "";
                                            ItemInfo["StoreStock"] = typeof items.StoreStock !== "undefined" ? items.StoreStock : "";
                                            ItemInfo["StockIntransit"] = typeof items.StockIntransit !== "undefined" ? items.StockIntransit : "";
                                            //ASA-2013 End
                                            ItemInfo["MoveBasis"] = items.MoveBasis;
                                            ItemInfo["IsContainer"] = items.IsContainer;
                                            ItemInfo["BsktFactor"] = items.BsktFactor;
                                            ItemInfo["OverHang"] = items.OverHang;
                                            ItemInfo["VertGap"] = items.VertGap;
                                            ItemInfo["OW"] = wpdSetFixed(items.OW);
                                            ItemInfo["OH"] = wpdSetFixed(items.OH);
                                            ItemInfo["OD"] = wpdSetFixed(items.OD);
                                            ItemInfo["Dragged"] = items.Dragged;
                                            ItemInfo["SpreadItem"] = items.SpreadItem;
                                            ItemInfo["MHorizCrushed"] = items.MHorizCrushed;
                                            ItemInfo["MVertCrushed"] = items.MVertCrushed;
                                            ItemInfo["MDepthCrushed"] = items.MDepthCrushed;
                                            ItemInfo["MCapTopFacing"] = items.MCapTopFacing; //ASA-1170
                                            //Start ASA-1369
                                            // ItemInfo["RW"] = items.RW;
                                            // ItemInfo["RH"] = items.RH;
                                            //Start Task_26826
                                            var [item_width, item_height, item_depth, actualHeight, actualWidth, actualDepth] = get_new_orientation_dim(items.Orientation, items.OW, items.OH, items.OD);
                                            ItemInfo["RW"] = wpdSetFixed(item_width * items.BHoriz);
                                            ItemInfo["RH"] = wpdSetFixed(item_height * items.BVert);
                                            ItemInfo["RD"] = wpdSetFixed(item_depth * items.BaseD);
                                            //End Task_26826
                                            //ItemInfo["RD"] = items.RD;
                                            //End ASA-1369
                                            ItemInfo["LObjID"] = items.LObjID;
                                            ItemInfo["SubLblObjID"] = items.SubLblObjID; //ASA-1182
                                            ItemInfo["SlotDivider"] = items.SlotDivider;
                                            ItemInfo["CapCount"] = items.CapCount;
                                            if (p_showSingleModule == "Y") {
                                                ItemInfo["X"] = wpdSetFixed(items.X - total_mod_width);
                                            } else {
                                                ItemInfo["X"] = wpdSetFixed(items.X);
                                            }
                                            ItemInfo["Y"] = wpdSetFixed(items.Y);
                                            if (ShelfInfo["ObjType"] == "HANGINGBAR") {
                                                ItemInfo["Y"] = wpdSetFixed(ShelfInfo["Y"] - items.H / 2);
                                            } else {
                                                ItemInfo["Y"] = wpdSetFixed(items.Y);
                                            }
                                            ItemInfo["BHoriz"] = items.BHoriz;
                                            ItemInfo["BVert"] = items.BVert;
                                            ItemInfo["BaseD"] = items.BaseD;
                                            ItemInfo["W"] = wpdSetFixed(items.W);
                                            ItemInfo["H"] = wpdSetFixed(items.H);
                                            ItemInfo["D"] = wpdSetFixed(items.D);
                                            ItemInfo["Distance"] = items.Distance;
                                            ItemInfo["PegBoardX"] = items.PegBoardX;
                                            ItemInfo["PegBoardY"] = items.PegBoardY;
                                            ItemInfo["NewPegId"] = "";
                                            ItemInfo["YDistance"] = typeof items.YDistance !== "undefined" ? items.YDistance : ItemInfo["Y"] - ShelfInfo["Y"] + ShelfInfo["H"] / 2;
                                            ItemInfo["MassCrushH"] = "N"; //20240415 Rregression issue 12
                                            ItemInfo["MassCrushV"] = "N"; //20240415 Rregression issue 12
                                            ItemInfo["MassCrushD"] = "N"; //20240415 Rregression issue 12
                                            ItemInfo["AutoDiv"] = typeof items.AutoDiv !== "undefined" ? items.AutoDiv : "N"; //ASA-1406
                                            // ASA-2010.2     

                                            if (ShelfInfo["ObjType"] == "PALLET") {
                                                ItemInfo["Z"] = wpdSetFixed(items.Z); 
                                            } else {
                                                ItemInfo["Z"] = items.Z == 0 ? wpdSetFixed(items.Z + items.D / 2) : wpdSetFixed(items.Z);     
                                            } 
                                        }
                                       // ASA-2010.2                                        
                                        // if (ShelfInfo["ObjType"] == "PALLET") {
                                        //     ItemInfo["Z"] = wpdSetFixed(items.Z + ItemInfo["D"] / 2);
                                        // } else {
                                        //     ItemInfo["Z"] = items.Z == 0 ? wpdSetFixed(items.Z + items.D / 2) : wpdSetFixed(items.Z);     
                                        // }   
                                                                          
                                        ItemInfo["Quantity"] = Math.round(items.Quantity * 100) / 100; //items.Quantity; ASA-1243
                                        ItemInfo["ItemID"] = items.ItemID;
                                        ItemInfo["Item"] = items.Item;
                                        if (typeof items.Color == "undefined" || items.Color == null) {
                                            //ASA-1310 prasanna ASA-1310_25890
                                            ItemInfo["Color"] = p_ItemColor;
                                        } else {
                                            ItemInfo["Color"] = items.Color;
                                        }
                                        ItemInfo["Desc"] = items.Desc;
                                        ItemInfo["Barcode"] = items.Barcode;
                                        ItemInfo["LocID"] = items.LocID;
                                        ItemInfo["Orientation"] = items.Orientation;
                                        ItemInfo["MerchStyle"] = items.MerchStyle == null || typeof items.MerchStyle == "undefined" || items.MerchStyle == "" ? "0" : items.MerchStyle;
                                        ItemInfo["Supplier"] = items.Supplier;
                                        if (typeof items.Supplier !== "undefined" && items.Supplier !== "" && items.Supplier !== null) {
                                            //ASA-1222-S //ASA-1350 issue 6 case 2 found a bug as its coming as null
                                            ItemInfo["SupplierName"] = items.Supplier.split("-")[1];
                                        } else {
                                            ItemInfo["SupplierName"] = "";
                                        } //ASA-1222-E
                                        ItemInfo["Brand"] = items.Brand;
                                        ItemInfo["BrandType"] = items.BrandType;
                                        ItemInfo["Group"] = items.Group;
                                        ItemInfo["Dept"] = items.Dept;
                                        ItemInfo["SubClass"] = items.SubClass;
                                        if (typeof items.Dept !== "undefined" && items.Dept !== "" && items.Dept !== null) {
                                            //Task_267933 QA error
                                            var itemdept = items.Dept.split("-"); //ASA-1222-S
                                        } else {
                                            var itemdept = "";
                                        }
                                        if (typeof items.Class !== "undefined" && items.Class !== "" && items.Class !== null) {
                                            //Task_267933 QA error
                                            var itemclass = items.Class.split("-");
                                        } else {
                                            var itemclass = "";
                                        }
                                        if (typeof items.SubClass !== "undefined" && items.SubClass !== "" && items.SubClass !== null) {
                                            //Task_26793 QA error
                                            var itemsubclass = items.SubClass.split("-");
                                        } else {
                                            var itemsubclass = "";
                                        } //ASA-1171 BS
                                        ItemInfo["Class"] = items.Class;
                                        ItemInfo["ClassName"] = itemdept[0] + "/" + itemclass[0] + "/" + itemsubclass[0]; //ASA-1222-E
                                        ItemInfo["StdUOM"] = items.StdUOM;
                                        ItemInfo["SizeDesc"] = typeof items.SizeDesc == "undefined" || items.SizeDesc == null ? "" : items.SizeDesc; //Task_26793 QA error //ASA-1327 noticed error as for some item it is null so from db tag not done.
                                        ItemInfo["HorizGap"] = items.HorizGap;
                                        ItemInfo["UW"] = wpdSetFixed(items.UW);
                                        ItemInfo["UH"] = wpdSetFixed(items.UH);
                                        ItemInfo["UD"] = wpdSetFixed(items.UD);
                                        ItemInfo["CW"] = wpdSetFixed(items.CW);
                                        ItemInfo["CH"] = wpdSetFixed(items.CH);
                                        ItemInfo["CD"] = wpdSetFixed(items.CD);
                                        ItemInfo["TW"] = wpdSetFixed(items.TW);
                                        ItemInfo["TH"] = wpdSetFixed(items.TH);
                                        ItemInfo["TD"] = wpdSetFixed(items.TD);
                                        ItemInfo["DW"] = wpdSetFixed(items.DW);
                                        ItemInfo["DH"] = wpdSetFixed(items.DH);
                                        ItemInfo["DD"] = wpdSetFixed(items.DD);
                                        ItemInfo["CWPerc"] = items.CWPerc;
                                        ItemInfo["CHPerc"] = items.CHPerc;
                                        ItemInfo["CDPerc"] = items.CDPerc;
                                        ItemInfo["TopObjID"] = items.TopObjID;
                                        ItemInfo["BottomObjID"] = items.BottomObjID;
                                        ItemInfo["SecondTier"] = items.SecondTier;
                                        ItemInfo["CompItemObjID"] = items.CompItemObjID;
                                        ItemInfo["SellingPrice"] = Math.round(items.SellingPrice * 100) / 100;
                                        // var salesunit = items.SalesUnit;
                                        // ItemInfo["SalesUnit"] = salesunit.toFixed(2);
                                        ItemInfo["NetSales"] = typeof items.NetSales !== "undefined" && items.NetSales !== "" ? Math.round(items.NetSales * 100) / 100 : 0; //Regression 1 task_26974// //--20240415 Regression Issue 1  WTCHK 20240428 giving erro in get_sales_info when it is "" and doing tofixed.
                                        ItemInfo["CogsAdj"] = items.CogsAdj;
                                        ItemInfo["CogsAdjInd"] = typeof items.CogsAdjInd !== "undefined" ? items.CogsAdjInd : "";
                                        ItemInfo["RegMovement"] = items.RegMovement;
                                        ItemInfo["RegMovementInd"] = typeof items.RegMovementInd !== "undefined" ? items.RegMovementInd : "";
                                        ItemInfo["AvgSales"] = typeof items.AvgSales !== "undefined" && items.AvgSales != null && items.AvgSales != "" ? Math.floor(items.AvgSales * 100) / 100 : ""; //ASA-1243
                                        ItemInfo["AvgSalesInd"] = typeof items.AvgSalesInd !== "undefined" ? items.AvgSalesInd : "";
                                        ItemInfo["ItemStatus"] = typeof items.ItemStatus !== "undefined" ? items.ItemStatus : "";
                                        ItemInfo["CDTLvl1"] = typeof items.CDTLvl1 !== "undefined" ? items.CDTLvl1 : ""; //ASA-1130
                                        ItemInfo["CDTLvl2"] = typeof items.CDTLvl2 !== "undefined" ? items.CDTLvl2 : ""; //ASA-1130
                                        ItemInfo["CDTLvl3"] = typeof items.CDTLvl3 !== "undefined" ? items.CDTLvl3 : ""; //ASA-1130
                                        ItemInfo["MPogVertFacings"] = typeof items.MPogVertFacings !== "undefined" ? items.MPogVertFacings : ""; //ASA-1408
                                        ItemInfo["MPogHorizFacings"] = typeof items.MPogHorizFacings !== "undefined" ? items.MPogHorizFacings : ""; //ASA-1408
                                        ItemInfo["MPogDepthFacings"] = typeof items.MPogDepthFacings !== "undefined" ? items.MPogDepthFacings : ""; //ASA-1408
                                        ItemInfo["ActualDPP"] = typeof items.ActualDPP !== "undefined" && items.ActualDPP != null && items.ActualDPP != "" ? parseFloat(items.ActualDPP).toFixed(2) : ""; //ASA-1243//ASA-1182  //ASA-1243 ASA-1277-(3)
                                        ItemInfo["DPPLoc"] = items.DPPLoc; //ASA-1308 Task-3
                                        ItemInfo["StoreSOH"] = typeof items.StoreSOH !== "undefined" ? items.StoreSOH : ""; //ASA-1277-(3)
                                        ItemInfo["StoreNo"] = typeof items.StoreNo !== "undefined" ? items.StoreNo : ""; //ASA-1277-(3)
                                        ItemInfo["WeeksOfInventory"] = typeof items.WeeksOfInventory !== "undefined" ? items.WeeksOfInventory : ""; //ASA-1277-(3)
                                        //ASA-2013 Start
                                        ItemInfo["ShelfPrice"] = typeof items.ShelfPrice !== "undefined" ? items.ShelfPrice : "";
                                        ItemInfo["PromoPrice"] = typeof items.PromoPrice !== "undefined" ? items.PromoPrice : "";
                                        ItemInfo["DiscountRate"] = typeof items.DiscountRate !== "undefined" ? items.DiscountRate : "";
                                        ItemInfo["PriceChangeDate"] = typeof items.PriceChangeDate !== "undefined" ? items.PriceChangeDate : "";
                                        ItemInfo["WeeksOfInventory"] = typeof items.WeeksOfInventory !== "undefined" ? items.WeeksOfInventory : "";
                                        ItemInfo["Qty"] = typeof items.Qty !== "undefined" ? items.Qty : "";
                                        ItemInfo["WhStock"] = typeof items.WhStock !== "undefined" ? items.WhStock : "";
                                        ItemInfo["StoreStock"] = typeof items.StoreStock !== "undefined" ? items.StoreStock : "";
                                        ItemInfo["StockIntransit"] = typeof items.StockIntransit !== "undefined" ? items.StockIntransit : "";
                                        //ASA-2013 End
                                        ItemInfo["GrossProfit"] = typeof items.GrossProfit !== "undefined" ? items.GrossProfit : 0; //Regression 1 task_26974
                                        ItemInfo["GrossProfitInd"] = typeof items.GrossProfitInd !== "undefined" ? items.GrossProfitInd : "";
                                        ItemInfo["WeeksCount"] = items.WeeksCount;
                                        ItemInfo["WeeksCountInd"] = typeof items.WeeksCountInd !== "undefined" ? items.WeeksCountInd : "";
                                        ItemInfo["MovingItem"] = items.MovingItem;
                                        ItemInfo["Profit"] = Math.round(items.Profit * 100) / 100;
                                        ItemInfo["TotalMargin"] = items.TotalMargin;
                                        ItemInfo["Price"] = items.Price;
                                        ItemInfo["Cost"] = items.Cost;
                                        ItemInfo["MHorizFacings"] = typeof items.MHorizFacings == "undefined" ? -1 : items.MHorizFacings == null ? -1 : parseInt(items.MHorizFacings);
                                        ItemInfo["MVertFacings"] = typeof items.MVertFacings == "undefined" ? -1 : items.MVertFacings == null ? -1 : parseInt(items.MVertFacings);
                                        ItemInfo["MDepthFacings"] = typeof items.MDepthFacings == "undefined" ? -1 : items.MDepthFacings == null ? -1 : parseInt(items.MDepthFacings);
                                        ItemInfo["Status"] = items.Status;
                                        ItemInfo["DaysOfSupply"] = items.DaysOfSupply;
                                        ItemInfo["DaysOfSupplyInd"] = typeof items.DaysOfSupplyInd !== "undefined" ? items.DaysOfSupplyInd : "";
                                        ItemInfo["ShowColorBackup"] = items.ShowColorBackup;
                                        ItemInfo["OrientationDesc"] = items.OrientationDesc;
                                        ItemInfo["StoreCnt"] = items.StoreCnt;
                                        ItemInfo["NewYN"] = "";
                                        ItemInfo["DescSecond"] = items.DescSecond;
                                        ItemInfo["Delist"] = typeof items.Delist == "undefined" ? "N" : items.Delist;
                                        ItemInfo["OverhungItem"] = typeof items.OverhungItem == "undefined" ? "N" : items.OverhungItem; //ASA-1138

                                        if (ItemInfo["Delist"] == "Y") {
                                            ItemInfo["Color"] = p_ItemDelistColor;
                                        }

                                        if (typeof items.CnW == "undefined") {
                                            ItemInfo["CnW"] = 0;
                                        } else {
                                            ItemInfo["CnW"] = items.CnW;
                                        }
                                        if (typeof items.CnH == "undefined") {
                                            ItemInfo["CnH"] = 0;
                                        } else {
                                            ItemInfo["CnH"] = items.CnH;
                                        }
                                        if (typeof items.CnD == "undefined") {
                                            ItemInfo["CnD"] = 0;
                                        } else {
                                            ItemInfo["CnD"] = items.CnD;
                                        }
                                        if (typeof items.NW == "undefined") {
                                            ItemInfo["NW"] = 0;
                                        } else {
                                            ItemInfo["NW"] = items.NW;
                                        }
                                        if (typeof items.NH == "undefined") {
                                            ItemInfo["NH"] = 0;
                                        } else {
                                            ItemInfo["NH"] = items.NH;
                                        }
                                        if (typeof items.ND == "undefined") {
                                            ItemInfo["ND"] = 0;
                                        } else {
                                            ItemInfo["ND"] = items.ND;
                                        }
                                        ItemInfo["ItemNesting"] = items.ItemNesting;
                                        ItemInfo["NVal"] = ItemInfo["ItemNesting"] == "H" ? items.NH : ItemInfo["ItemNesting"] == "W" ? items.NW : ItemInfo["ItemNesting"] == "D" ? items.ND : 0;

                                        ItemInfo["ItemContain"] = items.ItemContain;
                                        ItemInfo["CnVal"] = ItemInfo["ItemContain"] == "H" ? items.CnH : ItemInfo["ItemContain"] == "W" ? items.CnW : ItemInfo["ItemContain"] == "D" ? items.CnD : 0;

                                        ItemInfo["OldCnW"] = ItemInfo["CnW"];
                                        ItemInfo["OldCnH"] = ItemInfo["CnH"];
                                        ItemInfo["OldCnD"] = ItemInfo["CnD"];
                                        ItemInfo["OldNW"] = ItemInfo["NW"];
                                        ItemInfo["OldNH"] = ItemInfo["NH"];
                                        ItemInfo["OldND"] = ItemInfo["ND"];

                                        ItemInfo["OrgUW"] = wpdSetFixed(items.OrgUW);
                                        ItemInfo["OrgUH"] = wpdSetFixed(items.OrgUH);
                                        ItemInfo["OrgUD"] = wpdSetFixed(items.OrgUD);
                                        ItemInfo["OrgCW"] = wpdSetFixed(items.OrgCW);
                                        ItemInfo["OrgCH"] = wpdSetFixed(items.OrgCH);
                                        ItemInfo["OrgCD"] = wpdSetFixed(items.OrgCD);
                                        ItemInfo["OrgTW"] = wpdSetFixed(items.OrgTW);
                                        ItemInfo["OrgTH"] = wpdSetFixed(items.OrgTH);
                                        ItemInfo["OrgTD"] = wpdSetFixed(items.OrgTD);
                                        ItemInfo["OrgDW"] = wpdSetFixed(items.OrgDW);
                                        ItemInfo["OrgDH"] = wpdSetFixed(items.OrgDH);
                                        ItemInfo["OrgDD"] = wpdSetFixed(items.OrgDD);
                                        ItemInfo["OrgCWPerc"] = items.OrgCWPerc;
                                        ItemInfo["OrgCHPerc"] = items.OrgCHPerc;
                                        ItemInfo["OrgCDPerc"] = items.OrgCDPerc;
                                        ItemInfo["OrgCnW"] = items.OrgCnW;
                                        ItemInfo["OrgCnH"] = items.OrgCnH;
                                        ItemInfo["OrgCnD"] = items.OrgCnD;
                                        ItemInfo["OrgNW"] = items.OrgNW;
                                        ItemInfo["OrgNH"] = items.OrgNH;
                                        ItemInfo["OrgND"] = items.OrgND;
                                        if (typeof items.SizeDesc !== "undefined" && items.SizeDesc !== "") {
                                            var det_arr = items.SizeDesc !== null ? items.SizeDesc.split("*") : [];
                                        } else {
                                            var det_arr = [];
                                        } //ASA-1171 BS
                                        var cap_capacity = items.CapFacing * items.CapDepth * items.CapHorz; //ASA-1273 Prasanna
                                        ItemInfo["Cpct"] = items.BHoriz * items.BVert * items.BaseD + (!isNaN(cap_capacity) ? cap_capacity : 0);
                                        ItemInfo["ImgExists"] = items.ImgExists;
                                        ItemInfo["Exists"] = "E";
                                        ItemInfo["DimUpdate"] = "N";
                                        ItemInfo["ItemImage"] = items.ItemImage;
                                        ItemInfo["Edited"] = "Y";
                                        ItemInfo["OldObjID"] = items.ObjID;
                                        ItemInfo["NewPegId"] = "";
                                        ItemInfo["DFacing"] = items.BaseD;
                                        ItemInfo["UnitperCase"] = items.UnitperCase;
                                        ItemInfo["UnitperTray"] = items.UnitperTray;
                                        ItemInfo["DfacingUpd"] = "N";
                                        ItemInfo["TotalUnitsCalc"] = items.BHoriz * items.BVert * items.BaseD;

                                        //added for new PKsiz-ASA-1273-3
                                        // ItemInfo["PkSiz"] = parseInt(det_arr[0]) / parseInt(det_arr[1]); //ASA-1273 Prasanna
                                        ItemInfo["PkSiz"] = parseInt(det_arr[1]); //ASA-1341 added to print the first numeric value of EngDesc

                                        ItemInfo["ItmDescChi"] = items.ItmDescChi; //ASA-1407 Task 1,//ASA-1407 issue 5
                                        if (det_arr.length > 1) {
                                            //ASA-1273 Prasanna
                                            //ItemInfo["ItmDescEng"] = items.Brand + " " + items.Desc + " " + ItemInfo["PkSiz"] + '*' + det_arr[1] + '*' + det_arr[2];
                                            ItemInfo["ItmDescEng"] = items.Brand + " " + items.Desc + " " + parseInt(det_arr[0]) / parseInt(det_arr[1]) + "*" + det_arr[1] + "*" + det_arr[2]; //ASA-1341 added to print the existing PkSiz value in EngDesc
                                        } else {
                                            ItemInfo["ItmDescEng"] = items.Brand + " " + items.Desc;
                                        }

                                        ItemInfo["Brand_Category"] = typeof items.Brand_Category !== "undefined" ? items.Brand_Category : "";
                                        ItemInfo["Uda_item_status"] = typeof items.Uda_item_status !== "undefined" ? items.Uda_item_status : "";
                                        ItemInfo["Gobecobrand"] = typeof items.Gobecobrand !== "undefined" ? items.Gobecobrand : "";
                                        ItemInfo["Internet"] = typeof items.Internet !== "undefined" ? items.Internet : ""; //ASA-1158-E
                                        ItemInfo["LiveNewItem"] = typeof items.LiveNewItem !== "undefined" ? items.LiveNewItem : ""; //ASA-1250
                                        ItemInfo["CapDepthChanged"] = "N"; // ASA-1273
                                        ItemInfo["Categ"] = typeof items.Categ !== "undefined" ? items.Categ : "";
                                        ItemInfo["COO"] = typeof items.COO !== "undefined" ? items.COO : "";
                                        ItemInfo["ItemSize"] = typeof items.ItemSize !== "undefined" ? items.ItemSize : "";
                                        ItemInfo["SplrLbl"] = typeof items.SplrLbl !== "undefined" ? items.SplrLbl : "";
                                        ItemInfo["EDLP"] = typeof items.EDLP !== "undefined" ? items.EDLP : "";
                                        ItemInfo["GoGreen"] = typeof items.GoGreen !== "undefined" ? items.GoGreen : "";
                                        ItemInfo["LoGrp"] = typeof items.LoGrp !== "undefined" ? items.LoGrp : "";
                                        ItemInfo["SqzPer"] = (typeof items.CrushHoriz !== "undefined" ? items.CrushHoriz : 0) + ":" + (typeof items.CrushVert !== "undefined" ? items.CrushVert : 0) + ":" + (typeof items.CrushD !== "undefined" ? items.CrushD : 0);
                                        ItemInfo["InternationalRng"] = typeof items.InternationalRng !== "undefined" ? items.InternationalRng : "";
                                        ItemInfo["StoreCnt"] = typeof items.StoreCnt !== "undefined" ? items.StoreCnt : ""; //ASA-1182
                                        ItemInfo["NewItem"] = typeof items.NewItem !== "undefined" ? items.NewItem : ""; //ASA-1182
                                        if (typeof items.SalesUnit !== "undefined" && items.SalesUnit !== null) {
                                            var salesunit = items.SalesUnit;
                                            ItemInfo["SalesUnit"] = Math.floor(salesunit * 100) / 100;
                                        } else {
                                            ItemInfo["SalesUnit"] = "";
                                        }

                                        if (typeof items.Remarks !== undefined) {
                                            ItemInfo["Remarks"] = items.Remarks;
                                        } else {
                                            ItemInfo["Remarks"] = "";
                                        }
                                        ItemInfo["UDA751"] = typeof items.UDA751 !== "undefined" ? items.UDA751 : ""; //ASA-1407 Task 1 -S
                                        ItemInfo["UDA755"] = typeof items.UDA755 !== "undefined" ? items.UDA755 : ""; //ASA-1407 Task 1 -E

                                        //ASA-1640 Start
                                        ItemInfo["ItemCondition"] = nvl(items.ItemCondition) != 0 ? items.ItemCondition : "";
                                        ItemInfo["AUR"] = nvl(items.AUR) != 0 ? items.AUR : "";
                                        ItemInfo["ItemRanking"] = nvl(items.ItemRanking) != 0 ? items.ItemRanking : "";
                                        ItemInfo["WeeklySales"] = nvl(items.WeeklySales) != 0 ? items.WeeklySales : "";
                                        ItemInfo["WeeklyNetMargin"] = nvl(items.WeeklyNetMargin) != 0 ? items.WeeklyNetMargin : "";
                                        ItemInfo["WeeklyQty"] = nvl(items.WeeklyQty) != 0 ? items.WeeklyQty : "";
                                        ItemInfo["NetMarginPercent"] = typeof items.NetMarginPercent !== "undefined" ? items.NetMarginPercent : typeof items.NetMarginPerc !== "undefined" ? items.NetMarginPerc : ""; //ASA-1735  issue 4
                                        ItemInfo["CumulativeNM"] = nvl(items.CumulativeNM) != 0 ? items.CumulativeNM : "";
                                        ItemInfo["TOP80B2"] = nvl(items.TOP80B2) != 0 ? items.TOP80B2 : "";
                                        ItemInfo["ItemBrandC"] = nvl(items.ItemBrandC) != 0 ? items.ItemBrandC : "";
                                        ItemInfo["ItemPOGDept"] = nvl(items.ItemPOGDept) != 0 ? items.ItemPOGDept : "";
                                        ItemInfo["ItemRemark"] = nvl(items.ItemRemark) != 0 ? items.ItemRemark : "";
                                        ItemInfo["RTVStatus"] = nvl(items.RTVStatus) != 0 ? items.RTVStatus : "";
                                        ItemInfo["Pusher"] = nvl(items.Pusher) != 0 ? items.Pusher : "";
                                        ItemInfo["Divider"] = nvl(items.Divider) != 0 ? items.Divider : "";
                                        ItemInfo["BackSupport"] = nvl(items.BackSupport) != 0 ? items.BackSupport : "";
                                        //ASA-1640 End
                                        ItemInfo["OOSPerc"] = nvl(items.OOSPerc); //ASA-1750 Issue 2 //nvl(items.OOSPerc) != 0 ? items.OOSPerc : ""; //ASA-1688 Added for OOS%
                                        ItemInfo["InitialItemDesc"] = typeof items.InitialItemDesc !== "undefined" ? items.InitialItemDesc : ""; //ASA-1734 Issue 1
                                        ItemInfo["InitialBrand"] = typeof items.InitialBrand !== "undefined" ? items.InitialBrand : ""; //ASA-1787 Request #6
                                        ItemInfo["InitialBarcode"] = typeof items.InitialBarcode !== "undefined" ? items.InitialBarcode : ""; //ASA-1787 Request #6

                                        //below condition will be Y only from page 25, to calculate auto vertical facings. this can only happen in all the
                                        //shelf details exists to calculate available max merch.
                                        if (p_CopyJsonInd == "Y") {
                                            if ((g_auto_apply_v_facings == "Y" || g_auto_apply_d_facings == "Y") && (ShelfInfo["ObjType"] == "SHELF" || ShelfInfo["ObjType"] == "HANGINGBAR") && items.Item !== "DIVIDER") {
                                                p_copyJson[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[copy_index].ItemInfo[j].ItemX = wpdSetFixed(ItemInfo["ItemX"]);
                                                p_copyJson[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[copy_index].ItemInfo[j].ItemY = wpdSetFixed(ItemInfo["ItemY"]);
                                                var [h, Bvert, rh, y, d, baseD, rd] = calcMaxFacings(p_copyJson, p_mod_index, copy_index, p_copyJson[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[copy_index], ItemInfo, j);
                                                if (g_auto_apply_v_facings == "Y" && nvl(h) !== 0 && (ShelfInfo["ObjType"] == "SHELF" || (ShelfInfo["ObjType"] == "HANGINGBAR" && g_auto_hangbar_facings == "Y"))) {
                                                    ItemInfo["H"] = wpdSetFixed(h);
                                                    ItemInfo["RH"] = wpdSetFixed(rh);
                                                    ItemInfo["BVert"] = Bvert;
                                                    ItemInfo["Y"] = wpdSetFixed(y);
                                                }
                                                if (g_auto_apply_d_facings == "Y" && nvl(d) !== 0 && (ShelfInfo["ObjType"] == "SHELF" || (ShelfInfo["ObjType"] == "HANGINGBAR" && g_auto_hangbar_facings == "Y"))) {
                                                    ItemInfo["BaseD"] = wpdSetFixed(baseD);
                                                    ItemInfo["D"] = wpdSetFixed(d);
                                                    ItemInfo["RD"] = wpdSetFixed(rd);
                                                }
                                            }
                                        }

                                        g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo.push(ItemInfo);
                                        item_ind = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo.length - 1;
                                    } else {
                                        ItemInfo = items;
                                        item_ind = j;
                                    }
                                    //apply reset_top_bottom
                                    if (p_recreate == "Y") {
                                        // Start ASA-1350 issue 6 case 2 corrected from object to use json directly.
                                        var itemdtl = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo[item_ind];
                                        //Start Task_26899

                                        itemdtl.MIndex = p_mod_index;
                                        itemdtl.SIndex = i;
                                        itemdtl.IIndex = item_ind;
                                        /*add static 0 because the g_json get data according to pog wise not containe the all pog_json and add if condition due to bacth pdf g_json null ASA-1374 issue 2 */
                                        if (g_json.length > 0) {
                                            //ASA-1374 //ASA-1418
                                            if (g_json[0].ModuleInfo[p_mod_index].ShelfInfo[i].ObjType !== "BASE" && g_json[0].ModuleInfo[p_mod_index].ShelfInfo[i].ObjType !== "NOTCH" && g_json[0].ModuleInfo[p_mod_index].ShelfInfo[i].ObjType !== "TEXTBOX" && g_json[0].ModuleInfo[p_mod_index].ShelfInfo[i].ObjType !== "DIVIDER") {
                                                //ASA-1418 Task 2
                                                g_json[0].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo[item_ind].MIndex = p_mod_index; //ASA-1353 issue 3 20240424,p_pog_index
                                                g_json[0].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo[item_ind].SIndex = i; // ASA-1374 p_pog_index
                                                g_json[0].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo[item_ind].IIndex = item_ind; // ASA-1374 p_pog_index
                                            }
                                        }
                                        //End Task_26899
                                        if (itemdtl.Item == "DIVIDER") {
                                            var objID = add_items(itemdtl.ItemID, itemdtl.W, itemdtl.H, itemdtl.D, itemdtl.Color, itemdtl.X, itemdtl.Y, itemdtl.Z, p_mod_index, i, j, itemdtl.Rotation, p_pog_index);
                                        } else {
                                            //This below condition will be true only when
                                            if (p_crush_item == "Y" && g_pog_json[p_pog_index].MassUpdate == "Y") {
                                                //ASA-1310 KUSH FIX //--20240415 Rregression issue 12
                                                if ((itemdtl.CapStyle == "1" || itemdtl.CapStyle == "2" || itemdtl.CapStyle == "3") && itemdtl.CapCount == 0) {
                                                    await set_item_capping(p_pog_index, p_mod_index, i, j, "Y", "N"); //ASA-1410 issue 10 20240625 //ASA-1412 issue 1 20240628 //ASA-1936 Issue 1
                                                }
                                                //Start Task-02_25977
                                                //var [item_owidth, item_oheight, item_odepth, wActualHeight, wActualWidth, wActualDepth] = get_new_orientation_dim(itemdtl.Orientation, 0, 0, 0);//ASA-1353 issue 3 --Task_27104
                                                // if (wActualHeight == 'H' || wActualWidth == 'H' || wActualDepth == 'H') {//ASA-1353 issue 3 --Task_27104
                                                if (!(ShelfInfo["ObjType"] == "CHEST" && g_chest_as_pegboard == "Y")) {
                                                    //20240708 Regression issue 4
                                                    if (itemdtl.MVertCrushed == "Y" || itemdtl.MassCrushV == "Y" || ShelfInfo["AllowAutoCrush"] == "Y") { //ASA-2000 POINT 5 ADDING CONDITION
                                                        var retval = crushItem(p_pog_index, p_mod_index, i, j, "H", "Y", [itemdtl.D], [j], "Y"); //ASA-1383 issue 8//20240415 Rregression issue 12 20240430
                                                    }
                                                    // }
                                                    //if (wActualHeight == 'W' || wActualWidth == 'W' || wActualDepth == 'W') {//ASA-1353 issue 3 --Task_27104
                                                    if (itemdtl.MHorizCrushed == "Y" || itemdtl.MassCrushH == "Y" || ShelfInfo["AllowAutoCrush"] == "Y") {
                                                        //&& ShelfInfo["Combine"] =="N") { //crush issue regression 6 ,--asa-1353 issue 3-- && itemdtl.CWPerc !== 0 //ASA-1386  Issue 1
                                                        var retval = crushItem(p_pog_index, p_mod_index, i, j, "W", "Y", [itemdtl.D], [j], ShelfInfo["DivPed"] == "Y" && ShelfInfo["DivWidth"] > 0 ? "Y" : "N"); //ASA-1383 issue 8//ASA-1353 regression issue
                                                        l_item_crush = retval == "Y" ? "Y" : "N"; //ASA-1349 issue 2-3
                                                    }
                                                    //  }
                                                    //  if (wActualHeight == 'D' || wActualWidth == 'D' || wActualDepth == 'D') {//ASA-1353 issue 3 --Task_27104
                                                    if (itemdtl.MDepthCrushed == "Y" || itemdtl.MassCrushD == "Y" || ShelfInfo["AllowAutoCrush"] == "Y") {
                                                        // && ShelfInfo["Combine"] =="N") { //ASA-1351 issue 5 ,--asa-1353 issue 3   && itemdtl.CDPerc !== 0 //ASA-1386  Issue 1
                                                        var retval = crushItem(p_pog_index, p_mod_index, i, j, "D", "Y", [itemdtl.D], [j], "Y"); //ASA-1383 issue 8//ASA-1353 regression issue,//ASA-1442 issue 7
                                                    }
                                                } //20240708 Regression issue 4
                                                //  }
                                                //End Task-02_25977

                                                if (p_new_pog_ind == "N" && p_pog_type == "F") {
                                                    //ASA-25959 Kush added x and y set agin after crush  calculation
                                                    if (items.Item == "DIVIDER") {
                                                        itemdtl.X = wpdSetFixed(items.X + items.W / 2);
                                                    } else {
                                                        itemdtl.X = wpdSetFixed(ShelfInfo["X"] - ShelfInfo["W"] / 2 + items.X + itemdtl.W / 2);
                                                    }
                                                    if (ShelfInfo["ObjType"] == "PEGBOARD") {
                                                        if (p_json_array[p_pog_index].MassUpdate == "Y") {
                                                            //ASA-25959 didnot minus the base height after mass update
                                                            itemdtl.Y = wpdSetFixed(items.Y - itemdtl.H / 2);
                                                        } else {
                                                            itemdtl.Y = wpdSetFixed(items.Y - itemdtl.H / 2 - g_pog_json[p_pog_index].BaseH);
                                                        }
                                                    } else if (ShelfInfo["ObjType"] == "HANGINGBAR") {
                                                        itemdtl.Y = wpdSetFixed(ShelfInfo["Y"] - itemdtl.H / 2);
                                                    } else {
                                                        if (g_pog_json[p_pog_index].DesignType == "D" && g_pog_json[p_pog_index].MassUpdate == "Y" && ShelfInfo["ObjType"] == "SHELF") {
                                                            itemdtl.Y = wpdSetFixed(ShelfInfo["Y"] + ShelfInfo["H"] / 2 + itemdtl.H / 2);
                                                        } else {
                                                            itemdtl.Y = wpdSetFixed(items.Y + itemdtl.H / 2);
                                                        }
                                                    }
                                                    itemdtl.Distance = wpdSetFixed(itemdtl.X - itemdtl.W / 2 - shelf_start);
                                                    itemdtl.YDistance = wpdSetFixed(itemdtl.Y - ShelfInfo["Y"] + ShelfInfo["H"] / 2);
                                                    if (ShelfInfo["ObjType"] == "PEGBOARD") {
                                                        itemdtl.PegBoardX = wpdSetFixed(itemdtl.X - itemdtl.W / 2 - shelf_start);
                                                        itemdtl.PegBoardY = wpdSetFixed(itemdtl.Y - itemdtl.H / 2 - (ShelfInfo["Y"] - ShelfInfo["H"] / 2));
                                                    }
                                                }
                                            }
                                            var itemdtl = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo[item_ind];
                                            if (g_show_live_image == "N") {
                                                //  console.log(" g_orientation_jsoni", items.Orientation);
                                                // console.log("detail of g_orientation_jsoni", g_orientation_json[items.Orientation]);
                                                var details = g_orientation_json[items.Orientation];
                                        
                                                 var details_arr = details.split("###");
                                                // var details = g_orientation_json[items.Orientation];
                                                //     var details_arr = (details || "0###0").toString().split("###");
                                                //     var orientX = parseInt(details_arr[0]) || 0;
                                                //     var orientY = parseInt(details_arr[1]) || 0;
                                                //  var objID = await add_items_with_image(itemdtl.ItemID, itemdtl.W, itemdtl.H, itemdtl.D, itemdtl.Color, itemdtl.X, itemdtl.Y, itemdtl.Z, p_mod_index, i, j, itemdtl.BHoriz, itemdtl.BVert, itemdtl.Item, orientX, orientY, "N", "Y", p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_pog_index);
                                                var objID = await add_items_with_image(itemdtl.ItemID, itemdtl.W, itemdtl.H, itemdtl.D, itemdtl.Color, itemdtl.X, itemdtl.Y, itemdtl.Z, p_mod_index, i, j, itemdtl.BHoriz, itemdtl.BVert, itemdtl.Item, parseInt(details_arr[0]), parseInt(details_arr[1]), "N", "Y", p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_pog_index);
                                            } else {
                                                var objID = await add_items_prom(itemdtl.ItemID, itemdtl.W, itemdtl.H, itemdtl.D, itemdtl.Color, itemdtl.X, itemdtl.Y, itemdtl.Z, p_mod_index, i, j, "N", "Y", p_pogcrDelistItemDftColor, p_pogcrItemNumLabelColor, p_pogcrDisplayItemInfo, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pog_index);
                                            }
                                        }
                                        var selectedObject = g_world.getObjectById(objID);
                                        if (typeof selectedObject !== "undefined" && g_show_live_image == "N") {
                                            if (itemdtl.Status == "N") {
                                                selectedObject.BorderColour = g_status_error_color;
                                                selectedObject.Status = "N";
                                                selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                                            } else {
                                                if (nvl(items.OOSPerc) > 80 && g_pogcr_enbl_oos_border == "Y") {
                                                    //ASA-1688
                                                    selectedObject.BorderColour = g_pogcr_oos_border_color; //ASA-1688 Added to give blue border to item
                                                    selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                                                } else {
                                                    selectedObject.BorderColour = 0x000000;
                                                }
                                            }
                                        }
                                        // End ASA-1350 issue 6 case 2 corrected from object to use json directly.
                                        if (ShelfInfo["ObjType"] == "PALLET") {
                                            g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo[j].Z = wpdSetFixed(itemdtl.Z); //ASA-1892 Issue 3
                                            //   g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo[j].Z = wpdSetFixed(items.Z + items.D / 2)* itemdtl.DFacing; //ASA-1892 Issue 3
                                        } else {
                                            g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo[j].Z = 0.016;
                                        }
                                        g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo[j].ObjID = objID;
                                        g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo[j].CType = ShelfInfo["ObjType"];
                                    }
                                    j = j + 1;
                                }
                                var shelfObj = g_world.getObjectById(g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[i].SObjID);
                                if (typeof shelfObj !== "undefined") {
                                    shelfObj.AvlSpace = wpdSetFixed(shelfObj.AvlSpace * 100); //parseFloat((shelfObj.AvlSpace * 100).toFixed(3));
                                }
                                //ASA-2010 Issue1 Start
                                // if (ShelfInfo["ObjType"] == "SHELF") {
                                //     var returnval = await reset_top_bottom_objects(p_mod_index, i, "Y", p_pog_index);
                                // }
                                if (ShelfInfo["ObjType"] == "SHELF" || ShelfInfo["ObjType"] == "PALLET") {
                                    var returnval = await reset_top_bottom_objects(p_mod_index, i, "Y", p_pog_index);
                                }
                                //ASA-2010 Issue1 End
                                var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[i];
                                if (shelfdtl.Combine == "N" && l_item_crush == "Y" && !(shelfdtl.ObjType == "CHEST" && g_chest_as_pegboard == "Y") && shelfdtl.ObjType !== "PEGBOARD") {
                                    //--Task_26793 prod issue //ASA-1387 Issue 2, added "shelfdtl.Combine == "N",Found error when reorder for combined shelfs suggested by prasanna need to confirm tomorrow(commented on 20240422)

                                    var spread_gap = shelfdtl.HorizGap;
                                    var horiz_gap = spread_gap;
                                    var spread_product = shelfdtl.SpreadItem;
                                    var item_length = shelfdtl.ItemInfo.length;
                                    var allow_crush = shelfdtl.AllowAutoCrush;
                                    if (reorder_items(p_mod_index, i, p_pog_index)) {
                                        var k = 0;
                                        for (item_info of shelfdtl.ItemInfo) {
                                            var new_x = get_item_xaxis(item_info.W, item_info.H, item_info.D, item_info.CType, "", horiz_gap, spread_product, spread_gap, p_mod_index, i, k, "Y", item_length, "N", p_pog_index);
                                            item_info.X = wpdSetFixed(new_x);
                                            //Start ASA-1350 issue 6 case 2 -- after last item crush it needs to be created with new width.
                                            var selectedObject = g_world.getObjectById(item_info.ObjID);
                                            g_world.remove(selectedObject);
                                            if (item_info.Item == "DIVIDER") {
                                                //ASA-1402
                                                var objID = add_items(item_info.ItemID, item_info.W, item_info.H, item_info.D, item_info.Color, item_info.X, item_info.Y, item_info.Z, p_mod_index, i, k, item_info.Rotation, p_pog_index);
                                            } else {
                                                //ASA-1402
                                                if (g_show_live_image == "Y") {
                                                    var details = g_orientation_json[item_info.Orientation];
                                                    var details_arr = details.split("###");

                                                    var objID = await add_items_with_image(item_info.ItemID, item_info.W, item_info.H, item_info.D, item_info.Color, item_info.X, item_info.Y, item_info.Z, p_mod_index, i, k, item_info.BHoriz, item_info.BVert, item_info.Item, parseInt(details_arr[0]), parseInt(details_arr[1]), "N", "Y", p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_pog_index);
                                                } else {
                                                    var objID = await add_items_prom(item_info.ItemID, item_info.W, item_info.H, item_info.D, item_info.Color, item_info.X, item_info.Y, item_info.Z, p_mod_index, i, k, "N", "Y", p_pogcrDelistItemDftColor, p_pogcrItemNumLabelColor, p_pogcrDisplayItemInfo, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pog_index);
                                                }
                                            } //ASA-1402
                                            g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[i].ItemInfo[k].ObjID = objID;
                                            //End ASA-1350 issue 6 case 2
                                            k++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    i = i + 1;
                }
                var l_shelf_details = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo;
                var l_shelf_cnt = 0;
                for (const shelfs of l_shelf_details) {
                    var l_item_cnt = 0;
                    for (const items of shelfs.ItemInfo) {
                        if (items.Item == "DIVIDER") {
                            var l_dup_shelf = 0;
                            for (const shelfs_dtl of l_shelf_details) {
                                if (shelfs_dtl.ObjType == "DIVIDER" && shelfs_dtl.Shelf == items.ItemID) {
                                    g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[l_dup_shelf].ShelfDivObjID = items.ObjID;
                                }
                                l_dup_shelf++;
                            }
                        }
                        l_item_cnt++;
                    }
                    l_shelf_cnt++;
                }
            }
        }
        render(p_pog_index);
        logDebug("function : create_shelf_from_json_lib", "E");
    } catch (err) {
        error_handling(err);
    }
}

async function add_module_lib(p_uuid, p_width, p_height, p_depth, p_color, p_x, p_y, p_edit_ind, p_pog_flag, p_vert_start, p_vert_spacing, p_horz_start, p_horz_spacing, p_recreate, p_camera, p_module_ind, p_SpreadItem, p_HorizSpacing, p_VertiSpacing, p_BsktWallThickness, p_ChestWallThickness, p_AutoPlacing, p_WrapText, p_FSize, p_TextboxColor, p_ShelfColor, p_DivColor, p_SlotDivider, p_SlotOrientation, p_DividerFixed, p_ItemColor, p_ItemDelistColor, p_pegHolesActive, p_pogCarparkShelfDftColor, p_enlargeNo, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrDelistItemDftColor, p_pogcrItemNumLabelColor, p_pogcrDisplayItemInfo, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_notchHead, p_updateObjInd = "N", p_pog_index, p_DftBskFill, p_DftBaskSprd, p_m_crush = "N") {
    logDebug("function : add_module_lib; uuid : " + p_uuid + "; width : " + p_width + "; height : " + p_height + "; depth : " + p_depth + "; color : " + p_color + "; x : " + p_x + "; y : " + p_y + "; p_edit_ind : " + p_edit_ind + "; pog_flag : " + p_pog_flag + "; vert_start : " + p_vert_start + "; vert_spacing : " + p_vert_spacing + "; horz_start : " + p_horz_start + "; horz_spacing : " + p_horz_spacing + "; recreate : " + p_recreate + "; module_ind : " + p_module_ind, "S");
    try {
        console.log("add_module_lib", g_pog_json, p_pog_index);
        var notchX;
        if (p_module_ind == -1 || typeof p_module_ind == "undefined") {
            var module_count = parseFloat(g_pog_json[p_pog_index].ModuleInfo.length) - 1;
        } else {
            var module_count = p_module_ind;
        }
        var mod_cnt_chk = module_count;
        var finalX;
        var finalY; //ASA-1694 issue 10
        var moduleX = 0;
        var POGJSON_arr = [];

        if (p_edit_ind == "Y") {
            POGJSON_arr = JSON.parse(g_temp_POG_arr);
            var selectedObject = g_world.getObjectById(g_dblclick_objid);
            g_world.remove(selectedObject);
            module_count = g_module_index;
            var edit_x = 0;
            var object_exists = "N";
            var module_x_arr = [];
            var module_y_arr = [];
            var edit_index_arr = [];
            $.each(g_pog_json[p_pog_index].ModuleInfo, function (i, Modules) {
                if (Modules.ParentModule == null || Modules.ParentModule == "undefined") {
                    if (i < g_module_index) {
                        edit_x += Modules.W;
                    } else if (i > g_module_index) object_exists = "Y";
                }
            });
            if (object_exists == "Y") {
                finalX = edit_x + p_width / 2;
                module_x_arr.push(finalX);
                module_y_arr.push(p_height / 2 + g_pog_json[p_pog_index].BaseH);
                edit_index_arr.push(module_count);
                edit_x = edit_x + p_width;
                $.each(g_pog_json[p_pog_index].ModuleInfo, function (i, Modules) {
                    if (Modules.ParentModule == null || Modules.ParentModule == "undefined") {
                        if (i > g_module_index) {
                            var selectedObject = g_world.getObjectById(Modules.MObjID);
                            g_world.remove(selectedObject);
                            finalX = edit_x + Modules.W / 2;
                            edit_index_arr.push(i);
                            module_x_arr.push(finalX);
                            module_y_arr.push(Modules.H / 2 + g_pog_json[p_pog_index].BaseH);
                            edit_x += Modules.W;
                        }
                    }
                });

                var index = 0;
                for (const mod_x of module_x_arr) {
                    const edited_index = edit_index_arr[index];
                    const moduleY = module_y_arr[index];
                    var colorValue = parseInt(g_pog_json[p_pog_index].ModuleInfo[edited_index].Color.replace("#", "0x"), 16);
                    var hex_decimal = new THREE.Color(colorValue);

                    var return_val = await create_final_module(g_pog_json[p_pog_index].ModuleInfo[edited_index].Module, g_pog_json[p_pog_index].ModuleInfo[edited_index].W, g_pog_json[p_pog_index].ModuleInfo[edited_index].H, g_pog_json[p_pog_index].ModuleInfo[edited_index].D, hex_decimal, moduleY, p_edit_ind, g_pog_json[p_pog_index].ModuleInfo[edited_index].VertStart, g_pog_json[p_pog_index].ModuleInfo[edited_index].VertSpacing, g_pog_json[p_pog_index].ModuleInfo[edited_index].HorzStart, g_pog_json[p_pog_index].ModuleInfo[edited_index].HorzSpacing, mod_x, edited_index, p_pegHolesActive, p_pog_index);

                    if (p_edit_ind == "Y" && typeof POGJSON_arr[p_pog_index].ModuleInfo[edited_index] !== "undefined" && typeof POGJSON_arr[p_pog_index].ModuleInfo[0].ShelfInfo !== "undefined") {
                        if (typeof POGJSON_arr[p_pog_index].ModuleInfo[edited_index].Carpark !== "undefined") {
                            if (POGJSON_arr[p_pog_index].ModuleInfo[edited_index].Carpark.length > 0) {
                                var return_val = await create_shelf_edit_pog_lib(edited_index, POGJSON_arr[p_pog_index].ModuleInfo[edited_index].Carpark, p_width, "Y", "Y", "D", "Y", "Y", "Y", p_AutoPlacing, p_ShelfColor, p_DivColor, p_SlotDivider, p_SlotOrientation, p_DividerFixed, p_ItemColor, p_ItemDelistColor, p_pogCarparkShelfDftColor, p_enlargeNo, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrDelistItemDftColor, p_pogcrItemNumLabelColor, p_pogcrDisplayItemInfo, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_notchHead, p_updateObjInd, p_camera, p_pog_index, p_pog_index, p_m_crush);
                            }
                        }
                        if (POGJSON_arr[p_pog_index].ModuleInfo[0].ShelfInfo.length > 0) {
                            var return_val = await create_shelf_from_json_lib(edited_index, POGJSON_arr, g_pog_json[p_pog_index].ModuleInfo[edited_index].W, "N", "Y", "D", "Y", "Y", false, null, "N", null, p_SpreadItem, p_HorizSpacing, p_VertiSpacing, p_BsktWallThickness, p_ChestWallThickness, p_AutoPlacing, p_WrapText, p_FSize, p_TextboxColor, p_ShelfColor, p_ItemColor, p_ItemDelistColor, p_pogCarparkShelfDftColor, p_enlargeNo, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrDelistItemDftColor, p_pogcrItemNumLabelColor, p_pogcrDisplayItemInfo, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_updateObjInd, p_notchHead, p_DftBskFill, p_DftBaskSprd, p_camera, p_pog_index, p_pog_index, p_m_crush); //ASA-1300
                        }
                    }
                    index = index + 1;
                }
            } else {
                finalX = edit_x + p_width / 2;
                var return_val = await create_final_module(g_pog_json[p_pog_index].ModuleInfo[module_count].Module, p_width, p_height, p_depth, p_color, p_y, p_edit_ind, p_vert_start, p_vert_spacing, p_horz_start, p_horz_spacing, finalX, module_count, p_pegHolesActive, p_pog_index);
                if (p_edit_ind == "Y" && typeof POGJSON_arr[p_pog_index].ModuleInfo[module_count] !== "undefined" && typeof POGJSON_arr[p_pog_index].ModuleInfo[0].ShelfInfo !== "undefined") {
                    if (typeof POGJSON_arr[p_pog_index].ModuleInfo[0].Carpark !== "undefined") {
                        if (POGJSON_arr[p_pog_index].ModuleInfo[0].Carpark.length > 0) {
                            var return_val = await create_shelf_edit_pog_lib(0, POGJSON_arr[p_pog_index].ModuleInfo[0].Carpark, p_width, "Y", "Y", "D", "N", "Y", "Y", p_AutoPlacing, p_ShelfColor, p_DivColor, p_SlotDivider, p_SlotOrientation, p_DividerFixed, p_ItemColor, p_ItemDelistColor, p_pogCarparkShelfDftColor, p_enlargeNo, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrDelistItemDftColor, p_pogcrItemNumLabelColor, p_pogcrDisplayItemInfo, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_notchHead, p_updateObjInd, p_camera, p_pog_index, p_pog_index, p_m_crush); //ASA-1300
                        }
                    }
                    if (POGJSON_arr[p_pog_index].ModuleInfo[0].ShelfInfo.length > 0) {
                        var return_val = await create_shelf_from_json_lib(module_count, POGJSON_arr, p_width, "N", "Y", "D", "Y", "Y", false, [], "N", null, p_SpreadItem, p_HorizSpacing, p_VertiSpacing, p_BsktWallThickness, p_ChestWallThickness, p_AutoPlacing, p_WrapText, p_FSize, p_TextboxColor, p_ShelfColor, p_ItemColor, p_ItemDelistColor, p_pogCarparkShelfDftColor, p_enlargeNo, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrDelistItemDftColor, p_pogcrItemNumLabelColor, p_pogcrDisplayItemInfo, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_updateObjInd, p_notchHead, p_DftBskFill, p_DftBaskSprd, p_camera, p_pog_index, p_pog_index, p_m_crush);
                    }
                }
            }
        } else {
            if (g_pog_json[p_pog_index].ModuleInfo.length > 0) {
                var i = 0;
                $.each(g_pog_json[p_pog_index].ModuleInfo, function (i, Modules) {
                    if (Modules.ParentModule == null || Modules.ParentModule == "undefined") {
                        if (i < module_count) moduleX += Modules.W;
                    }
                });
            }

            finalX = p_width / 2 + moduleX;
            finalY = wpdSetFixed(p_height / 2 + g_pog_json[p_pog_index].BaseH); //ASA-1694 issue 10
            var return_val = await create_final_module(p_uuid, p_width, p_height, p_depth, p_color, finalY, p_edit_ind, p_vert_start, p_vert_spacing, p_horz_start, p_horz_spacing, finalX, module_count, p_pegHolesActive, p_pog_index); //ASA-1694 changes p_y to finalY Issue 10
        }
        var module_sum = g_pog_json[p_pog_index].W;
        if (g_pog_json[p_pog_index].BaseH > 0) {
            var colorValue = parseInt(g_pog_json[p_pog_index].Color.replace("#", "0x"), 16);
            var hex_decimal = new THREE.Color(colorValue);
            g_pog_json[p_pog_index].BaseW = module_sum;
            g_pog_json[p_pog_index].BaseX = module_sum / 2;
            var return_val = add_base("BASE1", module_sum, g_pog_json[p_pog_index].BaseH, g_pog_json[p_pog_index].BaseD, hex_decimal, module_sum / 2, g_pog_json[p_pog_index].BaseY, "Y", p_pog_index);
        }
        if (p_recreate == "N") {
            var details = get_min_max_xy(p_pog_index);
            var details_arr = details.split("###");
            set_camera_z(p_camera, parseFloat(details_arr[2]), parseFloat(details_arr[3]), parseFloat(details_arr[0]), parseFloat(details_arr[1]), g_offset_z, parseFloat(details_arr[4]), parseFloat(details_arr[5]), true, g_pog_index);
        }
        if (p_updateObjInd == "Y") {
            var res = updateObjID(p_uuid, p_module_ind, "M");
        }
        logDebug("function : add_module_lib", "E");
        return "SUCCESS";
    } catch (err) {
        error_handling(err);
    }
}

async function create_shelf_edit_pog_lib(p_mod_index, p_json_array, p_module_width, p_draft_ind, p_new_pog_ind, p_pog_type, p_carpark_ind, p_recreate, p_create_json, p_AutoPlacing, p_ShelfColor, p_DivColor, p_SlotDivider, p_SlotOrientation, p_DividerFixed, p_ItemColor, p_ItemDelistColor, p_pogCarparkShelfDftColor, p_enlargeNo, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrDelistItemDftColor, p_pogcrItemNumLabelColor, p_pogcrDisplayItemInfo, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_notchHead, p_updateObjInd, p_camera, p_pog_index, p_orgPogIndex, p_m_crush = "N") {
    logDebug("function : create_shelf_edit_pog_lib; mod_index : " + p_mod_index + "; p_module_width : " + p_module_width + "; draft_ind : " + p_draft_ind + "; new_pog_ind : " + p_new_pog_ind + "; pog_type : " + p_pog_type + "; carpark_ind : " + p_carpark_ind + "; recreate : " + p_recreate, "S");
    try {
        var newObjectID = -1;
        if (typeof p_json_array !== "undefined") {
            if (p_json_array.length > 0) {
                var carparkItemInfo = [];
                var i = 0;
                for (const shelfs in p_json_array) {
                    var selectedObject = g_world.getObjectById(shelfs.SObjID);
                    g_world.remove(selectedObject);
                    i++;
                }

                var l_shelf_details = p_json_array;
                var i = 0;
                for (const shelfs of p_json_array) {
                    // $.each(json_array, function (i, shelfs) {
                    var selectedObject = g_world.getObjectById(shelfs.SObjID);
                    g_world.remove(selectedObject);
                    // });
                    i++;
                }
                if (g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark.length > 0) {
                    if (typeof g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark[0] !== "undefined") {
                        if (typeof g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark[0].ItemInfo !== "undefined") {
                            if (g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark[0].ItemInfo.length > 0) {
                                carparkItemInfo = JSON.parse(JSON.stringify(g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark[0].ItemInfo));
                                for (d of carparkItemInfo) {
                                    var selectedObject = g_world.getObjectById(d.ObjID);
                                    g_world.remove(selectedObject);
                                }
                            }
                        }
                    }
                }
                if (p_create_json == "Y") {
                    g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark = [];
                }
                var i = 0;
                for (const shelfs of l_shelf_details) {
                    var shelf_ind = -1;
                    if (shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "BASE") {
                        var ShelfInfo = {};
                        if (p_create_json == "Y") {
                            if (p_carpark_ind == "N") {
                                ShelfInfo["X"] = shelfs.X;
                                ShelfInfo["Y"] = shelfs.Y;
                                ShelfInfo["Z"] = shelfs.Z;
                                ShelfInfo["GrillH"] = shelfs.GrillH;
                                ShelfInfo["LOverhang"] = shelfs.LOverhang;
                                ShelfInfo["ROverhang"] = shelfs.ROverhang;
                                ShelfInfo["SpacerThick"] = shelfs.SpacerThick;
                                ShelfInfo["HorizGap"] = shelfs.HorizGap !== null && shelfs.HorizGap !== "" && typeof shelfs.HorizGap !== "undefined" ? shelfs.HorizGap : 0; //ASA-1902
                                ShelfInfo["SpreadItem"] = shelfs.SpreadItem;
                                ShelfInfo["Combine"] = shelfs.Combine;
                                ShelfInfo["AllowAutoCrush"] = shelfs.AllowAutoCrush;
                                ShelfInfo["HorizSlotStart"] = shelfs.HorizSlotStart;
                                ShelfInfo["HorizSlotSpacing"] = shelfs.HorizSlotSpacing;
                                ShelfInfo["HorizStart"] = shelfs.HorizStart;
                                ShelfInfo["HorizSpacing"] = shelfs.HorizSpacing;
                                ShelfInfo["UOverHang"] = shelfs.UOverHang;
                                ShelfInfo["LoOverHang"] = shelfs.LoOverHang;
                                ShelfInfo["VertiStart"] = shelfs.VertiStart;
                                ShelfInfo["VertiSpacing"] = shelfs.VertiSpacing;
                                ShelfInfo["BsktFill"] = shelfs.BsktFill;
                                ShelfInfo["BsktSpreadProduct"] = shelfs.BsktSpreadProduct;
                                ShelfInfo["SnapTo"] = shelfs.SnapTo;
                                ShelfInfo["BsktWallH"] = shelfs.BsktWallH;
                                ShelfInfo["BsktBaseH"] = shelfs.BsktBaseH;
                                ShelfInfo["BsktWallThickness"] = shelfs.BsktWallThickness;
                                ShelfInfo["DSlotStart"] = shelfs.DSlotStart;
                                ShelfInfo["DSlotSpacing"] = shelfs.DSlotSpacing;
                                ShelfInfo["DGap"] = shelfs.DGap;
                                ShelfInfo["FrontOverHang"] = shelfs.FrontOverHang;
                                ShelfInfo["BackOverHang"] = shelfs.BackOverHang;
                                ShelfInfo["SlotDivider"] = shelfs.SlotDivider;
                                ShelfInfo["AllowOverLap"] = shelfs.AllowOverLap;
                                ShelfInfo["AutoPlacing"] = typeof shelfs.AutoPlacing !== "undefined" && shelfs.AutoPlacing !== "" ? shelfs.AutoPlacing : "";
                                ShelfInfo["AutoFillPeg"] = typeof shelfs.AutoFillPeg !== "undefined" && shelfs.AutoFillPeg !== "" ? shelfs.AutoFillPeg : ""; //ASA-1109
                                ShelfInfo["AvlSpace"] = shelfs.W + shelfs.LOverhang + shelfs.ROverhang;
                                ShelfInfo["WrapText"] = shelfs.WrapText;
                                ShelfInfo["ReduceToFit"] = shelfs.ReduceToFit;
                                ShelfInfo["TextDirection"] = shelfs.TextDirection;
                                ShelfInfo["SlotOrientation"] = shelfs.SlotOrientation;
                                ShelfInfo["DividerFixed"] = shelfs.DividerFixed;
                                ShelfInfo["LObjID"] = shelfs.LObjID;
                                ShelfInfo["NotchLabelObjID"] = shelfs.NotchLabelObjID;
                                ShelfInfo["Shelf"] = shelfs.Shelf;
                                ShelfInfo["ObjType"] = shelfs.ObjType;
                                ShelfInfo["Desc"] = shelfs.Desc;
                                ShelfInfo["MaxMerch"] = shelfs.MaxMerch;
                                ShelfInfo["FStyle"] = shelfs.FStyle;
                                ShelfInfo["FSize"] = shelfs.FSize;
                                ShelfInfo["FBold"] = shelfs.FBold;
                                ShelfInfo["TextImg"] = shelfs.TextImg;
                                ShelfInfo["TextImgName"] = shelfs.TextImgName; //ASA-1650 issue 10
                                ShelfInfo["TextImgMime"] = shelfs.TextImgMime; //ASA-1650 issue 10
                                ShelfInfo["NotchNo"] = shelfs.NotchNo;
                                ShelfInfo["ManualCrush"] = typeof shelfs.ManualCrush !== "undefined" && shelfs.ManualCrush !== "" ? shelfs.ManualCrush : p_m_crush; //ASA-1300
                                ShelfInfo["Overhung"] = typeof shelfs.Overhung == "undefined" && shelfs.Overhung !== "" ? "N" : shelfs.Overhung; //ASA-1138
                                if (shelfs.ObjType == "BASE") {
                                    ShelfInfo["H"] = g_pog_json[p_pog_index].BaseH;
                                    ShelfInfo["W"] = g_pog_json[p_pog_index].BaseW;
                                    ShelfInfo["D"] = g_pog_json[p_pog_index].BaseD;
                                    ShelfInfo["Color"] = g_pog_json[p_pog_index].Color;
                                } else if (shelfs.ObjType == "NOTCH") {
                                    ShelfInfo["H"] = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].H;
                                    ShelfInfo["W"] = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].NotchW;
                                    ShelfInfo["D"] = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].D;
                                    ShelfInfo["Color"] = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Color;
                                } else {
                                    ShelfInfo["H"] = shelfs.H;
                                    ShelfInfo["W"] = shelfs.W;
                                    ShelfInfo["D"] = shelfs.D;
                                    if (typeof shelfs.Color == "undefined" || shelfs.Color == "#0") {
                                        ShelfInfo["Color"] = p_ShelfColor;
                                    } else {
                                        ShelfInfo["Color"] = shelfs.Color;
                                    }
                                }
                                ShelfInfo["Rotation"] = shelfs.Rotation;
                                ShelfInfo["Slope"] = shelfs.Slope;

                                ShelfInfo["LiveImage"] = shelfs.LiveImage;
                                ShelfInfo["InputText"] = shelfs.InputText;
                                ShelfInfo["CompShelfObjID"] = shelfs.CompShelfObjID;
                                ShelfInfo["ManualZupdate"] = shelfs.ManualZupdate;
                                ShelfInfo["OldObjID"] = shelfs.SObjID;
                                ShelfInfo["DivHeight"] = shelfs.DivHeight; //ASA-1265
                                ShelfInfo["DivWidth"] = shelfs.DivWidth; //ASA-1265
                                ShelfInfo["DivPst"] = shelfs.DivPst; //ASA-1265
                                ShelfInfo["DivPed"] = shelfs.DivPed; //ASA-1265
                                ShelfInfo["DivPbtwFace"] = shelfs.DivPbtwFace; //ASA-1265
                                ShelfInfo["DivStX"] = isNaN(shelfs.DivStX) ? 0 : shelfs.DivStX; //Task_27734 shelfs.DivStX; //ASA-1265
                                ShelfInfo["DivSpaceX"] = isNaN(shelfs.DivSpaceX) ? 0 : shelfs.DivSpaceX; //Task_27734 shelfs.DivSpaceX; //ASA-1265
                                ShelfInfo["DivFillCol"] = shelfs.DivFillCol; //ASA-1265
                                ShelfInfo["NoDivIDShow"] = shelfs.NoDivIDShow; //ASA-1406
                                ShelfInfo["ChestEdit"] = shelfs.ChestEdit !== null && shelfs.ChestEdit !== "" && typeof shelfs.ChestEdit !== "undefined" ? shelfs.ChestEdit : "N"; //Bug-26122 - splitting the chest
                                ShelfInfo["ItemInfo"] = [];
                            } else {
                                ShelfInfo["Shelf"] = shelfs.Shelf;
                                ShelfInfo["ObjType"] = "SHELF";
                                ShelfInfo["Desc"] = "CARPARK_SHELF";
                                ShelfInfo["MaxMerch"] = 0;
                                ShelfInfo["GrillH"] = 0;
                                ShelfInfo["LOverhang"] = 0;
                                ShelfInfo["ROverhang"] = 0;
                                ShelfInfo["SpacerThick"] = 0;
                                ShelfInfo["HorizGap"] = 0;
                                ShelfInfo["SpreadItem"] = "L";
                                ShelfInfo["Combine"] = "N";
                                ShelfInfo["AllowAutoCrush"] = "N";
                                ShelfInfo["H"] = shelfs.H;
                                ShelfInfo["W"] = shelfs.W;
                                ShelfInfo["D"] = shelfs.D;
                                ShelfInfo["Rotation"] = 0;
                                ShelfInfo["Slope"] = 0;
                                ShelfInfo["Color"] = p_DivColor;
                                ShelfInfo["LiveImage"] = "";
                                ShelfInfo["HorizSlotStart"] = 0;
                                ShelfInfo["HorizSlotSpacing"] = 0;
                                ShelfInfo["HorizStart"] = 0;
                                ShelfInfo["HorizSpacing"] = 0;
                                ShelfInfo["UOverHang"] = 0;
                                ShelfInfo["LoOverHang"] = 0;
                                ShelfInfo["VertiStart"] = 0;
                                ShelfInfo["VertiSpacing"] = 0;
                                ShelfInfo["X"] = shelfs.X;
                                ShelfInfo["Y"] = shelfs.Y;

                                ShelfInfo["InputText"] = "";
                                ShelfInfo["WrapText"] = "";
                                ShelfInfo["ReduceToFit"] = "";
                                ShelfInfo["TextDirection"] = "";
                                ShelfInfo["BsktFill"] = "";
                                ShelfInfo["BsktSpreadProduct"] = "";
                                ShelfInfo["SnapTo"] = "";
                                ShelfInfo["BsktWallH"] = 0;
                                ShelfInfo["BsktBaseH"] = 0;
                                ShelfInfo["BsktWallThickness"] = 0;
                                ShelfInfo["DSlotStart"] = 0;
                                ShelfInfo["DSlotSpacing"] = 0;
                                ShelfInfo["DGap"] = 0;
                                ShelfInfo["FrontOverHang"] = 0;
                                ShelfInfo["BackOverHang"] = 0;
                                ShelfInfo["SlotDivider"] = p_SlotDivider;
                                ShelfInfo["AllowOverLap"] = "N";
                                ShelfInfo["AutoPlacing"] = "N";
                                ShelfInfo["AutoFillPeg"] = "N"; //ASA-1109
                                ShelfInfo["SlotOrientation"] = p_SlotOrientation;
                                ShelfInfo["DividerFixed"] = p_DividerFixed;
                                ShelfInfo["LObjID"] = -1;
                                ShelfInfo["NotchLabelObjID"] = -1;
                                ShelfInfo["FStyle"] = "";
                                ShelfInfo["FSize"] = "";
                                ShelfInfo["FBold"] = "";
                                ShelfInfo["TextImg"] = "";
                                ShelfInfo["TextImgName"] = "";
                                ShelfInfo["TextImgMime"] = "";
                                ShelfInfo["TextImageBlob"] = "";
                                ShelfInfo["ItemInfo"] = [];
                                ShelfInfo["Overhung"] = "N"; //ASA-1138
                                ShelfInfo["DivHeight"] = 0; //ASA-1265
                                ShelfInfo["DivWidth"] = 0; //ASA-1265
                                ShelfInfo["DivPst"] = "N"; //ASA-1265
                                ShelfInfo["DivPed"] = "N"; //ASA-1265
                                ShelfInfo["DivPbtwFace"] = "N"; //ASA-1265
                                ShelfInfo["NoDivIDShow"] = "N"; //ASA-1406
                                ShelfInfo["DivStX"] = 0; //ASA-1265
                                ShelfInfo["DivSpaceX"] = 0; //ASA-1265
                                ShelfInfo["DivFillCol"] = p_DivColor; //ASA-1265
                            }

                            if (shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "BASE" && p_carpark_ind == "N") {
                                g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.push(ShelfInfo);
                                shelf_ind = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.length - 1;
                            } else if (p_carpark_ind == "Y" && shelfs.ItemInfo !== null && shelfs.ItemInfo.length > 0) {
                                g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark.push(ShelfInfo);
                                shelf_ind = 0;
                            }
                        } else {
                            ShelfInfo = shelfs;
                            shelf_ind = i;
                        }
                        var shelf_start = ShelfInfo["X"] - ShelfInfo["W"] / 2;

                        var colorValue = parseInt(ShelfInfo["Color"].replace("#", "0x"), 16);
                        var hex_decimal = new THREE.Color(colorValue);
                        var final_height = 0;
                        if (typeof g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ParentModule == "undefined" || (g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ParentModule == null && p_recreate == "Y")) {
                            if (ShelfInfo["ObjType"] == "PEGBOARD") {
                                var return_val = add_pegboard(ShelfInfo["Shelf"], ShelfInfo["W"], ShelfInfo["H"], ShelfInfo["D"], hex_decimal, ShelfInfo["X"], ShelfInfo["Y"], 0.004, "N", ShelfInfo["VertiStart"], ShelfInfo["VertiSpacing"], ShelfInfo["HorizStart"], ShelfInfo["HorizSpacing"], p_mod_index, g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.length - 1, ShelfInfo["Rotation"], ShelfInfo["Slope"], "N", p_pogcrDelistItemDftColor, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_pog_index); //ASA-1350 issue 6 added parameters
                            } else if (ShelfInfo["ObjType"] == "TEXTBOX") {
                                if (g_show_live_image == "Y" && ShelfInfo["TextImg"] !== "" && typeof ShelfInfo["TextImg"] !== "undefined" && ShelfInfo["TextImg"] !== null) {
                                    var return_val = await add_text_box_with_image(ShelfInfo["Shelf"], "TEXTBOX", ShelfInfo["W"], ShelfInfo["H"], ShelfInfo["D"], hex_decimal, ShelfInfo["X"], ShelfInfo["Y"], ShelfInfo["Z"], "N", p_mod_index, ShelfInfo["InputText"], colorValue, ShelfInfo["WrapText"], ShelfInfo["ReduceToFit"], ShelfInfo["Color"], g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.length - 1, ShelfInfo["Rotation"], ShelfInfo["Slope"], "N", ShelfInfo["FStyle"], ShelfInfo["FSize"], ShelfInfo["FBold"], p_notchHead, p_pog_index);
                                } else {
                                    var return_val = add_text_box(ShelfInfo["Shelf"], "TEXTBOX", ShelfInfo["W"], ShelfInfo["H"], ShelfInfo["D"], hex_decimal, ShelfInfo["X"], ShelfInfo["Y"], ShelfInfo["Z"], "N", p_mod_index, ShelfInfo["InputText"], colorValue, ShelfInfo["WrapText"], ShelfInfo["ReduceToFit"], ShelfInfo["Color"], g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.length - 1, ShelfInfo["Rotation"], ShelfInfo["Slope"], "N", ShelfInfo["FStyle"], ShelfInfo["FSize"], ShelfInfo["FBold"], p_enlargeNo, p_pog_index, g_pogcr_enhance_textbox_fontsize, shelfs.TextDirection);
                                }

                                mod_details = g_pog_json[p_pog_index].ModuleInfo;
                                var c = 0;
                                for (const modules of mod_details) {
                                    if (typeof modules.ParentModule !== "undefined" && modules.ParentModule !== null && modules.Module == ShelfInfo["Shelf"]) {
                                        g_pog_json[p_pog_index].ModuleInfo[c].ObjID = return_val;
                                    }
                                    c = c + 1;
                                }
                            } else if (ShelfInfo["ObjType"] == "ROD") {
                                var return_val = add_rod(ShelfInfo["Shelf"], "SHELF", ShelfInfo["W"], ShelfInfo["H"], ShelfInfo["D"], hex_decimal, ShelfInfo["X"], ShelfInfo["Y"], 0.004, "N", p_mod_index, g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.length - 1, p_pog_index);
                            } else if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && (typeof g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ParentModule == "undefined" || g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ParentModule == null) && ((p_carpark_ind == "Y" && shelfs.ItemInfo !== null && shelfs.ItemInfo.length > 0) || p_carpark_ind == "N")) {
                                if (ShelfInfo["ObjType"] == "BASKET" || ShelfInfo["ObjType"] == "CHEST") {
                                    if (g_chest_as_pegboard == "Y" && ShelfInfo["ObjType"] == "CHEST") {
                                        final_height = ShelfInfo["D"];
                                        ShelfInfo["H"] = ShelfInfo["D"];
                                    } else {
                                        final_height = ShelfInfo["BsktBaseH"];
                                        ShelfInfo["H"] = ShelfInfo["BsktBaseH"];
                                    }
                                } else {
                                    final_height = ShelfInfo["H"];
                                }
                                var [return_val, shelf_cnt] = await add_shelf(ShelfInfo["Shelf"], "SHELF", ShelfInfo["W"], final_height, ShelfInfo["D"], hex_decimal, ShelfInfo["X"], ShelfInfo["Y"], 0.004, "N", p_mod_index, ShelfInfo["Rotation"], ShelfInfo["Slope"], shelf_ind, "N", p_carpark_ind, "Y", -1, p_pogCarparkShelfDftColor, p_notchHead, p_pogcrDelistItemDftColor, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_pog_index, p_json_array /*20241223 Reg 2*/); //ASA-1350 issue 6 added parameters

                                newObjectID = return_val;
                                if (p_updateObjInd == "Y") {
                                    var res = updateObjID(ShelfInfo["OldObjID"], return_val, "S");
                                }
                            }
                        }
                        if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX" && (typeof g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ParentModule == "undefined" || g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ParentModule == null)) {
                            if (typeof p_json_array[i].ItemInfo !== "undefined") {
                                if (p_json_array[i].ItemInfo !== null && p_json_array[i].ItemInfo.length > 0) {
                                    if (p_carpark_ind == "Y") {
                                        item_Details = carparkItemInfo;
                                    } else {
                                        var item_Details = shelfs.ItemInfo;
                                    }

                                    item_Details.sort((a, b) => (a.X > b.X ? 1 : -1));

                                    if (p_carpark_ind == "Y") {
                                        var newItems = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark[shelf_ind].ItemInfo;
                                        for (d of newItems) {
                                            var selectedObject = g_world.getObjectById(d.ObjID);
                                            g_world.remove(selectedObject);
                                        }
                                    }
                                    var j = 0;
                                    for (items of item_Details) {
                                        var selectedObject = g_world.getObjectById(items.ObjID);
                                        g_world.remove(selectedObject);
                                        var ItemInfo = {};
                                        if (p_create_json == "Y") {
                                            if (p_carpark_ind !== "Y") {
                                                ItemInfo["DimT"] = items.DimT;
                                                ItemInfo["PegID"] = items.PegID;
                                                ItemInfo["PegSpread"] = items.PegSpread;
                                                ItemInfo["PegPerFacing"] = items.PegPerFacing;
                                                ItemInfo["Fixed"] = items.Fixed;
                                                ItemInfo["CapStyle"] = items.CapStyle;
                                                /*ASA-1170, Start*/
                                                ItemInfo["CapFacing"] = items.CapFacing;
                                                ItemInfo["CapMerch"] = items.CapMerch;
                                                ItemInfo["CapOrientaion"] = items.CapOrientaion;
                                                ItemInfo["CapHeight"] = items.CapHeight;
                                                /*ASA-1170, End*/
                                                ItemInfo["CapHorz"] = items.CapHorz; //ASA-1179
                                                ItemInfo["CapDepth"] = items.CapDepth; //ASA-1179
                                                ItemInfo["CapTotalCount"] = items.CapTotalCount; //ASA-1179
                                                ItemInfo["CapMaxH"] = items.CapMaxH;
                                                ItemInfo["MaxHCapStyle"] = items.MaxHCapStyle;
                                                ItemInfo["Rotation"] = items.Rotation;
                                                ItemInfo["BaseD"] = items.BaseD;
                                                ItemInfo["CrushHoriz"] = typeof items.CrushHoriz !== "undefined" ? items.CrushHoriz : "";
                                                ItemInfo["CrushVert"] = typeof items.CrushVert !== "undefined" ? items.CrushVert : "";
                                                ItemInfo["CrushD"] = typeof items.CrushD !== "undefined" ? items.CrushD : "";
                                                ItemInfo["Price"] = items.Price;
                                                ItemInfo["Cost"] = items.Cost;
                                                ItemInfo["RegMovement"] = items.RegMovement;
                                                ItemInfo["RegMovementInd"] = typeof items.RegMovementInd !== "undefined" ? items.RegMovementInd : "";
                                                ItemInfo["DaysOfSupplyInd"] = typeof items.DaysOfSupplyInd !== "undefined" ? items.DaysOfSupplyInd : "";
                                                ItemInfo["AvgSales"] = typeof items.AvgSales !== "undefined" ? Math.floor(items.AvgSales * 100) / 100 : "";
                                                ItemInfo["AvgSalesInd"] = typeof items.AvgSalesInd !== "undefined" ? items.AvgSalesInd : "";
                                                ItemInfo["ItemStatus"] = typeof items.ItemStatus !== "undefined" ? items.ItemStatus : "";
                                                ItemInfo["CDTLvl1"] = typeof items.CDTLvl1 !== "undefined" ? items.CDTLvl1 : ""; //ASA-1130
                                                ItemInfo["CDTLvl2"] = typeof items.CDTLvl2 !== "undefined" ? items.CDTLvl2 : ""; //ASA-1130
                                                ItemInfo["CDTLvl3"] = typeof items.CDTLvl3 !== "undefined" ? items.CDTLvl3 : ""; //ASA-1130
                                                ItemInfo["DPPLoc"] = items.DPPLoc; //ASA-1308 Task-3
                                                ItemInfo["ActualDPP"] = typeof items.ActualDPP !== "undefined" ? items.ActualDPP : ""; //ASA-1277-(3)
                                                ItemInfo["StoreSOH"] = typeof items.StoreSOH !== "undefined" ? items.StoreSOH : ""; //ASA-1277-(3)
                                                ItemInfo["StoreNo"] = typeof items.StoreNo !== "undefined" ? items.StoreNo : ""; //ASA-1277-(3)
                                                ItemInfo["WeeksOfInventory"] = typeof items.WeeksOfInventory !== "undefined" ? items.WeeksOfInventory : ""; //ASA-1277-(3)
                                                //ASA-2013 Start
                                                ItemInfo["ShelfPrice"] = typeof items.ShelfPrice !== "undefined" ? items.ShelfPrice : "";
                                                ItemInfo["PromoPrice"] = typeof items.PromoPrice !== "undefined" ? items.PromoPrice : "";
                                                ItemInfo["DiscountRate"] = typeof items.DiscountRate !== "undefined" ? items.DiscountRate : "";
                                                ItemInfo["PriceChangeDate"] = typeof items.PriceChangeDate !== "undefined" ? items.PriceChangeDate : "";
                                                ItemInfo["WeeksOfInventory"] = typeof items.WeeksOfInventory !== "undefined" ? items.WeeksOfInventory : "";
                                                ItemInfo["Qty"] = typeof items.Qty !== "undefined" ? items.Qty : "";
                                                ItemInfo["WhStock"] = typeof items.WhStock !== "undefined" ? items.WhStock : "";
                                                ItemInfo["StoreStock"] = typeof items.StoreStock !== "undefined" ? items.StoreStock : "";
                                                ItemInfo["StockIntransit"] = typeof items.StockIntransit !== "undefined" ? items.StockIntransit : "";
                                                //ASA-2013 End
                                                ItemInfo["MoveBasis"] = items.MoveBasis;
                                                ItemInfo["ItemNesting"] = items.ItemNesting;
                                                ItemInfo["NVal"] = items.NVal;
                                                ItemInfo["ItemContain"] = items.ItemContain;
                                                ItemInfo["CnVal"] = items.CnVal;
                                                ItemInfo["IsContainer"] = items.IsContainer;
                                                ItemInfo["BsktFactor"] = items.BsktFactor;
                                                ItemInfo["OverHang"] = items.OverHang;
                                                ItemInfo["VertGap"] = items.VertGap;
                                                ItemInfo["OW"] = items.OW;
                                                ItemInfo["OH"] = items.OH;
                                                ItemInfo["OD"] = items.OD;
                                                ItemInfo["Quantity"] = items.Quantity;
                                                ItemInfo["Dragged"] = items.Dragged;
                                                ItemInfo["SpreadItem"] = items.SpreadItem;
                                                ItemInfo["MHorizCrushed"] = items.MHorizCrushed;
                                                ItemInfo["MVertCrushed"] = items.MVertCrushed;
                                                ItemInfo["MDepthCrushed"] = items.MDepthCrushed;
                                                ItemInfo["MCapTopFacing"] = items.MCapTopFacing; //ASA-1170
                                                ItemInfo["RW"] = items.RW;
                                                ItemInfo["RH"] = items.RH;
                                                ItemInfo["RD"] = items.RD;
                                                ItemInfo["LObjID"] = items.LObjID;
                                                ItemInfo["SubLblObjID"] = items.SubLblObjID; //ASA-1182
                                                ItemInfo["DimUpdate"] = items.DimUpdate;
                                                ItemInfo["SlotDivider"] = items.SlotDivider;
                                                ItemInfo["CapCount"] = items.CapCount;
                                                ItemInfo["X"] = items.X;
                                                ItemInfo["Y"] = items.Y;
                                                ItemInfo["Z"] = items.Z;
                                                ItemInfo["BHoriz"] = items.BHoriz;
                                                ItemInfo["BVert"] = items.BVert;
                                                ItemInfo["W"] = items.W;
                                                ItemInfo["H"] = items.H;

                                                ItemInfo["ItemID"] = items.ItemID;
                                                ItemInfo["Item"] = items.Item;
                                                ItemInfo["D"] = items.D;
                                                if (typeof items.Color == "undefined" || items.Color == null) {
                                                    //--ASA-1310 prasanna ASA-1310_25890_new
                                                    ItemInfo["Color"] = p_ItemColor;
                                                } else {
                                                    ItemInfo["Color"] = items.Color;
                                                }
                                                ItemInfo["Desc"] = items.Desc;
                                                ItemInfo["Barcode"] = items.Barcode;
                                                ItemInfo["LocID"] = items.LocID;
                                                ItemInfo["Orientation"] = items.Orientation;
                                                ItemInfo["MerchStyle"] = items.MerchStyle;
                                                ItemInfo["Supplier"] = typeof items.Supplier == "undefined" || items.Supplier == null ? "" : items.Supplier.split("-")[1]; //ASA-1381 -- error found during testing. supplier was undefined and split gave error.
                                                ItemInfo["Brand"] = items.Brand;
                                                ItemInfo["BrandType"] = items.BrandType;
                                                ItemInfo["Group"] = items.Group;
                                                ItemInfo["Dept"] = items.Dept;
                                                ItemInfo["Class"] = items.Class;
                                                ItemInfo["SubClass"] = items.SubClass;
                                                ItemInfo["StdUOM"] = items.StdUOM;
                                                ItemInfo["SizeDesc"] = typeof items.SizeDesc == "undefined" || items.SizeDesc == null ? "" : items.SizeDesc; //Task_26793 QA error //ASA-1327 noticed error as for some item it is null so from db tag not done.
                                                ItemInfo["HorizGap"] = items.HorizGap;
                                                ItemInfo["UW"] = items.UW;
                                                ItemInfo["UH"] = items.UH;
                                                ItemInfo["UD"] = items.UD;
                                                ItemInfo["CW"] = items.CW;
                                                ItemInfo["CH"] = items.CH;
                                                ItemInfo["CD"] = items.CD;
                                                ItemInfo["TW"] = items.TW;
                                                ItemInfo["TH"] = items.TH;
                                                ItemInfo["TD"] = items.TD;
                                                ItemInfo["DW"] = items.DW;
                                                ItemInfo["DH"] = items.DH;
                                                ItemInfo["DD"] = items.DD;
                                                ItemInfo["CWPerc"] = items.CWPerc;
                                                ItemInfo["CHPerc"] = items.CHPerc;
                                                ItemInfo["CDPerc"] = items.CDPerc;
                                                ItemInfo["CnW"] = items.CnW;
                                                ItemInfo["CnH"] = items.CnH;
                                                ItemInfo["CnD"] = items.CnD;
                                                ItemInfo["NW"] = items.NW;
                                                ItemInfo["NH"] = items.NH;
                                                ItemInfo["ND"] = items.ND;
                                                ItemInfo["OldCnW"] = items.CnW;
                                                ItemInfo["OldCnH"] = items.CnH;
                                                ItemInfo["OldCnD"] = items.CnD;
                                                ItemInfo["OldNW"] = items.NW;
                                                ItemInfo["OldNH"] = items.NH;
                                                ItemInfo["OldND"] = items.ND;

                                                ItemInfo["OrgUW"] = items.OrgUW;
                                                ItemInfo["OrgUH"] = items.OrgUH;
                                                ItemInfo["OrgUD"] = items.OrgUD;
                                                ItemInfo["OrgCW"] = items.OrgCW;
                                                ItemInfo["OrgCH"] = items.OrgCH;
                                                ItemInfo["OrgCD"] = items.OrgCD;
                                                ItemInfo["OrgTW"] = items.OrgTW;
                                                ItemInfo["OrgTH"] = items.OrgTH;
                                                ItemInfo["OrgTD"] = items.OrgTD;
                                                ItemInfo["OrgDW"] = items.OrgDW;
                                                ItemInfo["OrgDH"] = items.OrgDH;
                                                ItemInfo["OrgDD"] = items.OrgDD;
                                                ItemInfo["OrgCWPerc"] = items.OrgCWPerc;
                                                ItemInfo["OrgCHPerc"] = items.OrgCHPerc;
                                                ItemInfo["OrgCDPerc"] = items.OrgCDPerc;
                                                ItemInfo["OrgCnW"] = items.OrgCnW;
                                                ItemInfo["OrgCnH"] = items.OrgCnH;
                                                ItemInfo["OrgCnD"] = items.OrgCnD;
                                                ItemInfo["OrgNW"] = items.OrgNW;
                                                ItemInfo["OrgNH"] = items.OrgNH;
                                                ItemInfo["OrgND"] = items.OrgND;
                                                ItemInfo["TopObjID"] = items.TopObjID;
                                                ItemInfo["BottomObjID"] = items.BottomObjID;
                                                ItemInfo["SecondTier"] = items.SecondTier;
                                                ItemInfo["CompItemObjID"] = items.CompItemObjID;
                                                ItemInfo["SellingPrice"] = parseFloat(nvl(items.SellingPrice)); //20240415 Regression issue 1 parseFloat and nvl
                                                if (items.SalesUnit !== "undefined") {
                                                    var salesunit = parseFloat(nvl(items.SalesUnit)); //20240415 Regression issue 1 parseFloat and nvl
                                                    ItemInfo["SalesUnit"] = Math.floor(salesunit * 100) / 100;
                                                } else {
                                                    ItemInfo["SalesUnit"] = "";
                                                }
                                                ItemInfo["NetSales"] = parseFloat(nvl(items.NetSales)); //20240415 Regression issue 1 parseFloat and nvl
                                                ItemInfo["CogsAdj"] = items.CogsAdj;
                                                ItemInfo["CogsAdjInd"] = typeof items.CogsAdjInd !== "undefined" ? items.CogsAdjInd : "";
                                                ItemInfo["GrossProfit"] = items.GrossProfit;
                                                ItemInfo["GrossProfitInd"] = typeof items.GrossProfitInd !== "undefined" ? items.GrossProfitInd : "";
                                                ItemInfo["MovingItem"] = items.MovingItem;
                                                ItemInfo["WeeksCount"] = items.WeeksCount;
                                                ItemInfo["WeeksCountInd"] = typeof items.WeeksCountInd !== "undefined" ? items.WeeksCountInd : "";
                                                ItemInfo["Profit"] = parseFloat(nvl(items.Profit)); //20240415 Regression issue 1 parseFloat and nvl
                                                ItemInfo["GoGreen"] = items.GoGreen;
                                                ItemInfo["TotalMargin"] = parseFloat(nvl(items.TotalMargin)); //20240415 Regression issue 1 parseFloat and nvl
                                                ItemInfo["MHorizFacings"] = typeof items.MHorizFacings == "undefined" ? -1 : items.MHorizFacings == null ? -1 : parseInt(items.MHorizFacings);
                                                ItemInfo["MVertFacings"] = typeof items.MVertFacings == "undefined" ? -1 : items.MVertFacings == null ? -1 : parseInt(items.MVertFacings);
                                                ItemInfo["MDepthFacings"] = typeof items.MDepthFacings == "undefined" ? -1 : items.MDepthFacings == null ? -1 : parseInt(items.MDepthFacings);
                                                ItemInfo["Status"] = items.Status;
                                                ItemInfo["OrientationDesc"] = items.OrientationDesc;
                                                ItemInfo["StoreCnt"] = items.StoreCnt;
                                                ItemInfo["NewYN"] = "";
                                                ItemInfo["Delist"] = items.Delist;
                                                ItemInfo["ImgExists"] = items.ImgExists;
                                                ItemInfo["Exists"] = "E";
                                                ItemInfo["OldObjID"] = items.ObjID;
                                                ItemInfo["DescSecond"] = items.DescSecond;
                                                ItemInfo["OverhungItem"] = typeof items.OverhungItem == "undefined" ? "N" : items.OverhungItem; //ASA-1138
                                                ItemInfo["CapDepthChanged"] = "N"; //ASA-1273
                                                ItemInfo["Brand"] = items.Brand; //ASA-1292 - Issue 5 Start
                                                ItemInfo["ItmDescChi"] = items.ItmDescChi; //ASA-1407 Task 1,//ASA-1407 issue 5
                                                var det_arr = items.SizeDesc.split("*");
                                                if (det_arr.length > 1) {
                                                    ItemInfo["ItmDescEng"] = items.Brand + " " + items.Desc + " " + parseInt(det_arr[0]) / parseInt(det_arr[1]) + "*" + det_arr[1] + "*" + det_arr[2];
                                                } else {
                                                    ItemInfo["ItmDescEng"] = items.Brand + " " + items.Desc;
                                                }
                                                ItemInfo["PkSiz"] = parseInt(det_arr[1]);
                                                ItemInfo["Brand_Category"] = typeof items.Brand_Category !== "undefined" ? items.Brand_Category : "";
                                                ItemInfo["ItemSize"] = typeof items.ItemSize !== "undefined" ? items.ItemSize : "";
                                                ItemInfo["Categ"] = typeof items.Categ !== "undefined" ? items.Categ : "";
                                                ItemInfo["Uda_item_status"] = typeof items.Uda_item_status !== "undefined" ? items.Uda_item_status : "";
                                                ItemInfo["Gobecobrand"] = typeof items.Gobecobrand !== "undefined" ? items.Gobecobrand : "";
                                                ItemInfo["InternationalRng"] = typeof items.InternationalRng !== "undefined" ? items.InternationalRng : "";
                                                ItemInfo["EDLP"] = typeof items.EDLP !== "undefined" ? items.EDLP : "";
                                                ItemInfo["LoGrp"] = typeof items.LoGrp !== "undefined" ? items.LoGrp : "";
                                                ItemInfo["COO"] = typeof items.COO !== "undefined" ? items.COO : ""; //ASA-1292 - Issue 5 End
                                                ItemInfo["UDA751"] = typeof items.UDA751 !== "undefined" ? items.UDA751 : ""; //ASA-1407 Task 1 -S
                                                ItemInfo["UDA755"] = typeof items.UDA755 !== "undefined" ? items.UDA755 : ""; //ASA-1407 Task 1 -E
                                                ItemInfo["MPogDepthFacings"] = typeof items.MPogDepthFacings !== "undefined" ? items.MPogDepthFacings : ""; //ASA-1408
                                                ItemInfo["MPogHorizFacings"] = typeof items.MPogHorizFacings !== "undefined" ? items.MPogHorizFacings : ""; //ASA-1408
                                                ItemInfo["MPogVertFacings"] = typeof items.MPogVertFacings !== "undefined" ? items.MPogVertFacings : ""; //ASA-1408
                                                //ASA-1640 Start
                                                ItemInfo["ItemCondition"] = nvl(items.ItemCondition) != 0 ? items.ItemCondition : "";
                                                ItemInfo["AUR"] = nvl(items.AUR) != 0 ? items.AUR : "";
                                                ItemInfo["ItemRanking"] = nvl(items.ItemRanking) != 0 ? items.ItemRanking : "";
                                                ItemInfo["WeeklySales"] = nvl(items.WeeklySales) != 0 ? items.WeeklySales : "";
                                                ItemInfo["WeeklyNetMargin"] = nvl(items.WeeklyNetMargin) != 0 ? items.WeeklyNetMargin : "";
                                                ItemInfo["WeeklyQty"] = nvl(items.WeeklyQty) != 0 ? items.WeeklyQty : "";
                                                ItemInfo["NetMarginPercent"] = typeof items.NetMarginPercent !== "undefined" ? items.NetMarginPercent : typeof items.NetMarginPerc !== "undefined" ? NetMarginPerc : ""; //ASA-1735  issue 4
                                                ItemInfo["CumulativeNM"] = nvl(items.CumulativeNM) != 0 ? items.CumulativeNM : "";
                                                ItemInfo["TOP80B2"] = nvl(items.TOP80B2) != 0 ? items.TOP80B2 : "";
                                                ItemInfo["ItemBrandC"] = nvl(items.ItemBrandC) != 0 ? items.ItemBrandC : "";
                                                ItemInfo["ItemPOGDept"] = nvl(items.ItemPOGDept) != 0 ? items.ItemPOGDept : "";
                                                ItemInfo["ItemRemark"] = nvl(items.ItemRemark) != 0 ? items.ItemRemark : "";
                                                ItemInfo["RTVStatus"] = nvl(items.RTVStatus) != 0 ? items.RTVStatus : "";
                                                ItemInfo["Pusher"] = nvl(items.Pusher) != 0 ? items.Pusher : "";
                                                ItemInfo["Divider"] = nvl(items.Divider) != 0 ? items.Divider : "";
                                                ItemInfo["BackSupport"] = nvl(items.BackSupport) != 0 ? items.BackSupport : "";
                                                ItemInfo["OOSPerc"] = nvl(items.OOSPerc); //ASA-1750 Issue 2 //nvl(items.OOSPerc) != 0 ? items.OOSPerc : ""; //ASA-1688 Added for OOS%
                                                ItemInfo["InitialItemDesc"] = typeof items.InitialItemDesc !== "undefined" ? items.InitialItemDesc : ""; //ASA-1734 Issue 1
                                                ItemInfo["InitialBrand"] = typeof items.InitialBrand !== "undefined" ? items.InitialBrand : ""; //ASA-1787 Request #6
                                                ItemInfo["InitialBarcode"] = typeof items.InitialBarcode !== "undefined" ? items.InitialBarcode : ""; //ASA-1787 Request #6
                                                //ASA-1640 End
                                                ItemInfo["Distance"] = wpdSetFixed(nvl(items.Distance)); //ASA-1738
                                            } else {
                                                if (p_new_pog_ind == "N" && p_pog_type == "F") {
                                                    ItemInfo["DimT"] = items.MerchStyle;
                                                    ItemInfo["PegID"] = "";
                                                    ItemInfo["PegSpread"] = "";
                                                    ItemInfo["PegPerFacing"] = "";
                                                    ItemInfo["Fixed"] = "N";
                                                    ItemInfo["CapStyle"] = "0";
                                                    /*ASA-1170, Start*/
                                                    ItemInfo["CapFacing"] = "";
                                                    ItemInfo["CapMerch"] = "";
                                                    ItemInfo["CapOrientaion"] = "";
                                                    ItemInfo["CapHeight"] = "";
                                                    /*ASA-1170, End*/
                                                    ItemInfo["CapHorz"] = ""; //ASA-1179
                                                    ItemInfo["CapDepth"] = ""; //ASA-1179
                                                    ItemInfo["CapTotalCount"] = ""; //ASA-1179
                                                    ItemInfo["CapMaxH"] = 0;
                                                    ItemInfo["MaxHCapStyle"] = "3";
                                                    ItemInfo["Rotation"] = 0;
                                                    ItemInfo["CrushHoriz"] = 0;
                                                    ItemInfo["CrushVert"] = 0;
                                                    ItemInfo["CrushD"] = 0;
                                                    ItemInfo["Price"] = "";
                                                    ItemInfo["Cost"] = "";
                                                    ItemInfo["RegMovement"] = "";
                                                    ItemInfo["RegMovementInd"] = typeof items.RegMovementInd !== "undefined" ? items.RegMovementInd : "";
                                                    ItemInfo["DaysOfSupplyInd"] = typeof items.DaysOfSupplyInd !== "undefined" ? items.DaysOfSupplyInd : "";
                                                    ItemInfo["AvgSales"] = typeof items.AvgSales !== "undefined" ? Math.floor(items.AvgSales * 100) / 100 : "";
                                                    ItemInfo["ItemStatus"] = typeof items.ItemStatus !== "undefined" ? items.ItemStatus : "";
                                                    ItemInfo["CDTLvl1"] = ""; //ASA-1130
                                                    ItemInfo["CDTLvl2"] = ""; //ASA-1130
                                                    ItemInfo["CDTLvl3"] = ""; //ASA-1130
                                                    ItemInfo["ActualDPP"] = ""; //ASA-1277-(3)
                                                    ItemInfo["DPPLoc"] = ""; //ASA-1308 Task-3
                                                    ItemInfo["StoreSOH"] = ""; //ASA-1277-(3)
                                                    ItemInfo["StoreNo"] = ""; //ASA-1277-(3)
                                                    ItemInfo["WeeksOfInventory"] = ""; //ASA-1277-(3)
                                                    //ASA-2013 Start
                                                    ItemInfo["ShelfPrice"] = "";
                                                    ItemInfo["PromoPrice"] = "";
                                                    ItemInfo["DiscountRate"] = "";
                                                    ItemInfo["PriceChangeDate"] = "";
                                                    ItemInfo["WeeksOfInventory"] = "";
                                                    ItemInfo["Qty"] = "";
                                                    ItemInfo["WhStock"] = "";
                                                    ItemInfo["StoreStock"] = "";
                                                    ItemInfo["StockIntransit"] = "";
                                                    //ASA-2013 End
                                                    ItemInfo["MoveBasis"] = "";
                                                    ItemInfo["IsContainer"] = "N";
                                                    ItemInfo["BsktFactor"] = 0;
                                                    ItemInfo["OverHang"] = 0;
                                                    ItemInfo["VertGap"] = 0;
                                                    ItemInfo["BHoriz"] = items.BHoriz == null ? 1 : items.BHoriz;
                                                    ItemInfo["BVert"] = items.BVert == null ? 1 : items.BVert;
                                                    ItemInfo["BaseD"] = items.BaseD == null ? 1 : items.BaseD;

                                                    //getting dimension according to orientation.
                                                    //var [item_width, item_height, item_depth, actualHeight, actualWidth, actualDepth] = get_new_orientation_dim(items.Orientation, items.W, items.H, items.D);
                                                    ItemInfo["W"] = items.W;
                                                    ItemInfo["H"] = items.H;
                                                    ItemInfo["D"] = items.D;
                                                    if (ShelfInfo["ObjType"] == "BASKET") {
                                                        ItemInfo["W"] = ShelfInfo["W"];
                                                        ItemInfo["H"] = items.D * items.Quantity;
                                                        ItemInfo["D"] = items.D * ItemInfo["BaseD"];
                                                        ItemInfo["RW"] = items.W;
                                                        ItemInfo["RH"] = items.H;
                                                        ItemInfo["RD"] = items.D;
                                                    } else {
                                                        ItemInfo["W"] = ItemInfo["W"] * ItemInfo["BHoriz"];
                                                        ItemInfo["H"] = ItemInfo["H"] * ItemInfo["BVert"];
                                                        ItemInfo["D"] = ItemInfo["D"] * ItemInfo["BaseD"];
                                                        ItemInfo["RW"] = ItemInfo["W"];
                                                        ItemInfo["RH"] = ItemInfo["H"];
                                                        ItemInfo["RD"] = ItemInfo["D"];
                                                    }

                                                    ItemInfo["OW"] = items.W;
                                                    ItemInfo["OH"] = items.H;
                                                    ItemInfo["OD"] = items.D;
                                                    ItemInfo["LObjID"] = items.LObjID;
                                                    ItemInfo["SubLblObjID"] = items.SubLblObjID; //ASA-1182
                                                    ItemInfo["Dragged"] = "N";
                                                    ItemInfo["SpreadItem"] = 0;
                                                    ItemInfo["MHorizCrushed"] = "N";
                                                    ItemInfo["MVertCrushed"] = "N";
                                                    ItemInfo["MDepthCrushed"] = "N";
                                                    ItemInfo["MCapTopFacing"] = "N"; //ASA-1170
                                                    ItemInfo["X"] = items.X;
                                                    ItemInfo["Y"] = ShelfInfo["Y"] + ShelfInfo["H"] / 2 + ItemInfo["H"] / 2;
                                                    //ItemInfo["Y"] = items.Y;
                                                    ItemInfo["Z"] = items.Z;
                                                    ItemInfo["SlotDivider"] = "N";
                                                    ItemInfo["CapCount"] = 0;
                                                    ItemInfo["Distance"] = ItemInfo["X"] - ItemInfo["W"] / 2 - shelf_start;
                                                    if (ShelfInfo["ObjType"] == "PEGBOARD") {
                                                        ItemInfo["PegBoardX"] = ItemInfo["X"] - ItemInfo["W"] / 2 - shelf_start;
                                                        ItemInfo["PegBoardY"] = ItemInfo["Y"] - ItemInfo["H"] / 2 - (ShelfInfo["Y"] - ShelfInfo["H"] / 2);
                                                    }
                                                } else {
                                                    ItemInfo["DimT"] = items.DimT;
                                                    ItemInfo["PegID"] = items.PegID;
                                                    ItemInfo["PegSpread"] = items.PegSpread;
                                                    ItemInfo["PegPerFacing"] = items.PegPerFacing;
                                                    ItemInfo["Fixed"] = items.Fixed;
                                                    ItemInfo["CapStyle"] = items.CapStyle;
                                                    /*ASA-1170, Start*/
                                                    ItemInfo["CapFacing"] = items.CapFacing;
                                                    ItemInfo["CapMerch"] = items.CapMerch;
                                                    ItemInfo["CapOrientaion"] = items.CapOrientaion;
                                                    ItemInfo["CapHeight"] = items.CapHeight;
                                                    /*ASA-1170, End*/
                                                    ItemInfo["CapHorz"] = items.CapHorz; //ASA-1179
                                                    ItemInfo["CapDepth"] = items.CapDepth; //ASA-1179
                                                    ItemInfo["CapTotalCount"] = items.CapTotalCount; //ASA-1179
                                                    ItemInfo["CapMaxH"] = typeof items.CapMaxH !== "undefined" ? items.CapMaxH : 0;
                                                    ItemInfo["MaxHCapStyle"] = typeof items.MaxHCapStyle !== "undefined" ? items.MaxHCapStyle : "3";
                                                    ItemInfo["Rotation"] = items.Rotation;
                                                    ItemInfo["CrushHoriz"] = items.CrushHoriz;
                                                    ItemInfo["CrushVert"] = items.CrushVert;
                                                    ItemInfo["CrushD"] = items.CrushD;
                                                    ItemInfo["Price"] = items.Price;
                                                    ItemInfo["Cost"] = items.Cost;
                                                    ItemInfo["RegMovement"] = items.RegMovement;
                                                    ItemInfo["RegMovementInd"] = typeof items.RegMovementInd !== "undefined" ? items.RegMovementInd : "";
                                                    ItemInfo["DaysOfSupplyInd"] = typeof items.DaysOfSupplyInd !== "undefined" ? items.DaysOfSupplyInd : "";
                                                    ItemInfo["AvgSales"] = typeof items.AvgSales !== "undefined" ? Math.floor(items.AvgSales * 100) / 100 : "";
                                                    ItemInfo["ItemStatus"] = typeof items.ItemStatus !== "undefined" ? items.ItemStatus : "";
                                                    ItemInfo["CDTLvl1"] = typeof items.CDTLvl1 !== "undefined" ? items.CDTLvl1 : ""; //ASA-1130
                                                    ItemInfo["CDTLvl2"] = typeof items.CDTLvl2 !== "undefined" ? items.CDTLvl2 : ""; //ASA-1130
                                                    ItemInfo["CDTLvl3"] = typeof items.CDTLvl3 !== "undefined" ? items.CDTLvl3 : ""; //ASA-1130
                                                    ItemInfo["ActualDPP"] = typeof items.ActualDPP !== "undefined" ? items.ActualDPP : ""; //ASA-1277-(3)
                                                    ItemInfo["DPPLoc"] = items.DPPLoc; //ASA-1308 Task-3
                                                    ItemInfo["StoreSOH"] = typeof items.StoreSOH !== "undefined" ? items.StoreSOH : ""; //ASA-1277-(3)
                                                    ItemInfo["StoreNo"] = typeof items.StoreNo !== "undefined" ? items.StoreNo : ""; //ASA-1277-(3)
                                                    ItemInfo["WeeksOfInventory"] = typeof items.WeeksOfInventory !== "undefined" ? items.WeeksOfInventory : ""; //ASA-1277-(3)
                                                    //ASA-2013 Start
                                                    ItemInfo["ShelfPrice"] = typeof items.ShelfPrice !== "undefined" ? items.ShelfPrice : "";
                                                    ItemInfo["PromoPrice"] = typeof items.PromoPrice !== "undefined" ? items.PromoPrice : "";
                                                    ItemInfo["DiscountRate"] = typeof items.DiscountRate !== "undefined" ? items.DiscountRate : "";
                                                    ItemInfo["PriceChangeDate"] = typeof items.PriceChangeDate !== "undefined" ? items.PriceChangeDate : "";
                                                    ItemInfo["WeeksOfInventory"] = typeof items.WeeksOfInventory !== "undefined" ? items.WeeksOfInventory : "";
                                                    ItemInfo["Qty"] = typeof items.Qty !== "undefined" ? items.Qty : "";
                                                    ItemInfo["WhStock"] = typeof items.WhStock !== "undefined" ? items.WhStock : "";
                                                    ItemInfo["StoreStock"] = typeof items.StoreStock !== "undefined" ? items.StoreStock : "";
                                                    ItemInfo["StockIntransit"] = typeof items.StockIntransit !== "undefined" ? items.StockIntransit : "";
                                                    //ASA-2013 End
                                                    ItemInfo["MoveBasis"] = items.MoveBasis;
                                                    ItemInfo["IsContainer"] = items.IsContainer;
                                                    ItemInfo["BsktFactor"] = items.BsktFactor;
                                                    ItemInfo["OverHang"] = items.OverHang;
                                                    ItemInfo["VertGap"] = items.VertGap;
                                                    ItemInfo["OW"] = items.OW;
                                                    ItemInfo["OH"] = items.OH;
                                                    ItemInfo["OD"] = items.OD;
                                                    ItemInfo["Dragged"] = items.Dragged;
                                                    ItemInfo["SpreadItem"] = items.SpreadItem;
                                                    ItemInfo["MHorizCrushed"] = items.MHorizCrushed;
                                                    ItemInfo["MVertCrushed"] = items.MVertCrushed;
                                                    ItemInfo["MDepthCrushed"] = items.MDepthCrushed;
                                                    ItemInfo["MCapTopFacing"] = items.MCapTopFacing; //ASA-1170
                                                    ItemInfo["RW"] = items.RW;
                                                    ItemInfo["RH"] = items.RH;
                                                    ItemInfo["RD"] = items.RD;
                                                    ItemInfo["LObjID"] = items.LObjID;
                                                    ItemInfo["SubLblObjID"] = items.SubLblObjID; //ASA-1182
                                                    ItemInfo["SlotDivider"] = items.SlotDivider;
                                                    ItemInfo["CapCount"] = items.CapCount;
                                                    ItemInfo["X"] = items.X;
                                                    ItemInfo["Y"] = items.Y;
                                                    if (ShelfInfo["ObjType"] == "HANGINGBAR") {
                                                        ItemInfo["Y"] = ShelfInfo["Y"] - items.H / 2;
                                                    } else {
                                                        ItemInfo["Y"] = items.Y;
                                                    }
                                                    ItemInfo["BHoriz"] = items.BHoriz;
                                                    ItemInfo["BVert"] = items.BVert;
                                                    ItemInfo["BaseD"] = items.BaseD;
                                                    ItemInfo["W"] = items.W;
                                                    ItemInfo["H"] = items.H;
                                                    ItemInfo["D"] = items.D;
                                                    ItemInfo["Distance"] = items.Distance;
                                                    ItemInfo["PegBoardX"] = items.PegBoardX;
                                                    ItemInfo["PegBoardY"] = items.PegBoardY;
                                                }
                                                ItemInfo["Z"] = items.Z == 0 ? items.Z + items.D / 2 : items.Z;
                                                ItemInfo["Quantity"] = items.Quantity;
                                                ItemInfo["ItemID"] = items.ItemID;
                                                ItemInfo["Item"] = items.Item;
                                                if (typeof items.Color == "undefined" || items.Color == null) {
                                                    //--ASA-1310 prasanna ASA-1310_25890_new
                                                    ItemInfo["Color"] = p_ItemColor;
                                                } else {
                                                    ItemInfo["Color"] = items.Color;
                                                }
                                                ItemInfo["Desc"] = items.Desc;
                                                ItemInfo["Barcode"] = items.Barcode;
                                                ItemInfo["LocID"] = items.LocID;
                                                ItemInfo["Orientation"] = items.Orientation;
                                                ItemInfo["MerchStyle"] = items.MerchStyle == null || typeof items.MerchStyle == "undefined" || items.MerchStyle == "" ? "0" : items.MerchStyle;
                                                ItemInfo["Supplier"] = items.Supplier;
                                                ItemInfo["Brand"] = items.Brand;
                                                ItemInfo["BrandType"] = items.BrandType;
                                                ItemInfo["Group"] = items.Group;
                                                ItemInfo["Dept"] = items.Dept;
                                                ItemInfo["Class"] = items.Class;
                                                ItemInfo["SubClass"] = items.SubClass;
                                                ItemInfo["StdUOM"] = items.StdUOM;
                                                ItemInfo["SizeDesc"] = typeof items.SizeDesc == "undefined" || items.SizeDesc == null ? "" : items.SizeDesc; //Task_26793 QA error //ASA-1327 noticed error as for some item it is null so from db tag not done.
                                                ItemInfo["HorizGap"] = items.HorizGap;
                                                ItemInfo["UW"] = items.UW;
                                                ItemInfo["UH"] = items.UH;
                                                ItemInfo["UD"] = items.UD;
                                                ItemInfo["CW"] = items.CW;
                                                ItemInfo["CH"] = items.CH;
                                                ItemInfo["CD"] = items.CD;
                                                ItemInfo["TW"] = items.TW;
                                                ItemInfo["TH"] = items.TH;
                                                ItemInfo["TD"] = items.TD;
                                                ItemInfo["DW"] = items.DW;
                                                ItemInfo["DH"] = items.DH;
                                                ItemInfo["DD"] = items.DD;
                                                ItemInfo["CWPerc"] = items.CWPerc;
                                                ItemInfo["CHPerc"] = items.CHPerc;
                                                ItemInfo["CDPerc"] = items.CDPerc;
                                                ItemInfo["TopObjID"] = items.TopObjID;
                                                ItemInfo["BottomObjID"] = items.BottomObjID;
                                                ItemInfo["SecondTier"] = items.SecondTier;
                                                ItemInfo["CompItemObjID"] = items.CompItemObjID;
                                                ItemInfo["SellingPrice"] = parseFloat(nvl(items.SellingPrice)); //20240415 Regression issue 1 parseFloat and nvl
                                                if (items.SalesUnit !== "undefined") {
                                                    var salesunit = parseFloat(nvl(items.SalesUnit)); //20240415 Regression issue 1 parseFloat and nvl
                                                    ItemInfo["SalesUnit"] = Math.floor(salesunit * 100) / 100;
                                                } else {
                                                    ItemInfo["SalesUnit"] = "";
                                                }
                                                ItemInfo["NetSales"] = parseFloat(nvl(items.NetSales)); //20240415 Regression issue 1 parseFloat and nvl
                                                ItemInfo["CogsAdj"] = items.CogsAdj;
                                                ItemInfo["CogsAdjInd"] = typeof items.CogsAdjInd !== "undefined" ? items.CogsAdjInd : "";
                                                ItemInfo["GrossProfit"] = items.GrossProfit;
                                                ItemInfo["GrossProfitInd"] = typeof items.GrossProfitInd !== "undefined" ? items.GrossProfitInd : "";
                                                ItemInfo["WeeksCount"] = items.WeeksCount;
                                                ItemInfo["WeeksCountInd"] = typeof items.WeeksCountInd !== "undefined" ? items.WeeksCountInd : "";
                                                ItemInfo["MovingItem"] = items.MovingItem;
                                                ItemInfo["RegMovement"] = items.RegMovement;
                                                ItemInfo["RegMovementInd"] = typeof items.RegMovementInd !== "undefined" ? items.RegMovementInd : "";
                                                ItemInfo["DaysOfSupplyInd"] = typeof items.DaysOfSupplyInd !== "undefined" ? items.DaysOfSupplyInd : "";
                                                ItemInfo["AvgSales"] = typeof items.AvgSales !== "undefined" ? Math.floor(items.AvgSales * 100) / 100 : "";
                                                ItemInfo["AvgSalesInd"] = typeof items.AvgSalesInd !== "undefined" ? items.AvgSalesInd : "";
                                                ItemInfo["ItemStatus"] = typeof items.ItemStatus !== "undefined" ? items.ItemStatus : "";
                                                ItemInfo["CDTLvl1"] = typeof items.CDTLvl1 !== "undefined" ? items.CDTLvl1 : ""; //ASA-1130
                                                ItemInfo["CDTLvl2"] = typeof items.CDTLvl2 !== "undefined" ? items.CDTLvl2 : ""; //ASA-1130
                                                ItemInfo["CDTLvl3"] = typeof items.CDTLvl3 !== "undefined" ? items.CDTLvl3 : ""; //ASA-1130
                                                ItemInfo["ActualDPP"] = typeof items.ActualDPP !== "undefined" ? items.ActualDPP : ""; //ASA-1277-(3)
                                                ItemInfo["DPPLoc"] = items.DPPLoc; //ASA-1308 Task-3
                                                ItemInfo["StoreSOH"] = typeof items.StoreSOH !== "undefined" ? items.StoreSOH : ""; //ASA-1277-(3)
                                                ItemInfo["StoreNo"] = typeof items.StoreNo !== "undefined" ? items.StoreNo : ""; //ASA-1277-(3)
                                                ItemInfo["WeeksOfInventory"] = typeof items.WeeksOfInventory !== "undefined" ? items.WeeksOfInventory : ""; //ASA-1277-(3)
                                                //ASA-2013 Start
                                                ItemInfo["ShelfPrice"] = typeof items.ShelfPrice !== "undefined" ? items.ShelfPrice : "";
                                                ItemInfo["PromoPrice"] = typeof items.PromoPrice !== "undefined" ? items.PromoPrice : "";
                                                ItemInfo["DiscountRate"] = typeof items.DiscountRate !== "undefined" ? items.DiscountRate : "";
                                                ItemInfo["PriceChangeDate"] = typeof items.PriceChangeDate !== "undefined" ? items.PriceChangeDate : "";
                                                ItemInfo["WeeksOfInventory"] = typeof items.WeeksOfInventory !== "undefined" ? items.WeeksOfInventory : "";
                                                ItemInfo["Qty"] = typeof items.Qty !== "undefined" ? items.Qty : "";
                                                ItemInfo["WhStock"] = typeof items.WhStock !== "undefined" ? items.WhStock : "";
                                                ItemInfo["StoreStock"] = typeof items.StoreStock !== "undefined" ? items.StoreStock : "";
                                                ItemInfo["StockIntransit"] = typeof items.StockIntransit !== "undefined" ? items.StockIntransit : "";
                                                //ASA-2013 End
                                                ItemInfo["Profit"] = parseFloat(nvl(items.Profit)); //20240415 Regression issue 1 parseFloat and nvl
                                                ItemInfo["TotalMargin"] = parseFloat(nvl(items.TotalMargin)); //20240415 Regression issue 1 parseFloat and nvl
                                                ItemInfo["MHorizFacings"] = parseInt(items.MHorizFacings);
                                                ItemInfo["MVertFacings"] = parseInt(items.MVertFacings);
                                                ItemInfo["MDepthFacings"] = parseInt(items.MDepthFacings);
                                                ItemInfo["Status"] = items.Status;
                                                ItemInfo["Cost"] = items.Cost;
                                                ItemInfo["Price"] = items.Price;
                                                ItemInfo["DaysOfSupply"] = items.DaysOfSupply;
                                                ItemInfo["ShowColorBackup"] = items.ShowColorBackup;
                                                ItemInfo["OrientationDesc"] = items.OrientationDesc;
                                                ItemInfo["StoreCnt"] = items.StoreCnt;
                                                ItemInfo["NewYN"] = "";
                                                ItemInfo["DescSecond"] = items.DescSecond;
                                                ItemInfo["Delist"] = typeof items.Delist == "undefined" ? "N" : items.Delist;
                                                ItemInfo["OverhungItem"] = typeof items.OverhungItem == "undefined" ? "N" : items.OverhungItem; //ASA-1138

                                                if (ItemInfo["Delist"] == "Y") {
                                                    ItemInfo["Color"] = p_ItemDelistColor;
                                                }

                                                if (typeof items.CnW == "undefined") {
                                                    ItemInfo["CnW"] = 0;
                                                } else {
                                                    ItemInfo["CnW"] = items.CnW;
                                                }
                                                if (typeof items.CnH == "undefined") {
                                                    ItemInfo["CnH"] = 0;
                                                } else {
                                                    ItemInfo["CnH"] = items.CnH;
                                                }
                                                if (typeof items.CnD == "undefined") {
                                                    ItemInfo["CnD"] = 0;
                                                } else {
                                                    ItemInfo["CnD"] = items.CnD;
                                                }
                                                if (typeof items.NW == "undefined") {
                                                    ItemInfo["NW"] = 0;
                                                } else {
                                                    ItemInfo["NW"] = items.NW;
                                                }
                                                if (typeof items.NH == "undefined") {
                                                    ItemInfo["NH"] = 0;
                                                } else {
                                                    ItemInfo["NH"] = items.NH;
                                                }
                                                if (typeof items.ND == "undefined") {
                                                    ItemInfo["ND"] = 0;
                                                } else {
                                                    ItemInfo["ND"] = items.ND;
                                                }
                                                ItemInfo["ItemNesting"] = items.ItemNesting;
                                                ItemInfo["NVal"] = ItemInfo["ItemNesting"] == "H" ? items.NH : ItemInfo["ItemNesting"] == "W" ? items.NW : ItemInfo["ItemNesting"] == "D" ? items.ND : 0;

                                                ItemInfo["ItemContain"] = items.ItemContain;
                                                ItemInfo["CnVal"] = ItemInfo["ItemContain"] == "H" ? items.CnH : ItemInfo["ItemContain"] == "W" ? items.CnW : ItemInfo["ItemContain"] == "D" ? items.CnD : 0;

                                                ItemInfo["OldCnW"] = ItemInfo["CnW"];
                                                ItemInfo["OldCnH"] = ItemInfo["CnH"];
                                                ItemInfo["OldCnD"] = ItemInfo["CnD"];
                                                ItemInfo["OldNW"] = ItemInfo["NW"];
                                                ItemInfo["OldNH"] = ItemInfo["NH"];
                                                ItemInfo["OldND"] = ItemInfo["ND"];

                                                ItemInfo["OrgUW"] = items.OrgUW;
                                                ItemInfo["OrgUH"] = items.OrgUH;
                                                ItemInfo["OrgUD"] = items.OrgUD;
                                                ItemInfo["OrgCW"] = items.OrgCW;
                                                ItemInfo["OrgCH"] = items.OrgCH;
                                                ItemInfo["OrgCD"] = items.OrgCD;
                                                ItemInfo["OrgTW"] = items.OrgTW;
                                                ItemInfo["OrgTH"] = items.OrgTH;
                                                ItemInfo["OrgTD"] = items.OrgTD;
                                                ItemInfo["OrgDW"] = items.OrgDW;
                                                ItemInfo["OrgDH"] = items.OrgDH;
                                                ItemInfo["OrgDD"] = items.OrgDD;
                                                ItemInfo["OrgCWPerc"] = items.OrgCWPerc;
                                                ItemInfo["OrgCHPerc"] = items.OrgCHPerc;
                                                ItemInfo["OrgCDPerc"] = items.OrgCDPerc;
                                                ItemInfo["OrgCnW"] = items.OrgCnW;
                                                ItemInfo["OrgCnH"] = items.OrgCnH;
                                                ItemInfo["OrgCnD"] = items.OrgCnD;
                                                ItemInfo["OrgNW"] = items.OrgNW;
                                                ItemInfo["OrgNH"] = items.OrgNH;
                                                ItemInfo["OrgND"] = items.OrgND;

                                                ItemInfo["ImgExists"] = items.ImgExists;
                                                ItemInfo["Exists"] = "E";
                                                ItemInfo["DimUpdate"] = "N";
                                                ItemInfo["ItemImage"] = items.ItemImage;
                                                ItemInfo["Edited"] = "Y";
                                                ItemInfo["OldObjID"] = items.ObjID;
                                                ItemInfo["Brand"] = items.Brand; //ASA-1292 - Issue 5 Start
                                                ItemInfo["ItmDescChi"] = items.ItmDescChi; //ASA-1407 Task 1,//ASA-1407 issue 5
                                                var det_arr = items.SizeDesc.split("*");
                                                if (det_arr.length > 1) {
                                                    ItemInfo["ItmDescEng"] = items.Brand + " " + items.Desc + " " + parseInt(det_arr[0]) / parseInt(det_arr[1]) + "*" + det_arr[1] + "*" + det_arr[2];
                                                } else {
                                                    ItemInfo["ItmDescEng"] = items.Brand + " " + items.Desc;
                                                }
                                                ItemInfo["PkSiz"] = parseInt(det_arr[1]);
                                                ItemInfo["Brand_Category"] = typeof items.Brand_Category !== "undefined" ? items.Brand_Category : "";
                                                ItemInfo["ItemSize"] = typeof items.ItemSize !== "undefined" ? items.ItemSize : "";
                                                ItemInfo["Categ"] = typeof items.Categ !== "undefined" ? items.Categ : "";
                                                ItemInfo["Uda_item_status"] = typeof items.Uda_item_status !== "undefined" ? items.Uda_item_status : "";
                                                ItemInfo["Gobecobrand"] = typeof items.Gobecobrand !== "undefined" ? items.Gobecobrand : "";
                                                ItemInfo["InternationalRng"] = typeof items.InternationalRng !== "undefined" ? items.InternationalRng : "";
                                                ItemInfo["EDLP"] = typeof items.EDLP !== "undefined" ? items.EDLP : "";
                                                ItemInfo["LoGrp"] = typeof items.LoGrp !== "undefined" ? items.LoGrp : "";
                                                ItemInfo["COO"] = typeof items.COO !== "undefined" ? items.COO : ""; //ASA-1292 - Issue 5 End
                                                ItemInfo["UDA751"] = typeof items.UDA751 !== "undefined" ? items.UDA751 : ""; //ASA-1407 Task 1 -S
                                                ItemInfo["UDA755"] = typeof items.UDA755 !== "undefined" ? items.UDA755 : ""; //ASA-1407 Task 1 -E
                                                ItemInfo["MPogDepthFacings"] = typeof items.MPogDepthFacings !== "undefined" ? items.MPogDepthFacings : ""; //ASA-1408
                                                ItemInfo["MPogHorizFacings"] = typeof items.MPogHorizFacings !== "undefined" ? items.MPogHorizFacings : ""; //ASA-1408
                                                ItemInfo["MPogVertFacings"] = typeof items.MPogVertFacings !== "undefined" ? items.MPogVertFacings : ""; //ASA-1408
                                                ItemInfo["Internet"] = typeof items.Internet !== "undefined" ? items.Internet : ""; //ASA-1407 issue 9
                                                ItemInfo["SplrLbl"] = typeof items.SplrLbl !== "undefined" ? items.SplrLbl : ""; //ASA-1407 issue 9
                                                //ASA-1640 Start
                                                ItemInfo["ItemCondition"] = nvl(items.ItemCondition) != 0 ? items.ItemCondition : "";
                                                ItemInfo["AUR"] = nvl(items.AUR) != 0 ? items.AUR : "";
                                                ItemInfo["ItemRanking"] = nvl(items.ItemRanking) != 0 ? items.ItemRanking : "";
                                                ItemInfo["WeeklySales"] = nvl(items.WeeklySales) != 0 ? items.WeeklySales : "";
                                                ItemInfo["WeeklyNetMargin"] = nvl(items.WeeklyNetMargin) != 0 ? items.WeeklyNetMargin : "";
                                                ItemInfo["WeeklyQty"] = nvl(items.WeeklyQty) != 0 ? items.WeeklyQty : "";
                                                ItemInfo["NetMarginPercent"] = typeof items.NetMarginPercent !== "undefined" ? items.NetMarginPercent : typeof items.NetMarginPerc !== "undefined" ? items.NetMarginPerc : ""; //ASA-1735  issue 4
                                                ItemInfo["CumulativeNM"] = nvl(items.CumulativeNM) != 0 ? items.CumulativeNM : "";
                                                ItemInfo["TOP80B2"] = nvl(items.TOP80B2) != 0 ? items.TOP80B2 : "";
                                                ItemInfo["ItemBrandC"] = nvl(items.ItemBrandC) != 0 ? items.ItemBrandC : "";
                                                ItemInfo["ItemPOGDept"] = nvl(items.ItemPOGDept) != 0 ? items.ItemPOGDept : "";
                                                ItemInfo["ItemRemark"] = nvl(items.ItemRemark) != 0 ? items.ItemRemark : "";
                                                ItemInfo["RTVStatus"] = nvl(items.RTVStatus) != 0 ? items.RTVStatus : "";
                                                ItemInfo["Pusher"] = nvl(items.Pusher) != 0 ? items.Pusher : "";
                                                ItemInfo["Divider"] = nvl(items.Divider) != 0 ? items.Divider : "";
                                                ItemInfo["BackSupport"] = nvl(items.BackSupport) != 0 ? items.BackSupport : "";
                                                //ASA-1640 End
                                                ItemInfo["OOSPerc"] = nvl(items.OOSPerc); //ASA-1750 Issue 2 //nvl(items.OOSPerc) != 0 ? items.OOSPerc : ""; //ASA-1688 Added for OOS%
                                                ItemInfo["InitialItemDesc"] = typeof items.InitialItemDesc !== "undefined" ? items.InitialItemDesc : ""; //ASA-1734 Issue 1
                                                ItemInfo["InitialBrand"] = typeof items.InitialBrand !== "undefined" ? items.InitialBrand : ""; //ASA-1787 Request #6
                                                ItemInfo["InitialBarcode"] = typeof items.InitialBarcode !== "undefined" ? items.InitialBarcode : ""; //ASA-1787 Request #6
                                            }
                                            if (p_carpark_ind !== "Y") {
                                                g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[shelf_ind].ItemInfo.push(ItemInfo);
                                            } else {
                                                g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark[shelf_ind].ItemInfo.push(ItemInfo);
                                            }
                                        } else {
                                            ItemInfo = items;
                                        }
                                        var is_divider = "N";
                                        if (ItemInfo["Item"] == "DIVIDER") {
                                            is_divider = "Y";
                                        }
                                        if (p_recreate == "Y") {
                                            if (p_carpark_ind == "Y") {
                                                var objID = await add_carpark_item(ItemInfo["ItemID"], ItemInfo["W"], ItemInfo["H"], ItemInfo["D"], ItemInfo["Color"], ItemInfo["X"], ItemInfo["Y"], ItemInfo["Z"], p_mod_index, shelf_ind, j, "Y", "N", g_show_live_image, "", p_pog_index);
                                            } else {
                                                if (g_show_live_image == "Y" && items.MerchStyle != 3) {
                                                    var details = g_orientation_json[items.Orientation];
                                                    var details_arr = details.split("###");

                                                    var objID = await add_items_with_image(ItemInfo["ItemID"], ItemInfo["W"], ItemInfo["H"], ItemInfo["D"], ItemInfo["Color"], ItemInfo["X"], ItemInfo["Y"], ItemInfo["Z"], p_mod_index, shelf_ind, j, ItemInfo["BHoriz"], ItemInfo["BVert"], ItemInfo["Item"], parseInt(details_arr[0]), parseInt(details_arr[1]), "N", "N", p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_pog_index);
                                                } else {
                                                    var objID = await add_items_prom(ItemInfo["ItemID"], ItemInfo["W"], ItemInfo["H"], ItemInfo["D"], ItemInfo["Color"], ItemInfo["X"], ItemInfo["Y"], ItemInfo["Z"], p_mod_index, shelf_ind, j, "N", "N", p_pogcrDelistItemDftColor, p_pogcrItemNumLabelColor, p_pogcrDisplayItemInfo, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pog_index);
                                                }
                                            }
                                            if (ItemInfo["Status"] == "N") {
                                                var selectedObject = g_world.getObjectById(objID);
                                                selectedObject.BorderColour = g_status_error_color;
                                                selectedObject.Status = "N";
                                                selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                                            }
                                            if (p_carpark_ind == "N") {
                                                g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[shelf_ind].ItemInfo[j].Z = 0.025;
                                                g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[shelf_ind].ItemInfo[j].ObjID = objID;
                                                g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[shelf_ind].ItemInfo[j].CType = ShelfInfo["ObjType"];
                                            } else {
                                                g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark[shelf_ind].ItemInfo[j].Z = 0.025;
                                                g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark[shelf_ind].ItemInfo[j].ObjID = objID;
                                                g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark[shelf_ind].ItemInfo[j].CType = ShelfInfo["ObjType"];
                                            }
                                        }
                                        j = j + 1;
                                    }

                                    if (p_carpark_ind == "N") {
                                        var item_Details = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[shelf_ind].ItemInfo;
                                        for (const items of item_Details) {
                                            if ((typeof items.TopObjID !== "undefined" && items.TopObjID !== "") || (typeof items.BottomObjID !== "undefined" && items.BottomObjID !== "")) {
                                                var tier_ind;
                                                if (items.TopObjID !== "" && typeof items.TopObjID !== "undefined") {
                                                    tier_ind = "BOTTOM";
                                                } else {
                                                    tier_ind = "TOP";
                                                }
                                                var returnval = reset_top_bottom_obj_id(tier_ind, items.OldObjID, items.ObjID, items.X, "N", p_pog_index);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    i = i + 1;
                }
            }
            logDebug("function : create_shelf_edit_pog_lib", "E");
            return newObjectID;
        }
    } catch (err) {
        error_handling(err);
    }
}

function create_final_module(p_uuid, p_width, p_height, p_depth, p_color, p_y, p_edit_ind, p_vert_start, p_vert_spacing, p_horz_start, p_horz_spacing, p_finalX, p_edit_module_index, p_pegHolesActive, p_pog_index) {
    try {
        logDebug("function : create_final_module; uuid : " + p_uuid + "; width : " + p_width + "; height : " + p_height + "; depth : " + p_depth + "; color : " + p_color + "; y : " + p_y + "; p_edit_ind : " + p_edit_ind + "; vert_start : " + p_vert_start + "; vert_spacing : " + p_vert_spacing + "; horz_start : " + p_horz_start + "; horz_spacing : " + p_horz_spacing + "; finalX : " + p_finalX + "; edit_module_index : " + p_edit_module_index, "S");
        return new Promise(function (resolve, reject) {
            var l_module = new THREE.Mesh( //remove global variable
                new THREE.BoxGeometry(p_width, p_height, 0.001),
                new THREE.MeshStandardMaterial({
                    color: p_color,
                })
            );

            if (p_vert_spacing > 0 || p_horz_spacing > 0) {
                var dot_module = add_dots_to_object(p_width - g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].NotchW * 2, p_height, 0.0007, p_vert_start, p_vert_spacing, p_horz_start, p_horz_spacing, l_module, "MODULE", "", p_edit_module_index, p_pegHolesActive, "N", p_pog_index);

                dot_module.position.x = p_finalX;
                dot_module.position.y = p_y;
                dot_module.position.z = 0;
                dot_module.uuid = p_uuid;
                if (g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].NotchW > 0) {
                    add_notches("MODULE" + p_edit_module_index + "_NOTCHES", g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].NotchW, p_height, g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].NotchStart, g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].NotchSpacing, p_color, p_edit_ind, p_width, p_edit_module_index, dot_module, p_pog_index);
                }
                var l_wireframe_id = add_wireframe(dot_module, 2);
                dot_module.WFrameID = l_wireframe_id;
                g_world.add(dot_module);
                if (p_edit_ind == "N") {
                    g_module_obj_array.push(dot_module);
                } else {
                    if (p_edit_module_index == 0) {
                        g_module_obj_array.splice(p_edit_module_index, p_edit_module_index + 1);
                    } else {
                        g_module_obj_array.splice(p_edit_module_index, 1);
                    }
                    g_module_obj_array.push(dot_module);
                }
                g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].MObjID = dot_module.id;
                g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].WFrameID = l_wireframe_id;
                dot_module.Module = g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].Module;
                dot_module.POGCode = g_pog_json[p_pog_index].POGCode; //ASA-1360 Task 2
                dot_module.Version = g_pog_json[p_pog_index].Version; //ASA-1360 Task 2
                dot_module.SvnCode = g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].SvnCode; //ASA-1994
                dot_module.EgtCode = g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].EgtCode; //ASA-1994
                dot_module.Remarks = g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].Remarks !== null ? g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].Remarks : ""; //ASA-1360 Task 2
            } else {
                l_module.position.x = p_finalX;
                l_module.position.y = p_y;
                l_module.position.z = 0;
                l_module.uuid = p_uuid;
                if (g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].NotchW > 0) {
                    add_notches("MODULE" + p_edit_module_index + "_NOTCHES", g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].NotchW, p_height, g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].NotchStart, g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].NotchSpacing, p_color, p_edit_ind, p_width, p_edit_module_index, l_module, p_pog_index);
                }
                var l_wireframe_id = add_wireframe(l_module, 2);
                l_module.WFrameID = l_wireframe_id;
                g_world.add(l_module);
                if (p_edit_ind == "N") {
                    g_module_obj_array.push(l_module);
                } else {
                    if (p_edit_module_index == 0) {
                        g_module_obj_array.splice(p_edit_module_index, p_edit_module_index + 1);
                    } else {
                        g_module_obj_array.splice(p_edit_module_index, 1);
                    }
                    g_module_obj_array.push(l_module);
                }
                g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].MObjID = l_module.id;
                g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].WFrameID = l_wireframe_id;
                l_module.Module = g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].Module;
                l_module.POGCode = g_pog_json[p_pog_index].POGCode; //ASA-1360 Task 2
                l_module.Version = g_pog_json[p_pog_index].Version; //ASA-1360 Task 2
                l_module.Remarks = g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].Remarks !== null ? g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].Remarks : ""; //ASA-1360 Task 2
                l_module.SvnCode = g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].SvnCode; //ASA-1994
                l_module.EgtCode = g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].EgtCode; //ASA-1994
            }
            g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].X = wpdSetFixed(p_finalX);
            g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].Y = wpdSetFixed(p_y);
            g_pog_json[p_pog_index].ModuleInfo[p_edit_module_index].Z = 0;
            resolve("SUCCESS");
            logDebug("function : create_final_module", "E");
        });
    } catch (err) {
        error_handling(err);
    }
}

function update_module_coords(p_height, p_width, p_module_ind, p_pog_index) {
    logDebug("function : update_module_coords; height : " + p_height + "; width : " + p_width + "; module_ind : " + p_module_ind, "S");
    try {
        var module_count = parseFloat(g_pog_json[p_pog_index].ModuleInfo.length) - 1;
        var mod_cnt_chk = module_count;
        var finalX;
        var moduleX = 0;
        var edit_x = 0;
        var object_exists = "N";
        var module_x_arr = [];
        var module_y_arr = [];
        var edit_index_arr = [];

        $.each(g_pog_json[p_pog_index].ModuleInfo, function (i, Modules) {
            if (Modules.ParentModule == null || Modules.ParentModule == "undefined") {
                if (i < p_module_ind) {
                    edit_x += Modules.W;
                } else if (i > p_module_ind) object_exists = "Y";
            }
        });

        if (object_exists == "Y") {
            finalX = edit_x + p_width / 2;
            module_x_arr.push(finalX);
            module_y_arr.push(p_height / 2 + g_pog_json[p_pog_index].BaseH);
            edit_index_arr.push(module_count);
            edit_x = edit_x + p_width;

            $.each(g_pog_json[p_pog_index].ModuleInfo, function (i, Modules) {
                if (Modules.ParentModule == null || Modules.ParentModule == "undefined") {
                    if (i > p_module_ind) {
                        finalX = edit_x + Modules.W / 2;
                        edit_index_arr.push(i);
                        module_x_arr.push(finalX);
                        module_y_arr.push(Modules.H / 2 + g_pog_json[p_pog_index].BaseH);
                        edit_x += Modules.W;
                    }
                }
            });

            module_x_arr.forEach((mod_x, index) => {
                const edited_index = edit_index_arr[index];
                const moduleY = module_y_arr[index];
                g_pog_json[p_pog_index].ModuleInfo[edit_index_arr[index]].X = mod_x;
                g_pog_json[p_pog_index].ModuleInfo[edit_index_arr[index]].Y = module_y_arr[index];
            });
        } else {
            g_pog_json[p_pog_index].ModuleInfo[p_module_ind].X = edit_x + p_width / 2;
            g_pog_json[p_pog_index].ModuleInfo[p_module_ind].Y = p_height / 2 + g_pog_json[p_pog_index].BaseH;
        }
        logDebug("function : update_module_coords", "E");
    } catch (err) {
        error_handling(err);
        logDebug("function : update_module_coords", "E");
    }
}

function getCombinedBoundingBox(p_object) {
    logDebug("function : getCombinedBoundingBox", "S");
    try {
        const result = new THREE.Box3();
        p_object.traverse((child) => {
            // skip everything that doesn't have a geometry
            if (!child.geometry) {
                return;
            }

            child.geometry.computeBoundingBox();
            result.union(child.geometry.boundingBox);
        });

        logDebug("function : getCombinedBoundingBox", "E");
        return result;
    } catch (err) {
        error_handling(err);
        logDebug("function : getCombinedBoundingBox", "E");
    }
}

async function add_shelf(p_uuid, p_type, p_width, p_height, p_depth, p_color, p_x, p_y, p_z, p_edit_ind, p_mod_index, p_rotation, p_slope, p_shelf_ind, p_recreate, p_carpark_ind, p_shelf_edit, p_create_canvas, p_pogCarparkShelfDftColor, p_notchHead, p_pogcrDelistItemDftColor, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_pog_index, p_pog_json = g_pog_json /*20241223 Reg 2*/) {
    //ASA-1350 issue 6 case 2 added parameters //ASA-1487
    logDebug("function : add_shelf; uuid : " + p_uuid + "; type : " + p_type + "; width : " + p_width + "; height : " + p_height + "; depth : " + p_depth + "; color : " + p_color + "; x : " + p_x + "; y : " + p_y + "; z : " + p_z + "; p_edit_ind : " + p_edit_ind + "; mod_index : " + p_mod_index + "; rotation : " + p_rotation + "; slope : " + p_slope + "; shelf_ind : " + p_shelf_ind + "; recreate : " + p_recreate + "; carpark_ind : " + p_carpark_ind + "; shelf_edit : " + p_shelf_edit, "S");
    try {
        if (p_carpark_ind == "Y") {
            p_color = p_pogCarparkShelfDftColor;
        }
        if (p_rotation !== 0 || p_slope !== 0) {
            p_depth = p_depth;
        } else {
            p_depth = 0.001;
        }
        var availableSpace = 0;
        p_create_canvas = typeof p_create_canvas == "undefined" ? -1 : p_create_canvas;
        var shelf_cnt;
        var shelf_obj_type;
        if (typeof g_module_width == "undefined" || g_module_width == "") g_module_width = parseFloat(g_pog_json[p_pog_index].ModuleInfo[p_mod_index].W);

        if (p_edit_ind == "Y") {
            var selectedObject = g_world.getObjectById(g_dblclick_objid);
            g_world.remove(selectedObject);
            shelf_cnt = p_shelf_ind;
        } else {
            if (p_shelf_ind !== -1) {
                shelf_cnt = p_shelf_ind;
            } else {
                shelf_cnt = parseFloat(g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.length) - 1;
            }
        }
        var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[shelf_cnt];

        if (p_carpark_ind == "N") {
            shelf_obj_type = shelfdtl.ObjType;
            availableSpace = shelfdtl.AvlSpace;
        } else {
            availableSpace = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark[0].AvlSpace;
            shelf_obj_type = "SHELF";
        }

        if (p_rotation == 0 && p_slope == 0) {
            p_rotation = 0;
            p_slope = 0;
            var l_shelf = new THREE.Mesh(
                new THREE.BoxGeometry(p_width, p_height, p_depth),
                new THREE.MeshStandardMaterial({
                    color: p_color,
                })
            );
            var l_wireframe_id = add_wireframe(l_shelf, 2);
            if (p_carpark_ind == "N") {
                var shelf_info = shelfdtl;
            } else {
                var shelf_info = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark[shelf_cnt];
            }
            l_shelf.WFrameID = l_wireframe_id;
            l_shelf.position.x = p_x;
            l_shelf.position.y = p_y;
            //ASA-1710,1681 Added carpark condition
            if (p_carpark_ind == "N" && isShelfOnPegboard(p_x, p_y, p_mod_index, p_pog_index, shelf_info, p_pog_json)) {
                // ASA-1769 issue 1 Changed g_pog_json to p_pog_json  //ASA-1694 #18 Changed p_pog_json to g_pog_json
                l_shelf.position.z = 0.004;
            } else {
                l_shelf.position.z = 0.0009;
            } // ASA-1544 Issue - 1
            l_shelf.uuid = p_uuid;
            l_shelf.POGCode = g_pog_json[p_pog_index].POGCode; //ASA-1243
            l_shelf.Version = g_pog_json[p_pog_index].Version; //ASA-1243
            //Start ASA-1305
            l_shelf.X = wpdSetFixed(shelf_info.X * 100 - (shelf_info.W * 100) / 2); //.toFixed(2);
            if (shelf_info.EditNotch == "Y") {
                l_shelf.Y = wpdSetFixed(shelf_info.EditNotchY * 100); //.toFixed(2);
            } else {
                l_shelf.Y = wpdSetFixed(shelf_info.Y * 100 - (shelf_info.H * 100) / 2); //.toFixed(2);
            }
            l_shelf.Z = wpdSetFixed(shelf_info.Z * 100 - (shelf_info.D * 100) / 2); //.toFixed(2);
            //l_shelf.X = Math.round(shelf_info.X * 100); // ASA-1243 //ASA-1305
            //l_shelf.Y = Math.round(shelf_info.Y * 100); // ASA-1243 //ASA-1305
            //l_shelf.Z = Math.round(shelf_info.Z * 100); // ASA-1243 //ASA-1305
            //End ASA-1305
            l_shelf.NotchNo = shelf_info.NotchNo;

            l_shelf.Desc = shelf_info.Desc;
            l_shelf.FixelID = shelf_info.Shelf;
            l_shelf.Module = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Module;
            //ASA-1361 20240501-S
            l_shelf.W = shelf_info.W; //ASA-1277 * 100   no need to multiply the value here beacuse we using the width get from the world and find the item pos x
            l_shelf.H = shelf_info.H; //ASA-1277* 100
            l_shelf.D = shelf_info.D; //ASA-1277* 100
            l_shelf.ROverhang = shelf_info.ROverhang; //ASA-1305 * 100
            l_shelf.LOverhang = shelf_info.LOverhang; //ASA-1305* 100
            // ASA-1361 20240501 -E
            l_shelf.Color = shelf_info.Color;
            l_shelf.Rotation = p_rotation;
            l_shelf.ItemSlope = p_slope;
            l_shelf.RotationFlag = p_rotation !== 0 || p_slope !== 0 ? "Y" : "N";
            l_shelf.ImageExists = "N";
            if (shelf_obj_type == "SHELF") {
                l_shelf.AvlSpace = wpdSetFixed(nvl(availableSpace)); // parseFloat(nvl(availableSpace).toFixed(3));
            }

            g_world.add(l_shelf);
            if (p_carpark_ind == "N") {
                shelfdtl.WFrameID = l_wireframe_id;
                if (g_compare_pog_flag == "Y" && g_compare_view == "EDIT_PALLET" && g_edit_pallet_shelfid == shelfdtl.SObjID) {
                    g_pog_json[p_pog_index].ModuleInfo[0].ShelfInfo[0] = JSON.parse(JSON.stringify(shelfdtl));
                    g_pog_json[p_pog_index].ModuleInfo[0].ShelfInfo[0].PrimeShelfObjID = parseInt(l_shelf.id);
                }
                shelfdtl.SObjID = parseInt(l_shelf.id);
            } else {
                g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark[shelf_cnt].WFrameID = l_wireframe_id;
                g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark[shelf_cnt].SObjID = parseInt(l_shelf.id);
            }
        } else {
            g_rotation = p_rotation;
            if (p_slope > 0) {
                p_slope = 0 - p_slope;
            } else {
                p_slope = -p_slope;
            }
            g_slope = p_slope;

            var l_shelf = new THREE.Mesh(
                new THREE.BoxGeometry(p_width, p_height, p_depth),
                new THREE.MeshBasicMaterial({
                    color: p_color,
                })
            );
            var l_wireframe_id = add_wireframe(l_shelf, 2);
            l_shelf.WFrameID = l_wireframe_id;
            var mod_right = 0;
            if (p_recreate == "Y" && p_edit_ind == "N") {
                var i = 0;
                for (const modules of g_pog_json[p_pog_index].ModuleInfo) {
                    if (modules.ParentModule == null) {
                        mod_right = Math.max(mod_right, parseFloat(modules.X) + modules.W / 2);
                    }
                    i++;
                }
                p_x = mod_right + p_width / 2;
                p_y = g_pog_json[p_pog_index].CameraY;
            }

            l_shelf.uuid = p_uuid;
            l_shelf.rotateY((p_rotation * Math.PI) / 180);
            l_shelf.rotateX((p_slope * Math.PI) / 180);
            g_world.add(l_shelf);
            l_shelf.geometry.computeBoundingBox();
            var bounding_box = l_shelf.geometry.boundingBox;
            var box = new THREE.Box3().setFromObject(l_shelf);
            var box_dim = box.getSize(new THREE.Vector3());

            l_shelf.position.x = p_x; //0 - (depth / 2);
            l_shelf.position.y = p_y;
            if (p_slope < 0) {
                l_shelf.position.y = p_y + parseFloat(box_dim.y) / 2;
            } else {
                l_shelf.position.y = p_y - parseFloat(box_dim.y) / 2;
            }
            l_shelf.position.z = p_depth / 2 + g_pog_json[p_pog_index].BackDepth;
            if (p_carpark_ind == "N") {
                var shelf_info = shelfdtl;
            } else {
                var shelf_info = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark[shelf_cnt];
            }
            l_shelf.POGCode = g_pog_json[p_pog_index].POGCode; //ASA-1243
            l_shelf.Version = g_pog_json[p_pog_index].Version; //ASA-1243
            //Start ASA-1305
            l_shelf.X = wpdSetFixed(shelf_info.X * 100 - (shelf_info.W * 100) / 2); //.toFixed(2);
            if (shelf_info.EditNotch == "Y") {
                l_shelf.Y = wpdSetFixed(shelf_info.EditNotchY * 100); //.toFixed(2);
            } else {
                l_shelf.Y = wpdSetFixed(shelf_info.Y * 100 - (shelf_info.H * 100) / 2); //toFixed(roundNumber(shelf_info.Y * 100 - ((shelf_info.H * 100) / 2), 3));
            }
            l_shelf.Z = wpdSetFixed(shelf_info.Z * 100 - (shelf_info.D * 100) / 2); //.toFixed(2);
            //l_shelf.X = Math.round(shelf_info.X * 100); // ASA-1243 //ASA-1305
            //l_shelf.Y = Math.round(shelf_info.Y * 100); // ASA-1243 //ASA-1305
            //l_shelf.Z = Math.round(shelf_info.Z * 100); // ASA-1243 //ASA-1305
            //End ASA-1305
            l_shelf.Desc = shelf_info.Desc;
            l_shelf.FixelID = shelf_info.Shelf;
            l_shelf.Module = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Module;
            //ASA-1361 20240501-S
            l_shelf.W = shelf_info.W; //ASA-1277 * 100 no need to multiply the value here beacuse we using the width get from the world and find the item pos x
            l_shelf.H = shelf_info.H; //ASA-1277* 100
            l_shelf.D = shelf_info.D; //ASA-1277* 100
            l_shelf.ROverhang = shelf_info.ROverhang; //* 100
            l_shelf.LOverhang = shelf_info.LOverhang; //* 100
            //ASA-1361 20240501-E
            l_shelf.Color = shelf_info.Color;
            l_shelf.Rotation = p_rotation;
            l_shelf.ItemSlope = p_slope;
            l_shelf.NotchNo = shelf_info.NotchNo;
            l_shelf.Rotation = p_rotation !== 0 || p_slope !== 0 ? "Y" : "N";
            l_shelf.ImageExists = "N";
            if (shelf_obj_type == "SHELF") {
                l_shelf.AvlSpace = wpdSetFixed(nvl(availableSpace)); //parseFloat(nvl(availableSpace).toFixed(3));
            }

            if (p_carpark_ind == "N") {
                if (g_compare_pog_flag == "Y" && g_compare_view == "EDIT_PALLET" && g_edit_pallet_shelfid == shelfdtl.SObjID) {
                    g_pog_json[p_pog_index].ModuleInfo[0].ShelfInfo[0] = JSON.parse(JSON.stringify(g_pog_json[p_pog_index].ModuleInfo[g_module_index].ShelfInfo[g_shelf_index]));
                    g_pog_json[p_pog_index].ModuleInfo[0].ShelfInfo[0].PrimeShelfObjID = parseInt(l_shelf.id);
                }
                shelfdtl.X = p_x;
                shelfdtl.Y = p_y;
                shelfdtl.SObjID = parseInt(l_shelf.id);
                shelfdtl.Z = p_depth / 2 + g_pog_json[p_pog_index].BackDepth;

                shelfdtl.WFrameID = l_wireframe_id;
                shelfdtl.ShelfRotateWidth = parseFloat(box_dim.x);
                shelfdtl.ShelfRotateHeight = parseFloat(box_dim.y);
                shelfdtl.ShelfRotateDepth = parseFloat(box_dim.z);
            }
            if (g_manual_zoom_ind == "N") {
                var details = get_min_max_xy(p_pog_index);
                var details_arr = details.split("###");
                set_camera_z(g_camera, parseFloat(details_arr[2]), parseFloat(details_arr[3]), parseFloat(details_arr[0]), parseFloat(details_arr[1]), g_offset_z, parseFloat(details_arr[4]), parseFloat(details_arr[5]), true, g_pog_index);
            }
            if (p_recreate == "Y" && p_edit_ind == "N") {
                p_x = wpdSetFixed(mod_right + p_width / 2);
                p_y = g_pog_json[p_pog_index].CameraY;
            }
            l_shelf.position.x = p_x; //0 - (depth / 2);
            if (p_slope < 0) {
                l_shelf.position.y = wpdSetFixed(p_y + parseFloat(box_dim.y) / 2);
            } else {
                l_shelf.position.y = wpdSetFixed(p_y - parseFloat(box_dim.y) / 2);
            }
            if (p_rotation !== 0) {
                l_shelf.quaternion.copy(g_camera.quaternion);
                l_shelf.lookAt(g_pog_json[p_pog_index].CameraX, g_pog_json[p_pog_index].CameraY, g_pog_json[p_pog_index].CameraZ);
                l_shelf.rotateY((p_rotation * Math.PI) / 180);
                l_shelf.rotateX((p_slope * Math.PI) / 180);
            }
        }
        l_shelf.BorderColour = 0x000000;
        var shelf_id = parseInt(l_shelf.id);
        if (g_show_fixel_label == "Y" && p_carpark_ind == "N") {
            if (shelf_obj_type !== "BASE" && shelf_obj_type !== "NOTCH") {
                var hex_color = shelfdtl.Color;
                if (hexToRgb(hex_color) == null) {
                    var red = parseInt("FF", 16);
                    var green = parseInt("FF", 16);
                    var blue = parseInt("FF", 16);
                } else {
                    var red = hexToRgb(hex_color).r;
                    var green = hexToRgb(hex_color).r;
                    var blue = hexToRgb(hex_color).g;
                }
                var text_color = getTextColor(red, green, blue); //ASA-1095
                if (g_fixel_label == "Y") {
                    var notch_no = get_notch_no(g_pog_json[p_pog_index].ModuleInfo[p_mod_index], p_pog_index, shelfdtl.Y + shelfdtl.H / 2);
                    var shelf = shelfdtl.Shelf + " " + shelfdtl.Desc + " " + parseFloat(shelfdtl.Y * 100 - (shelfdtl.H / 2) * 100).toFixed(2) + get_message("POGCR_FIXEL_CM") + " " + notch_no;
                    var return_obj = addlabelText(shelf, g_labelFont, g_labelActualSize, text_color, "center", "");
                    l_shelf.add(return_obj); //ASA-1638 #1
                    return_obj.position.y = -0.005; //ASA-1638 #1
                    var x = ((return_obj.material.map.image.width / return_obj.material.map.image.height) * g_labelActualSize) / 2; //ASA-1677 #5 Added to calculate value for X
                    return_obj.position.x = 0 - shelfdtl.W / 2 + x + 0.01; //ASA-1677 #5
                    //return_obj.position.x = 0 - (shelfdtl.W / 2.4 - 0.02);    //ASA-1638 #1
                } else {
                    var return_obj = addlabelText(shelfdtl.Shelf, g_labelFont, g_labelActualSize, text_color, "center", "");
                    l_shelf.add(return_obj); //ASA-1638 #1
                    var x = ((return_obj.material.map.image.width / return_obj.material.map.image.height) * g_labelActualSize) / 2; //ASA-1677 #5 Added to calculate value for X
                    return_obj.position.x = 0 - shelfdtl.W / 2 + x + 0.01; //ASA-1677 #5
                    //return_obj.position.x = 0 - (shelfdtl.W / 2.4 + 0.01);   //ASA-1638 #1
                    return_obj.position.y = 0; //ASA-1638 #1
                } //ASA-1638

                if (shelfdtl.Rotation !== 0 || shelfdtl.Slope !== 0) {
                    return_obj.position.z = shelfdtl.D / 2 + 0.005;
                } else {
                    return_obj.position.z = 0.001;
                }
                shelfdtl.LObjID = return_obj.id;
            }
        } else if (p_carpark_ind == "Y") {
            var text_color = "#ffffff";
            var return_obj = addlabelText(g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark[shelf_cnt].Shelf, 12, g_labelActualSize, text_color, "center", "");
            l_shelf.add(return_obj);
            return_obj.position.x = 0 - (g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Carpark[shelf_cnt].W / 3 + 0.01);
            return_obj.position.y = 0;
            return_obj.position.z = 0.005;
        }
        if (shelf_obj_type == "CHEST" && g_chest_as_pegboard == "Y") {
            //ASA-1125
            add_chest_dots_array(p_width, p_height, 0, 0.01, 0, 0.01, shelf_cnt, p_mod_index, p_pog_index);
        }

        if (p_carpark_ind == "N") {
            //&& g_show_notch_label == "Y") {//ASA-1254 Notch no to be updated always to show in status bar //Task_26627 found a bug the whole condition was commented, which will give error for carpark shelf.
            var returnval = update_single_notch_label("Y", p_mod_index, shelf_cnt, p_notchHead, l_shelf, p_pog_index, p_carpark_ind);
        }
        l_shelf.NotchNo = shelf_info.NotchNo;

        if (p_recreate == "Y") {
            if (reorder_items(p_mod_index, shelf_cnt, p_pog_index)) {
                //ASA-1446 issue 5
                var return_val = await recreate_all_items(p_mod_index, shelf_cnt, shelfdtl.ObjType, "Y", -1, -1, shelfdtl.ItemInfo.length, "Y", "N", -1, -1, p_create_canvas, "", p_pog_index, p_pogcrDelistItemDftColor, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, "Y"); //ASA-1350 issue 6 case 2 added parameters
            }
        }
        if (typeof g_pog_json !== "undefined" && g_compare_view == "EDIT_PALLET") {
            g_pog_json[p_pog_index].ModuleInfo[0].ShelfInfo[0].PrimeShelfObjID = l_shelf.id;
        }
        logDebug("function : add_shelf", "E");
        return [shelf_id, shelf_cnt];
    } catch (err) {
        error_handling(err);
    }
}
//Start ASA-1371_26842
function get_notch_no(p_modules, p_pog_index, p_shelf_top) {
    var cap_count = 100;
    var notch_no = 0;
    for (k = 0; k < cap_count; k++) {
        if (p_shelf_top < g_pog_json[p_pog_index].BaseH + p_modules.NotchStart / 2 && p_modules.NotchStart > 0) {
            notch_no = 0;
            break;
        } else if (p_shelf_top <= g_pog_json[p_pog_index].BaseH + p_modules.NotchStart && p_modules.NotchStart > 0) {
            notch_no = 1;
            break;
        } else if (p_shelf_top <= g_pog_json[p_pog_index].BaseH && p_modules.NotchStart == 0) {
            notch_no = 0;
            break;
        } else if (wpdSetFixed(p_shelf_top) < wpdSetFixed(g_pog_json[p_pog_index].BaseH + p_modules.NotchStart + p_modules.NotchSpacing * k)) {
            notch_no = k;
            break;
        }
    }
    return notch_no;
}
//End ASA-1371_26842

async function update_single_notch_label(p_label_ind, p_mod_index, p_shelf_cnt, p_notchHead, p_shelf_obj, p_pog_index, p_carpark_ind) {
    //ASA-1254 Notch no to be updated always to show in status bar
    var shelfs = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[p_shelf_cnt];
    var modules = g_pog_json[p_pog_index].ModuleInfo[p_mod_index];
    var notch_label = g_notch_label_position.toUpperCase();
    if (g_pog_json[p_pog_index].ModuleInfo[p_mod_index].NotchW > 0 && shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX") {
        if (p_shelf_obj == "") {
            try {
                p_shelf_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[p_shelf_cnt].SObjID);
            } catch {
                return "FAIL";
            }
        }

        var notch_no = get_notch_no(modules, p_pog_index, shelfs.Y + shelfs.H / 2); //ASA-1371_26842

        shelfs.NotchNo = notch_no;
        p_shelf_obj.NotchNo = notch_no;

        if (p_carpark_ind == "N" && g_show_notch_label == "Y") {
            if (p_label_ind == "Y") {
                //ASA-1234 -- Update notch details even if notch label not called
                if (typeof shelfs.NotchLabelObjID !== "undefined" && shelfs.NotchLabelObjID !== -1) {
                    var label_obj = p_shelf_obj.getObjectById(shelfs.NotchLabelObjID);
                    p_shelf_obj.remove(label_obj);
                }

                var hex_color = shelfs.Color;
                if (hexToRgb(hex_color) == null) {
                    var red = parseInt("FF", 16);
                    var green = parseInt("FF", 16);
                    var blue = parseInt("FF", 16);
                } else {
                    var red = hexToRgb(hex_color).r;
                    var green = hexToRgb(hex_color).r;
                    var blue = hexToRgb(hex_color).g;
                }

                var text_color;
                // ASA-1095
                if (notch_label == "CENTER") {
                    text_color = getTextColor(red, green, blue);
                } else {
                    text_color = "#000000";
                }

                var return_obj = addlabelText(p_notchHead + " " + notch_no, g_labelFont, g_labelActualSize, text_color, "center", "");
                p_shelf_obj.add(return_obj);
                // return_obj.position.y = -0.005;
                if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                    return_obj.position.z = shelfs.D / 2 + 0.005;
                } else {
                    return_obj.position.z = 0.005; // 0.0005 --ASA-1095
                }

                // return_obj.position.x = 0 - (shelfs.W / 4 + 0.01);
                [posX, posY] = getLabelPosition(shelfs, "S", notch_label); // ASA-1095
                return_obj.position.x = posX;
                return_obj.position.y = posY;
                g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[p_shelf_cnt].NotchLabelObjID = return_obj.id;
            } else {
                if (typeof shelfs.NotchLabelObjID !== "undefined" && shelfs.NotchLabelObjID !== -1) {
                    var label_obj = p_shelf_obj.getObjectById(shelfs.NotchLabelObjID);
                    p_shelf_obj.remove(label_obj);
                }
            }
        }
    }
    return "SUCCESS";
}

function add_rod(p_uuid, p_type, p_width, p_height, p_depth, p_color, p_x, p_y, p_z, p_edit_ind, p_mod_index, p_shelf_ind, p_pog_index) {
    logDebug("function : add_rod; uuid : " + p_uuid + "; type : " + p_type + "; width : " + p_width + "; height : " + p_height + "; depth : " + p_depth + "; color : " + p_color + "; x : " + p_x + "; y : " + p_y + "; z : " + p_z + "; p_edit_ind : " + p_edit_ind + "; mod_index : " + p_mod_index + "; shelf_ind : " + p_shelf_ind, "S");
    try {
        p_depth = 0.001;
        var shelf_cnt;
        var lines_vertices_x = [];
        var lines_vertices_y = [];
        if (typeof g_module_width == "undefined" || g_module_width == "") g_module_width = parseFloat(g_pog_json[p_pog_index].ModuleInfo[p_mod_index].W);

        if (p_edit_ind == "Y") {
            var selectedObject = g_world.getObjectById(g_dblclick_objid);
            g_world.remove(selectedObject);
            shelf_cnt = g_shelf_index;
        } else {
            if (p_shelf_ind !== -1) {
                shelf_cnt = p_shelf_ind;
            } else {
                shelf_cnt = parseFloat(g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.length) - 1;
            }
        }
        var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[shelf_cnt];

        var shelf_obj_type = shelfdtl.SObjID;
        var l_shelf = new THREE.Mesh(
            new THREE.BoxGeometry(p_width, p_height, p_depth),
            new THREE.MeshStandardMaterial({
                color: p_color,
            })
        );
        //var geometry = new THREE.Geometry();

        lines_vertices_x.push(0 - p_width / 2);
        lines_vertices_x.push(p_width / 2);
        lines_vertices_x.push(0 - p_width / 2);
        lines_vertices_x.push(p_width / 2);

        lines_vertices_y.push(0 - p_height / 2);
        lines_vertices_y.push(p_height / 2);
        lines_vertices_y.push(p_height / 2);
        lines_vertices_y.push(0 - p_height / 2);

        var points = [];

        points.push(new THREE.Vector3(lines_vertices_x[0], lines_vertices_y[0], 0));
        points.push(new THREE.Vector3(lines_vertices_x[1], lines_vertices_y[1], 0));
        points.push(new THREE.Vector3(lines_vertices_x[2], lines_vertices_y[2], 0));
        points.push(new THREE.Vector3(lines_vertices_x[3], lines_vertices_y[3], 0));

        let geometry = new THREE.BufferGeometry().setFromPoints(points);

        var material = new THREE.LineBasicMaterial({
            color: 0xda1b1b,
        });

        var line1 = new THREE.LineSegments(geometry, material);
        var line2 = new THREE.LineSegments(geometry, material);

        line1.position.z = 0.001;
        line2.position.z = 0.001;
        l_shelf.add(line1);
        l_shelf.add(line2);

        var l_wireframe_id = add_wireframe(l_shelf, 2);
        l_shelf.WFrameID = l_wireframe_id;
        l_shelf.position.x = p_x;
        l_shelf.position.y = p_y;
        l_shelf.position.z = 0.008;
        l_shelf.uuid = p_uuid;
        var shelf_info = shelfdtl;
        l_shelf.POGCode = g_pog_json[p_pog_index].POGCode; // ASA-1243
        l_shelf.Version = g_pog_json[p_pog_index].Version; // ASA-1243
        //Start ASA-1305
        l_shelf.X = wpdSetFixed(shelf_info.X * 100 - (shelf_info.W * 100) / 2); // (shelf_info.X * 100 - (shelf_info.W * 100) / 2).toFixed(2);
        if (shelf_info.EditNotch == "Y") {
            l_shelf.Y = wpdSetFixed(shelf_info.EditNotchY * 100); //.toFixed(2);
        } else {
            l_shelf.Y = wpdSetFixed(shelf_info.Y * 100 - (shelf_info.H * 100) / 2); //toFixed(roundNumber(shelf_info.Y * 100 - ((shelf_info.H * 100) / 2), 3));
        }
        l_shelf.Z = wpdSetFixed(shelf_info.Z * 100 - (shelf_info.D * 100) / 2); //.toFixed(2);
        //l_shelf.X = Math.round(shelf_info.X * 100); // ASA-1243 //ASA-1305
        //l_shelf.Y = Math.round(shelf_info.Y * 100); // ASA-1243 //ASA-1305
        //l_shelf.Z = Math.round(shelf_info.Z * 100); // ASA-1243 //ASA-1305
        //End ASA-1305
        l_shelf.AvlSpace = shelf_info.AvlSpace; // ASA-1243;
        l_shelf.FixelID = shelf_info.Shelf;
        l_shelf.Desc = shelf_info.Desc; //ASA-1243
        l_shelf.Module = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Module;
        l_shelf.W = shelf_info.W;
        l_shelf.H = shelf_info.H;
        l_shelf.D = shelf_info.D;
        l_shelf.Color = shelf_info.Color;
        l_shelf.Rotation = 0;
        l_shelf.ItemSlope = 0;
        l_shelf.Rotation = "N";
        l_shelf.ImageExists = "N";
        l_shelf.BorderColour = 0x000000;
        g_world.add(l_shelf);

        shelfdtl.LineVerticesX = lines_vertices_x;
        shelfdtl.LineVerticesY = lines_vertices_y;
        shelfdtl.SObjID = parseInt(l_shelf.id);
        shelfdtl.WFrameID = l_wireframe_id;
        if (g_show_fixel_label == "Y") {
            if (shelf_obj_type !== "BASE" && shelf_obj_type !== "NOTCH") {
                var hex_color = shelfdtl.Color;
                if (hexToRgb(hex_color) == null) {
                    var red = parseInt("FF", 16);
                    var green = parseInt("FF", 16);
                    var blue = parseInt("FF", 16);
                } else {
                    var red = hexToRgb(hex_color).r;
                    var green = hexToRgb(hex_color).r;
                    var blue = hexToRgb(hex_color).g;
                }

                var text_color = getTextColor(red, green, blue); //ASA-1095

                // if (red * 0.299 + green * 0.587 + blue * 0.114 > 186) {
                // 	text_color = "#000000";
                // } else {
                // 	text_color = "#ffffff";
                // }
                var return_obj = addlabelText(shelfdtl.Shelf, g_labelFont, g_labelActualSize, text_color, "center", "");
                l_shelf.add(return_obj);
                return_obj.position.x = 0 - (shelfdtl.W / 2.4 + 0.01);
                return_obj.position.y = 0;
                return_obj.position.z = 0.005;
                shelfdtl.LObjID = return_obj.id;
            }
        }
        logDebug("function : add_rod", "E");
        return parseInt(l_shelf.id);
    } catch (err) {
        error_handling(err);
    }
}

function wrapText(p_context, p_text, p_x, p_y, p_maxWidth, p_lineHeight) {
    logDebug("function : wrapText; text : " + p_text + "; x : " + p_x + "; y : " + p_y + "; maxWidth : " + p_maxWidth + "; lineHeight : " + p_lineHeight, "S");
    try {
        var words = p_text.split(" "),
            line = "",
            lineCount = 0,
            p = 0,
            test,
            metrics;
        for (p = 0; p < words.length; p++) {
            test = words[p];
            metrics = p_context.measureText(test);
            while (metrics.width > p_maxWidth) {
                // Determine how much of the word will fit
                test = test.substring(0, test.length - 1);
                metrics = p_context.measureText(test);
            }
            if (words[p] != test && test !== "") {
                words.splice(p + 1, 0, words[p].substr(test.length));
                words[p] = test;
            }

            test = line + words[p] + " ";
            metrics = p_context.measureText(test);

            if (metrics.width > p_maxWidth && p > 0) {
                p_context.fillText(line, p_x, p_y);
                line = words[p] + " ";
                p_y += p_lineHeight;
                lineCount++;
            } else {
                line = test;
            }
        }

        p_context.fillText(line, p_x, p_y);
        logDebug("function : wrapText", "E");
    } catch (err) {
        logDebug("function : wrapText", "E");
        error_handling(err);
    }
}

function dcText(p_txt, p_font_size, p_fgcolor, p_bgcolor, p_width, p_height, p_wrap_text, p_reducetofit, p_fontstyle, p_fontbold, p_fontsize, p_mod_index, p_shelf_cnt, p_enlarge_no, p_pog_index, p_pogcr_enhance_textbox_fontsize, p_text_direction) {
    try {
        logDebug("function : dcText; txt : " + p_txt, "S");
        if (p_txt && p_txt.includes("ASA-1837")) {
            console.error("DRAWING ASA-1837 VIA dcText", p_txt);
            }
        // ===== FONT SIZE SYNC FIX (MOST IMPORTANT) =====  ASA-2029
        // if ((!p_font_size || p_font_size === "") && p_fontsize) {
        //     p_font_size = p_fontsize;
        // }
        // p_font_size = parseInt(p_font_size, 10) || 12;
        // =============================================

        if (p_shelf_cnt !== -1) {
            var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[p_shelf_cnt];
            if ((shelfdtl.ObjType !== "TEXTBOX") || (shelfdtl.ObjType == "TEXTBOX" && p_pogcr_enhance_textbox_fontsize == "Y" && p_reducetofit == "Y")) {
                p_pogcr_enhance_textbox_fontsize = "N"; //ASA-1787, added if block
            }
            if (typeof shelfdtl.canvasW !== "undefined") {
                if (shelfdtl.canvasW !== null && p_pogcr_enhance_textbox_fontsize == "N") {
                    var canvasWidth = shelfdtl.canvasW * p_enlarge_no;
                    var canvasHeight = shelfdtl.canvasH * p_enlarge_no;
                } else {
                    var [canvasWidth, canvasHeight] = get_visible_size(0.012, p_width * p_enlarge_no, p_height * p_enlarge_no, g_canvas, g_camera);
                    if (shelfdtl.canvasW == null) {
                        shelfdtl.canvasW = canvasWidth / p_enlarge_no;
                        shelfdtl.canvasH = canvasHeight / p_enlarge_no;
                    }
                }
            } else {
                var [canvasWidth, canvasHeight] = get_visible_size(0.012, p_width * p_enlarge_no, p_height * p_enlarge_no, g_canvas, g_camera);
                shelfdtl.canvasW = canvasWidth / p_enlarge_no;
                shelfdtl.canvasH = canvasHeight / p_enlarge_no;
            }
        } else {
            var [canvasWidth, canvasHeight] = get_visible_size(0.012, p_width * p_enlarge_no, p_height * p_enlarge_no, g_canvas, g_camera);
        }
        if (!p_font_size || p_font_size === "" && p_text_direction == "V") { // ASA-1797 Issue 1   //ASA-2029
            p_font_size = 12;
        }
        var ruler = document.createElement("DIV");
        ruler.style.fontFamily = p_fontstyle;
        ruler.style.fontWeight = p_fontbold == "bold" ? "bold" : "normal";
        ruler.style.fontSize = parseInt(p_font_size) * p_enlarge_no + "pt";
        ruler.style.position = "absolute";
        ruler.style.top = "-500px";
        ruler.style.left = "0";
        ruler.innerHTML = p_txt;
        document.body.appendChild(ruler);

        let cssSize = {
            width: ruler.offsetWidth,
            height: ruler.offsetHeight,
        },
            cssInfo = window.getComputedStyle(ruler, null),
            fontSizePx = parseFloat(cssInfo["fontSize"]);
        document.body.removeChild(ruler);

        var text_width = ruler.offsetWidth + 5;
        var text_height = parseInt(p_font_size) * p_enlarge_no; //ruler.offsetHeight;

        // create the canvas for the texture
        var txtcanvas = document.createElement("canvas"); // create the canvas for the texture
        var ctx = txtcanvas.getContext("2d");
        txtcanvas.width = canvasWidth;
        txtcanvas.height = canvasHeight;

        if (p_bgcolor != undefined || p_bgcolor !== null) {
            ctx.fillStyle = "#" + p_bgcolor.toString(16).padStart(6, "0");
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        }
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#" + p_fgcolor.toString(16).padStart(6, "0"); // fgcolor
        ctx.font = p_fontbold + " " + fontSizePx + "px " + p_fontstyle;

        // ASA-1797 Issue 1 Start
        if (shelfdtl && shelfdtl.ObjType === "TEXTBOX" && p_text_direction == "V") {
            const chars = p_txt.split("");
            let fontSize = parseInt(p_font_size) * p_enlarge_no;
            let charHeight = fontSize * 1.2;
            let totalHeight = chars.length * charHeight;
            let cols = 1;
            if (p_wrap_text === "Y" && totalHeight > canvasHeight) {
                cols = 2;
            }
            let charsPerCol = Math.ceil(chars.length / cols);
            if (p_reducetofit === "Y") {
                while ((charsPerCol * charHeight > canvasHeight) && fontSize > 6) {
                    fontSize--;
                    charHeight = fontSize * 1.2;
                    totalHeight = chars.length * charHeight;
                    charsPerCol = Math.ceil(chars.length / cols);
                }
            }
            ctx.font = p_fontbold + " " + fontSize + "px " + p_fontstyle;
            let startY = (canvasHeight - charHeight * charsPerCol) / 2 + charHeight / 2;
            let centerX = canvasWidth / 2;
            let columnOffset = fontSize;
            for (let c = 0; c < cols; c++) {
                let colX = cols === 2
                    ? centerX + (c === 0 ? -columnOffset / 2 : columnOffset / 2)
                    : centerX;

                for (let i = 0; i < charsPerCol; i++) {
                    let charIndex = i + c * charsPerCol;
                    if (charIndex >= chars.length) break;
                    let yPos = startY + i * charHeight;
                    ctx.fillText(chars[charIndex], colX, yPos);
                }
            }
        }
        // ASA-1797 Issue 1 End
        else {
            var metrics = ctx.measureText(p_txt);
            lineGap = cssSize.height - (metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent);
            let advMetrics = {
                width: metrics.width,
                cssHeight: cssSize.height,
                cssFontSizePx: fontSizePx,
                fontAscent: metrics.fontBoundingBoxAscent,
                fontDescent: metrics.fontBoundingBoxDescent,
                actualAscent: metrics.actualBoundingBoxAscent,
                actualDescent: metrics.actualBoundingBoxDescent,
                lineHeight: cssSize.height,
                lineGap: lineGap,
                lineGapTop: lineGap / 2,
                lineGapBottom: lineGap / 2,
            };

            var metrics = ctx.measureText(p_txt).width;
            if (p_reducetofit == "Y" && metrics > canvasWidth && p_wrap_text == "N") {
                var new_txt_hgt = 50;
                for (i = 50; i >= 0; i--) {
                    var newcanvas = document.createElement("canvas");
                    var new_context = newcanvas.getContext("2d");
                    newcanvas.width = canvasWidth;
                    newcanvas.height = canvasHeight;
                    if (p_bgcolor != undefined || p_bgcolor !== null) {
                        new_context.fillStyle = "#" + p_bgcolor.toString(16).padStart(6, "0");
                        new_context.fillRect(0, 0, canvasWidth, canvasHeight);
                    }
                    new_context.textAlign = "center";
                    new_context.textBaseline = "middle";
                    new_context.fillStyle = "#" + p_fgcolor.toString(16).padStart(6, "0"); // fgcolor
                    new_context.font = p_fontbold + " " + i + "px " + p_fontstyle;
                    if (new_context.measureText(p_txt).width + 5 <= canvasWidth) {
                        new_txt_hgt = i;
                        break;
                    }
                }

                text_height = new_txt_hgt < 50 ? new_txt_hgt : text_height;
            }

            if (p_bgcolor != undefined || p_bgcolor !== null) {
                // fill background if desired (transparent if none)
                ctx.fillStyle = "#" + p_bgcolor.toString(16).padStart(6, "0");
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            }
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "#" + p_fgcolor.toString(16).padStart(6, "0"); // fgcolor
            //ctx.font = p_fontbold + " " + text_height + "px " + p_fontstyle;
            ctx.font = (p_fontbold ? p_fontbold + " " : "") + " " + text_height + "px " + p_fontstyle; // ASA 2030 ISSUE 1 FIX

            var lineHeight = advMetrics.lineHeight - advMetrics.lineGap;
            if (p_wrap_text == "Y" && metrics > canvasWidth) {
                wrapText(ctx, p_txt, canvasWidth / 2, text_height, canvasWidth, lineHeight);
            } else {
                ctx.fillText(p_txt, canvasWidth / 2, canvasHeight / 2);
            }
        }

        var tex = new THREE.CanvasTexture(txtcanvas);
        tex.minFilter = THREE.LinearFilter;
        //tex.needsUpdate = true;

        geometry = new THREE.PlaneGeometry(p_width, p_height);
        var material = new THREE.MeshBasicMaterial({
            side: THREE.DoubleSide,
            map: tex,
            transparent: true,
            opacity: 1.0,
        });

        var mesh = new THREE.Mesh(geometry, material);
        logDebug("function : dcText", "E");
        return mesh;
    } catch (err) {
        error_handling(err);
    }
}

function add_pegboard(p_uuid, p_width, p_height, p_depth, p_color, p_x, p_y, p_z, p_edit_ind, p_vert_start, p_vert_spacing, p_horz_start, p_horz_spacing, p_mod_index, p_shelf_ind, p_rotation, p_slope, p_recreate, p_pogcrDelistItemDftColor, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_pog_index) {
    //ASA-1350 issue 6 added parameters
    logDebug("function : add_pegboard; uuid : " + p_uuid + "; width : " + p_width + "; height : " + p_height + "; depth : " + p_depth + "; color : " + p_color + "; x : " + p_x + "; y : " + p_y + "; z : " + p_z + "; p_edit_ind : " + p_edit_ind + "; vert_start : " + p_vert_start + "; vert_spacing : " + p_vert_spacing + "; horz_start : " + p_horz_start + "; horz_spacing : " + p_horz_spacing + "; mod_index : " + p_mod_index + "; shelf_ind : " + p_shelf_ind + "; rotation : " + p_rotation + "; slope : " + p_slope + "; recreate : " + p_recreate, "S");
    try {
        var shelf_cnt = 0;

        if (p_edit_ind == "Y") {
            var selectedObject = g_world.getObjectById(g_dblclick_objid);
            g_world.remove(selectedObject);
            shelf_cnt = g_shelf_index;
        } else {
            if (p_shelf_ind !== -1) {
                shelf_cnt = p_shelf_ind;
            } else {
                shelf_cnt = parseFloat(g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.length) - 1;
            }
        }
        var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[shelf_cnt];

        var shelf_obj_type = shelfdtl.SObjID;

        if (p_rotation !== 0 || p_slope !== 0) {
            g_rotation = p_rotation;
            if (p_slope > 0) {
                p_slope = 0 - p_slope;
            } else {
                p_slope = -p_slope;
            }
            g_slope = p_slope;

            var l_pegboard = new THREE.Mesh(
                new THREE.BoxGeometry(p_width, p_height, 0.01),
                new THREE.MeshStandardMaterial({
                    color: p_color,
                })
            );

            var dot_pegboard = add_dots_to_object(p_width, p_height, 0.0007, p_vert_start, p_vert_spacing, p_horz_start, p_horz_spacing, l_pegboard, "PEGBOARD", shelf_cnt, p_mod_index, g_peg_holes_active /*ASA-1640*/, "N", p_pog_index);

            var mod_right = 0;
            var i = 0;
            if (p_recreate == "Y" && p_edit_ind == "N") {
                for (const modules of g_pog_json[p_pog_index].ModuleInfo) {
                    if (modules.ParentModule == null) {
                        mod_right = Math.max(mod_right, parseFloat(modules.X) + modules.W / 2);
                    }
                    i++;
                }
                p_x = mod_right + p_width / 2;
                p_y = g_pog_json[p_pog_index].CameraY;
            }

            dot_pegboard.position.x = g_pog_json[p_pog_index].CameraX;
            dot_pegboard.position.y = p_y;
            dot_pegboard.position.z = 0.00115;
            dot_pegboard.uuid = p_uuid;

            var shelf_info = shelfdtl;
            dot_pegboard.POGCode = g_pog_json[p_pog_index].POGCode; //ASA-1243
            dot_pegboard.Version = g_pog_json[p_pog_index].Version; //ASA-1243
            dot_pegboard.FixelID = shelf_info.Shelf;
            dot_pegboard.Module = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Module;
            dot_pegboard.W = shelf_info.W;
            dot_pegboard.H = shelf_info.H;
            dot_pegboard.D = shelf_info.D;
            //Start ASA-1305
            dot_pegboard.X = wpdSetFixed(shelf_info.X * 100 - (shelf_info.W * 100) / 2); //.toFixed(2);
            if (shelf_info.EditNotch == "Y") {
                dot_pegboard.Y = wpdSetFixed(shelf_info.EditNotchY * 100); //.toFixed(2);
            } else {
                dot_pegboard.Y = wpdSetFixed(shelf_info.Y * 100 - (shelf_info.H * 100) / 2); //toFixed(roundNumber(shelf_info.Y * 100 - ((shelf_info.H * 100) / 2), 3));
            }
            dot_pegboard.Z = wpdSetFixed(shelf_info.Z * 100 - (shelf_info.D * 100) / 2); //.toFixed(2);
            //dot_pegboard.X = Math.round(shelf_info.X * 100); // ASA-1243 //ASA-1305
            //dot_pegboard.Y = Math.round(shelf_info.Y * 100); // ASA-1243 //ASA-1305
            //dot_pegboard.Z = Math.round(shelf_info.Z * 100); // ASA-1243 //ASA-1305
            //End ASA-1305
            dot_pegboard.Color = shelf_info.Color;
            dot_pegboard.Rotation = p_rotation;
            dot_pegboard.ItemSlope = p_slope;
            dot_pegboard.Rotation = p_rotation !== 0 || p_slope !== 0 ? "Y" : "N";
            dot_pegboard.ImageExists = "N";
            dot_pegboard.rotateY((p_rotation * Math.PI) / 180);
            dot_pegboard.rotateX((p_slope * Math.PI) / 180);
            var l_wireframe_id = add_wireframe(dot_pegboard, 2);
            dot_pegboard.WFrameID = l_wireframe_id;
            g_world.add(dot_pegboard);
            dot_pegboard.geometry.computeBoundingBox();
            var bounding_box = dot_pegboard.geometry.boundingBox;
            var box = new THREE.Box3().setFromObject(dot_pegboard);
            var box_dim = box.getSize(new THREE.Vector3());
            shelfdtl.WFrameID = l_wireframe_id;
            shelfdtl.ShelfRotateWidth = parseFloat(box_dim.x);
            shelfdtl.ShelfRotateHeight = parseFloat(box_dim.y);
            shelfdtl.ShelfRotateDepth = parseFloat(box_dim.z);
            if (g_manual_zoom_ind == "N") {
                var details = get_min_max_xy(p_pog_index);
                var details_arr = details.split("###");
                set_camera_z(g_camera, parseFloat(details_arr[2]), parseFloat(details_arr[3]), parseFloat(details_arr[0]), parseFloat(details_arr[1]), g_offset_z, parseFloat(details_arr[4]), parseFloat(details_arr[5]), true, p_pog_index);
            }
            if (p_recreate == "Y" && p_edit_ind == "N") {
                p_x = mod_right + p_width / 2;
                p_y = g_pog_json[p_pog_index].CameraY;
            }
            dot_pegboard.position.x = p_x; //0 - (depth / 2);
            if (p_slope < 0) {
                dot_pegboard.position.y = p_y + parseFloat(box_dim.y) / 2;
            } else {
                dot_pegboard.position.y = p_y - parseFloat(box_dim.y) / 2;
            }
            dot_pegboard.position.z = 0.00115;
            if (p_rotation !== 0) {
                dot_pegboard.quaternion.copy(g_camera.quaternion);
                dot_pegboard.lookAt(g_pog_json[p_pog_index].CameraX, g_pog_json[p_pog_index].CameraY, g_pog_json[p_pog_index].CameraZ);
            }
            dot_pegboard.rotateY((p_rotation * Math.PI) / 180);
            dot_pegboard.rotateX((p_slope * Math.PI) / 180);
            dot_pegboard.updateMatrix();
        } else {
            var l_pegboard = new THREE.Mesh(
                new THREE.BoxGeometry(p_width, p_height, 0.001),
                new THREE.MeshStandardMaterial({
                    color: p_color,
                })
            );

            var dot_pegboard = add_dots_to_object(p_width, p_height, 0.0007, p_vert_start, p_vert_spacing, p_horz_start, p_horz_spacing, l_pegboard, "PEGBOARD", shelf_cnt, p_mod_index, g_peg_holes_active /*ASA-1640*/, "N", p_pog_index);

            dot_pegboard.position.x = p_x;
            dot_pegboard.position.y = p_y;
            dot_pegboard.position.z = 0.00115;
            dot_pegboard.uuid = p_uuid;

            dot_pegboard.POGCode = g_pog_json[p_pog_index].POGCode; //ASA-1243
            dot_pegboard.Version = g_pog_json[p_pog_index].Version; //ASA-1243

            var shelf_info = shelfdtl;
            dot_pegboard.FixelID = shelf_info.Shelf;
            dot_pegboard.Module = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Module;
            dot_pegboard.W = shelf_info.W;
            dot_pegboard.H = shelf_info.H;
            dot_pegboard.D = shelf_info.D;
            //Start ASA-1305
            dot_pegboard.X = wpdSetFixed(shelf_info.X * 100 - (shelf_info.W * 100) / 2); //.toFixed(2);
            if (shelf_info.EditNotch == "Y") {
                dot_pegboard.Y = wpdSetFixed(shelf_info.EditNotchY * 100); //.toFixed(2);
            } else {
                dot_pegboard.Y = wpdSetFixed(shelf_info.Y * 100 - (shelf_info.H * 100) / 2); //toFixed(roundNumber(shelf_info.Y * 100 - ((shelf_info.H * 100) / 2), 3));
            }
            dot_pegboard.Z = wpdSetFixed(shelf_info.Z * 100 - (shelf_info.D * 100) / 2); //.toFixed(2);
            //dot_pegboard.X = Math.round(shelf_info.X * 100); // ASA-1243 //ASA-1305
            //dot_pegboard.Y = Math.round(shelf_info.Y * 100); // ASA-1243 //ASA-1305
            //dot_pegboard.Z = Math.round(shelf_info.Z * 100); // ASA-1243 //ASA-1305
            //End ASA-1305
            dot_pegboard.Color = shelf_info.Color;
            dot_pegboard.Rotation = p_rotation;
            dot_pegboard.ItemSlope = p_slope;
            dot_pegboard.Rotation = p_rotation !== 0 || p_slope !== 0 ? "Y" : "N";
            dot_pegboard.ImageExists = "N";

            var l_wireframe_id = add_wireframe(dot_pegboard, 2);
            dot_pegboard.WFrameID = l_wireframe_id;
            g_world.add(dot_pegboard);
        }
        shelfdtl.SObjID = parseInt(dot_pegboard.id);
        dot_pegboard.BorderColour = 0x000000;

        if (p_recreate == "Y") {
            if (shelfdtl.ItemInfo.length > 0) {
                var items_arr = shelfdtl.ItemInfo;
                var i = 0;
                for (const items of items_arr) {
                    shelfdtl.ItemInfo[i].Exists = "E";
                    i++;
                }
                return_val = recreate_all_items(p_mod_index, shelf_cnt, shelfdtl.ObjType, "Y", -1, -1, shelfdtl.ItemInfo.length, "N", "N", p_pog_index, [], g_start_canvas, "", p_pog_index, p_pogcrDelistItemDftColor, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, "Y"); //ASA-1350 issue 6 case 2 added parameters
            }
        }
        if (g_show_fixel_label == "Y") {
            var hex_color = shelfdtl.Color;
            if (hexToRgb(hex_color) == null) {
                var red = parseInt("FF", 16);
                var green = parseInt("FF", 16);
                var blue = parseInt("FF", 16);
            } else {
                var red = hexToRgb(hex_color).r;
                var green = hexToRgb(hex_color).r;
                var blue = hexToRgb(hex_color).g;
            }

            var text_color = getTextColor(red, green, blue); //ASA-1095
            var return_obj = addlabelText(shelfdtl.Shelf, g_labelFont, g_labelActualSize, text_color, "center", "");
            dot_pegboard.add(return_obj);
            var x = ((return_obj.material.map.image.width / return_obj.material.map.image.height) * g_labelActualSize) / 2; //ASA-1677 #5 Added to calculate value for X
            return_obj.position.x = 0 - shelfdtl.W / 2 + x + 0.01; //ASA-1677 #5
            //return_obj.position.x = 0 - (shelfdtl.W / 2.4 + 0.01);
            return_obj.position.y = 0;
            if (shelfdtl.Rotation !== 0 || shelfdtl.Slope !== 0) {
                return_obj.position.z = shelfdtl.D / 2 + 0.005;
            } else {
                return_obj.position.z = 0.005;
            }
            shelfdtl.LObjID = return_obj.id;
        }
        shelfdtl.WFrameID = l_wireframe_id;
        g_dblclick_opened = "N";
        logDebug("function : add_pegboard", "E");
        return parseInt(dot_pegboard.id);
    } catch (err) {
        logDebug("function : add_pegboard", "E");
        error_handling(err);
    }
}

function add_text_box_with_image(p_uuid, p_type, p_width, p_height, p_depth, p_color, p_x, p_y, p_z, p_edit_ind, p_mod_index, p_input_text, p_color_hex, p_wrap_text, p_reducetofit, p_hex_color, p_shelf_ind, p_rotation, p_slope, p_recreate, p_fontstyle, p_fontsize, p_fontbold, p_notchHead, p_pog_index) {
    logDebug("function : add_text_box_with_image; uuid : " + p_uuid + "; type : " + p_type + "; width : " + p_width + "; height : " + p_height + "; depth : " + p_depth + "; color : " + p_color + "; x : " + p_x + "; y : " + p_y + "; z : " + p_z + "; p_edit_ind : " + p_edit_ind + "; mod_index : " + p_mod_index + "; input_text : " + p_input_text + "; color_hex : " + p_color_hex + "; wrap_text : " + p_wrap_text + "; reducetofit : " + p_reducetofit + "; hex_color : " + p_hex_color + "; shelf_ind : " + p_shelf_ind + "; rotation : " + p_rotation + "; slope : " + p_slope + "; recreate : " + p_recreate + "; fontstyle : " + p_fontstyle + "; fontsize : " + p_fontsize + "; fontbold : " + p_fontbold, "S");
    try {
        return new Promise(function (resolve, reject) {
            var shelf_cnt = -1;
            if (p_edit_ind == "Y") {
                var selectedObject = g_world.getObjectById(g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[p_shelf_ind].SObjID);
                g_world.remove(selectedObject);
                shelf_cnt = p_shelf_ind;
            } else {
                if (p_shelf_ind !== -1) {
                    shelf_cnt = p_shelf_ind;
                } else {
                    shelf_cnt = parseFloat(g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.length) - 1;
                }
            }
            var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[shelf_cnt];

            // Create an image
            var image = new Image(); // or document.createElement('img' );
            // Create texture
            var tex = new THREE.Texture(image);
            // On image load, update texture
            image.onload = () => {
                tex.needsUpdate = true;
            };
            // Set image source
            image.src = "data:image/png;base64," + shelfdtl.TextImg;
            geometry = new THREE.PlaneGeometry(p_width, p_height);
            var material = new THREE.MeshBasicMaterial({
                side: THREE.DoubleSide,
                map: tex,
                transparent: true,
                opacity: 1.0,
            });
            // and finally, the mesh
            var mesh = new THREE.Mesh(geometry, material);

            if (p_rotation !== 0 || p_slope !== 0) {
                g_rotation = p_rotation;
                if (p_slope > 0) {
                    p_slope = 0 - p_slope;
                } else {
                    p_slope = -p_slope;
                }
                g_slope = p_slope;

                mesh.position.x = g_pog_json[p_pog_index].CameraX;
                mesh.position.y = p_y;
                mesh.position.z = p_depth / 2 + g_pog_json[p_pog_index].BackDepth;

                var shelf_info = shelfdtl;
                mesh.FixelID = shelf_info.Shelf;

                mesh.POGCode = g_pog_json[p_pog_index].POGCode; //ASA-1243
                mesh.Version = g_pog_json[p_pog_index].Version; //ASA-1243
                //Start ASA-1305
                mesh.X = wpdSetFixed(shelf_info.X * 100 - (shelf_info.W * 100) / 2); //.toFixed(2);
                if (shelf_info.EditNotch == "Y") {
                    mesh.Y = wpdSetFixed(shelf_info.EditNotchY * 100); //.toFixed(2);
                } else {
                    mesh.Y = wpdSetFixed(shelf_info.Y * 100 - (shelf_info.H * 100) / 2); //toFixed(roundNumber(shelf_info.Y * 100 - ((shelf_info.H * 100) / 2), 3));
                }
                mesh.Z = wpdSetFixed(shelf_info.Z * 100); //.toFixed(2);
                //mesh.X = Math.round(shelf_info.X * 100); // ASA-1243 //ASA-1305
                //mesh.Y = Math.round(shelf_info.Y * 100); // ASA-1243 //ASA-1305
                //mesh.Z = Math.round(shelf_info.Z * 100); // ASA-1243 //ASA-1305
                //End ASA-1305

                mesh.Module = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Module;
                mesh.W = shelf_info.W;
                mesh.H = shelf_info.H;
                mesh.D = shelf_info.D;
                mesh.Color = shelf_info.Color;
                mesh.Rotation = p_rotation;
                mesh.ItemSlope = p_slope;
                mesh.Rotation = p_rotation !== 0 || p_slope !== 0 ? "Y" : "N";
                mesh.ImageExists = "Y";

                mesh.rotateY((p_rotation * Math.PI) / 180);
                if (p_rotation == 0) {
                    mesh.rotateX(((p_slope / 2) * Math.PI) / 180);
                } else {
                    mesh.rotateX((p_slope * Math.PI) / 180);
                }
                g_world.add(mesh);
                mesh.geometry.computeBoundingBox();
                var bounding_box = mesh.geometry.boundingBox;
                var box = new THREE.Box3().setFromObject(mesh);
                var box_dim = box.getSize(new THREE.Vector3());

                shelfdtl.ShelfRotateWidth = parseFloat(box_dim.x);
                shelfdtl.ShelfRotateHeight = parseFloat(box_dim.y);
                shelfdtl.ShelfRotateDepth = parseFloat(box_dim.z);

                if (g_manual_zoom_ind == "N") {
                    var details = get_min_max_xy(p_pog_index);
                    var details_arr = details.split("###");
                    set_camera_z(g_camera, parseFloat(details_arr[2]), parseFloat(details_arr[3]), parseFloat(details_arr[0]), parseFloat(details_arr[1]), g_offset_z, parseFloat(details_arr[4]), parseFloat(details_arr[5]), true, p_pog_index);
                }
                mesh.position.x = p_x;
                mesh.position.y = p_y;
                mesh.position.z = p_depth / 2 + g_pog_json[p_pog_index].BackDepth;
                if (p_rotation !== 0) {
                    mesh.quaternion.copy(g_camera.quaternion);
                    mesh.lookAt(g_pog_json[p_pog_index].CameraX, g_pog_json[p_pog_index].CameraY, g_pog_json[p_pog_index].CameraZ);
                }
                mesh.rotateY((p_rotation * Math.PI) / 180);
                if (p_rotation == 0) {
                    mesh.rotateX(((p_slope / 2) * Math.PI) / 180);
                } else {
                    mesh.rotateX((p_slope * Math.PI) / 180);
                }
                mesh.updateMatrix();
            } else {
                mesh.position.x = p_x;
                mesh.position.y = p_y;
                if (p_z == g_pog_json[p_pog_index].BackDepth) {
                    mesh.position.z = 0.001;
                } else {
                    mesh.position.z = p_z > 0.0021 ? 0.0021 : p_z == 0 ? 0.0006 : p_z;
                }
            }
            mesh.uuid = p_uuid;
            mesh.FixelID = shelfdtl.Shelf;
            mesh.Module = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Module;
            mesh.POGCode = g_pog_json[p_pog_index].POGCode; //ASA-1243
            mesh.Version = g_pog_json[p_pog_index].Version; //ASA-1243
            //Start ASA-1305
            mesh.X = wpdSetFixed(shelfdtl.X * 100 - (shelfdtl.W * 100) / 2); //.toFixed(2);
            if (shelfdtl.EditNotch == "Y") {
                mesh.Y = wpdSetFixed(shelfdtl.EditNotchY * 100); //.toFixed(2);
            } else {
                mesh.Y = wpdSetFixed(shelfdtl.Y * 100 - (shelfdtl.H * 100) / 2); //toFixed(roundNumber(shelfdtl.Y * 100 - ((shelfdtl.H * 100) / 2), 3));
            }
            mesh.Z = wpdSetFixed(shelfdtl.Z * 100); //.toFixed(2);
            //mesh.X = Math.round(shelfdtl.X * 100); // ASA-1243 //ASA-1305
            //mesh.Y = Math.round(shelfdtl.Y * 100); // ASA-1243 //ASA-1305
            //mesh.Z = Math.round(shelfdtl.Z * 100); // ASA-1243 //ASA-1305
            //End ASA-1305

            var l_wireframe_id = add_wireframe(mesh, 1);
            g_world.add(mesh);
            shelfdtl.WFrameID = l_wireframe_id;
            mesh.BorderColour = 0x000000;
            if (g_show_fixel_label == "Y") {
                var hex_color = shelfdtl.Color;
                if (hexToRgb(hex_color) == null) {
                    var red = parseInt("FF", 16);
                    var green = parseInt("FF", 16);
                    var blue = parseInt("FF", 16);
                } else {
                    var red = hexToRgb(hex_color).r;
                    var green = hexToRgb(hex_color).r;
                    var blue = hexToRgb(hex_color).g;
                }

                var text_color = getTextColor(red, green, blue); //ASA-1095
                var return_obj = addlabelText(shelfdtl.Shelf, 10, 0.018, text_color, "center", "");
                mesh.add(return_obj);
                return_obj.position.x = 0 - (shelfdtl.W / 2.4 + 0.01);
                return_obj.position.y = 0;
                return_obj.position.z = 0.005;
                shelfdtl.LObjID = return_obj.id;
            }
            if (g_show_notch_label == "Y") {
                show_notch_labels("Y", p_notchHead, "N", p_pog_index);
            }
            shelfdtl.SObjID = parseInt(mesh.id);
            //ASA-1652 #3 Start
            // if (p_edit_ind == "Y") {
            //     if (typeof shelfdtl.ManualZupdate !== "undefined") {
            //         if (shelfdtl.ManualZupdate == "N") {
            //             var shelfz = get_textbox_z(p_mod_index, shelf_cnt, p_x, p_y, p_width, p_height, p_pog_index);
            //             shelfdtl.Z = shelfz;
            //         }
            //     } else {
            //         var shelfz = get_textbox_z(p_mod_index, shelf_cnt, p_x, p_y, p_width, p_height, p_pog_index);
            //         shelfdtl.Z = shelfz;
            //     }
            // }
            //ASA-1652 #3 End
            resolve(mesh.id);
            logDebug("function : add_text_box_with_image", "E");
        });
    } catch (err) {
        error_handling(err);
    }
}

function get_textbox_z(p_module_index, p_shelf_index, p_x, p_y, p_width, p_height, p_pog_index) {
    logDebug("function : get_textbox_z; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index + "; x : " + p_x + "; y : " + p_y + "; width : " + p_width + "; height : " + p_height, "S");
    var shelf_start = p_x - p_width / 2;
    var shelf_end = p_x + p_width / 2;
    var shelf_top = p_y + p_height / 2;
    var shelf_bottom = p_y - p_height / 2;
    var module_details = g_pog_json[p_pog_index].ModuleInfo;
    var obj_hit = "N",
        obj_z = 0;
    var i = 0;

    for (const modules of module_details) {
        if (obj_hit == "Y") {
            break;
        }
        if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
            var l_shelf_details = modules.ShelfInfo;
            var j = 0;
            for (const shelfs of l_shelf_details) {
                if (obj_hit == "Y") {
                    break;
                }
                if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX") {
                    if (shelfs.ItemInfo.length > 0) {
                        var item_Details = shelfs.ItemInfo;
                        var k = 0;
                        for (const items of item_Details) {
                            var div_left = items.X - items.W / 2;
                            var div_right = items.X + items.W / 2;
                            var div_top = items.Y + items.H / 2;
                            var div_bottom = items.Y - items.H / 2;
                            if ((shelf_start >= div_left && shelf_start < div_right && ((shelf_top > div_bottom && shelf_top <= div_top) || (shelf_bottom >= div_bottom && shelf_bottom < div_top))) || (shelf_end > div_left && shelf_end <= div_right && ((shelf_top > div_bottom && shelf_top <= div_top) || (shelf_bottom >= div_bottom && shelf_bottom < div_top))) || (shelf_start < div_left && shelf_end > div_right && ((shelf_top > div_bottom && shelf_top <= div_top) || (shelf_bottom >= div_bottom && shelf_bottom < div_top)))) {
                                obj_hit = "Y";
                                obj_z = g_pog_json[p_pog_index].BackDepth / 2 + shelfs.D + 0.005;
                                break;
                            } else if ((shelf_start >= div_left && shelf_start && shelf_top > div_top && shelf_bottom < div_bottom) || (shelf_end > div_left && shelf_end <= div_right && shelf_top > div_top && shelf_bottom < div_bottom)) {
                                obj_hit = "Y";
                                obj_z = g_pog_json[p_pog_index].BackDepth / 2 + shelfs.D + 0.005;
                                break;
                            }

                            k = k + 1;
                        }
                    } else {
                        var div_left = shelfs.X - shelfs.W / 2;
                        var div_right = shelfs.X + shelfs.W / 2;
                        var div_top = shelfs.Y + shelfs.H / 2;
                        var div_bottom = shelfs.Y - shelfs.H / 2;
                        if ((shelf_start >= div_left && shelf_start < div_right && ((shelf_top > div_bottom && shelf_top <= div_top) || (shelf_bottom >= div_bottom && shelf_bottom < div_top))) || (shelf_end > div_left && shelf_end <= div_right && ((shelf_top > div_bottom && shelf_top <= div_top) || (shelf_bottom >= div_bottom && shelf_bottom < div_top))) || (shelf_start < div_left && shelf_end > div_right && ((shelf_top > div_bottom && shelf_top <= div_top) || (shelf_bottom >= div_bottom && shelf_bottom < div_top)))) {
                            obj_hit = "Y";
                            obj_z = g_pog_json[p_pog_index].BackDepth / 2 + shelfs.D + 0.005;
                            break;
                        } else if ((shelf_start >= div_left && shelf_start && shelf_top > div_top && shelf_bottom < div_bottom) || (shelf_end > div_left && shelf_end <= div_right && shelf_top > div_top && shelf_bottom < div_bottom)) {
                            obj_hit = "Y";
                            obj_z = g_pog_json[p_pog_index].BackDepth / 2 + shelfs.D + 0.005;
                            break;
                        }
                    }
                }
                j = j + 1;
            }
        }
        i = i + 1;
    }

    // if (obj_hit == "N" && g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].Y - g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].H / 2 <= 0) {
    //     obj_z = g_pog_json[p_pog_index].BackDepth / 2 + 0.005 + g_pog_json[p_pog_index].BaseD;
    // } else if (obj_hit == "N") {
    //     obj_z = g_pog_json[p_pog_index].BackDepth / 2 + 0.005;
    // }
    if (obj_hit == "N") {
        var shelfExists = g_pog_json && g_pog_json[p_pog_index] && g_pog_json[p_pog_index].ModuleInfo &&
            g_pog_json[p_pog_index].ModuleInfo[p_module_index] &&
            g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo &&
            typeof g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index] !== "undefined";
        if (shelfExists) {
            var shelfObj = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
            if (shelfObj.Y - shelfObj.H / 2 <= 0) {
                obj_z = g_pog_json[p_pog_index].BackDepth / 2 + 0.005 + g_pog_json[p_pog_index].BaseD;
            } else {
                obj_z = g_pog_json[p_pog_index].BackDepth / 2 + 0.005;
            }
        } else {
            // fallback when shelf info missing
            obj_z = g_pog_json && g_pog_json[p_pog_index] ? g_pog_json[p_pog_index].BackDepth / 2 + 0.005 : 0.005;
        }
    }
    logDebug("function : get_textbox_z", "E");
    return wpdSetFixed(obj_z); //.toFixed(3));
}

function add_text_box(p_uuid, p_type, p_width, p_height, p_depth, p_color, p_x, p_y, p_z, p_edit_ind, p_mod_index, p_input_text, p_color_hex, p_wrap_text, p_reducetofit, p_hex_color, p_shelf_ind, p_rotation, p_slope, p_recreate, p_fontstyle, p_fontsize, p_fontbold, p_enlargeNo, p_pog_index, p_pogcr_enhance_textbox_fontsize = "N", p_text_direction = "H") { //ASA-1797
    logDebug("function : add_text_box; uuid : " + p_uuid + "; type : " + p_type + "; width : " + p_width + "; height : " + p_height + "; depth : " + p_depth + "; color : " + p_color + "; x : " + p_x + "; y : " + p_y + "; z : " + p_z + "; p_edit_ind : " + p_edit_ind + "; mod_index : " + p_mod_index + "; input_text : " + p_input_text + "; color_hex : " + p_color_hex + "; wrap_text : " + p_wrap_text + "; reducetofit : " + p_reducetofit + "; hex_color : " + p_hex_color + "; shelf_ind : " + p_shelf_ind + "; rotation : " + p_rotation + "; slope : " + p_slope + "; recreate : " + p_recreate + "; fontstyle : " + p_fontstyle + "; fontsize : " + p_fontsize + "; fontbold : " + p_fontbold, "S");
    try {
        if (hexToRgb(p_hex_color) == null) {
            var red = parseInt("FF", 16);
            var green = parseInt("FF", 16);
            var blue = parseInt("FF", 16);
        } else {
            var red = hexToRgb(p_hex_color).r;
            var green = hexToRgb(p_hex_color).r;
            var blue = hexToRgb(p_hex_color).g;
        }

        if (p_edit_ind == "Y") {
            // var selectedObject = g_world.getObjectById(g_dblclick_objid);        //ASA-1669
            var selectedObject = g_world.getObjectById(g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[p_shelf_ind].SObjID); //ASA-1669
            g_world.remove(selectedObject);
            // shelf_cnt = g_shelf_index;   //ASA-1669
            shelf_cnt = p_shelf_ind; //ASA-1669
        } else {
            if (p_shelf_ind !== -1) {
                shelf_cnt = p_shelf_ind;
            } else {
                shelf_cnt = parseFloat(g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo.length) - 1;
            }
        }
        var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].ShelfInfo[shelf_cnt];

        var text_color = getTextColor(red, green, blue); //ASA-1095
        if (text_color == "#000000") {
            text_color = 0x000000;
        } else {
            text_color = 0xffffff;
        }
        // if (color_hex == null || red * 0.299 + green * 0.587 + blue * 0.114 > 186) {
        // 	text_color = 0x000000;
        // } else {
        // 	text_color = 0xffffff;
        // }
        mesh = dcText(p_input_text, p_fontsize, text_color, p_color_hex, p_width, p_height, p_wrap_text, p_reducetofit, p_fontstyle, p_fontbold, p_fontsize, p_mod_index, shelf_cnt, p_enlargeNo, p_pog_index, p_pogcr_enhance_textbox_fontsize, p_text_direction); //ASA-1797

        if (p_rotation !== 0 || p_slope !== 0) {
            g_rotation = p_rotation;
            if (p_slope > 0) {
                p_slope = 0 - p_slope;
            } else {
                p_slope = -p_slope;
            }
            g_slope = p_slope;

            var l_wireframe_id = add_wireframe(mesh, 1);
            var mod_right = 0;
            var i = 0;
            if (p_recreate == "Y" && p_edit_ind == "N") {
                for (const modules of g_pog_json[p_pog_index].ModuleInfo) {
                    if (modules.ParentModule == null) {
                        mod_right = Math.max(mod_right, parseFloat(modules.X) + modules.W / 2);
                    }
                    i++;
                }
                p_x = mod_right + p_width / 2;
                p_y = g_pog_json[p_pog_index].CameraY;
            }

            mesh.position.x = g_pog_json[p_pog_index].CameraX; //0 - (depth / 2);
            mesh.position.y = p_y;
            mesh.position.z = p_depth / 2 + g_pog_json[p_pog_index].BackDepth;
            mesh.uuid = p_uuid;

            var shelf_info = shelfdtl;
            mesh.FixelID = shelf_info.Shelf;
            mesh.POGCode = g_pog_json[p_pog_index].POGCode; //ASA-1243
            mesh.Version = g_pog_json[p_pog_index].Version; //ASA-1243
            //Start ASA-1305
            mesh.X = wpdSetFixed(shelf_info.X * 100 - (shelf_info.W * 100) / 2); //.toFixed(2);
            if (shelf_info.EditNotch == "Y") {
                mesh.Y = wpdSetFixed(shelf_info.EditNotchY * 100); //.toFixed(2);
            } else {
                mesh.Y = wpdSetFixed(shelf_info.Y * 100 - (shelf_info.H * 100) / 2); //toFixed(roundNumber(shelf_info.Y * 100 - ((shelf_info.H * 100) / 2), 3));
            }
            mesh.Z = wpdSetFixed(shelf_info.Z * 100); //.toFixed(2);
            //mesh.X = Math.round(shelf_info.X * 100); // ASA-1243 //ASA-1305
            //mesh.Y = Math.round(shelf_info.Y * 100); // ASA-1243 //ASA-1305
            //mesh.Z = Math.round(shelf_info.Z * 100); // ASA-1243 //ASA-1305
            //End ASA-1305
            mesh.NotchNo = shelf_info.NotchNo;
            mesh.Desc = shelf_info.Desc;

            mesh.Module = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Module;
            mesh.W = shelf_info.W;
            mesh.H = shelf_info.H;
            mesh.D = shelf_info.D;
            mesh.Color = shelf_info.Color;
            mesh.Rotation = p_rotation;
            mesh.ItemSlope = p_slope;
            mesh.Rotation = p_rotation !== 0 || p_slope !== 0 ? "Y" : "N";
            mesh.ImageExists = "N";

            mesh.rotateY((p_rotation * Math.PI) / 180);
            if (p_rotation == 0) {
                mesh.rotateX(((p_slope / 2) * Math.PI) / 180);
            } else {
                mesh.rotateX((p_slope * Math.PI) / 180);
            }
            g_world.add(mesh);
            mesh.geometry.computeBoundingBox();
            var bounding_box = mesh.geometry.boundingBox;
            var box = new THREE.Box3().setFromObject(mesh);
            var box_dim = box.getSize(new THREE.Vector3());
            shelfdtl.WFrameID = l_wireframe_id;
            shelfdtl.ShelfRotateWidth = parseFloat(box_dim.x);
            shelfdtl.ShelfRotateHeight = parseFloat(box_dim.y);
            shelfdtl.ShelfRotateDepth = parseFloat(box_dim.z);

            if (g_manual_zoom_ind == "N") {
                var details = get_min_max_xy(p_pog_index);
                var details_arr = details.split("###");
                set_camera_z(g_camera, parseFloat(details_arr[2]), parseFloat(details_arr[3]), parseFloat(details_arr[0]), parseFloat(details_arr[1]), g_offset_z, parseFloat(details_arr[4]), parseFloat(details_arr[5]), true, p_pog_index /*g_pog_index*/); //ASA-1491 Issue 1
            }
            if (p_recreate == "Y" && p_edit_ind == "N") {
                p_x = mod_right + p_width / 2;
                p_y = g_pog_json[p_pog_index].CameraY;
            }
            mesh.position.x = p_x; //0 - (depth / 2);
            mesh.position.y = p_y;
            mesh.position.z = p_depth / 2 + g_pog_json[p_pog_index].BackDepth;
            if (p_rotation !== 0) {
                mesh.quaternion.copy(g_camera.quaternion);
                mesh.lookAt(g_pog_json[p_pog_index].CameraX, g_pog_json[p_pog_index].CameraY, g_pog_json[p_pog_index].CameraZ);
            }
            mesh.rotateY((p_rotation * Math.PI) / 180);
            if (p_rotation == 0) {
                mesh.rotateX(((p_slope / 2) * Math.PI) / 180);
            } else {
                mesh.rotateX((p_slope * Math.PI) / 180);
            }
            mesh.updateMatrix();
        } else {
            mesh.position.x = p_x;
            mesh.position.y = p_y;
            if (p_z == g_pog_json[p_pog_index].BackDepth) {
                mesh.position.z = 0.001;
            } else {
                mesh.position.z = p_z > 0.0021 ? 0.0021 : p_z == 0 ? 0.0006 : p_z;
            }

            mesh.FixelID = shelfdtl.Shelf;
            mesh.Module = g_pog_json[p_pog_index].ModuleInfo[p_mod_index].Module;
            mesh.POGCode = g_pog_json[p_pog_index].POGCode; //ASA-1243
            mesh.Version = g_pog_json[p_pog_index].Version; //ASA-1243
            //Start ASA-1305
            mesh.X = wpdSetFixed(shelfdtl.X * 100 - (shelfdtl.W * 100) / 2); //.toFixed(2);
            if (shelfdtl.EditNotch == "Y") {
                mesh.Y = wpdSetFixed(shelfdtl.EditNotchY * 100); //.toFixed(2);
            } else {
                mesh.Y = wpdSetFixed(shelfdtl.Y * 100 - (shelfdtl.H * 100) / 2); //toFixed(roundNumber(shelfdtl.Y * 100 - ((shelfdtl.H * 100) / 2), 3));
            }
            mesh.Z = wpdSetFixed(shelfdtl.Z * 100); //.toFixed(2);
            //mesh.X = Math.round(shelfdtl.X * 100); // ASA-1243 //ASA-1305
            //mesh.Y = Math.round(shelfdtl.Y * 100); // ASA-1243 //ASA-1305
            //mesh.Z = Math.round(shelfdtl.Z * 100); // ASA-1243 //ASA-1305
            //End ASA-1305

            mesh.W = shelfdtl.W;
            mesh.H = shelfdtl.H;
            mesh.D = shelfdtl.D;
            mesh.Color = shelfdtl.Color;
            mesh.Rotation = p_rotation;
            mesh.ItemSlope = p_slope;
            mesh.Rotation = p_rotation !== 0 || p_slope !== 0 ? "Y" : "N";
            mesh.ImageExists = "N";
            mesh.NotchNo = shelfdtl.NotchNo;
            mesh.Desc = shelfdtl.Desc;

            var l_wireframe_id = add_wireframe(mesh, 1);
            g_world.add(mesh);
            let buffergeometry = new THREE.BufferGeometry().setFromPoints([]);
            var buffermaterial = new THREE.LineBasicMaterial({
                color: 0x000000,
            });
            var line = new THREE.LineSegments(buffergeometry, buffermaterial);
            line.position.z = 0.0006;
            mesh.add(line);
            shelfdtl.WFrameID = l_wireframe_id;
        }

        shelfdtl.SObjID = parseInt(mesh.id);
        //ASA-1652 #3 Start
        // if (p_edit_ind == "Y") {
        //     if (typeof shelfdtl.ManualZupdate !== "undefined") {
        //         if (shelfdtl.ManualZupdate == "N") {
        //             var shelfz = get_textbox_z(p_mod_index, shelf_cnt, p_x, p_y, p_width, p_height, p_pog_index);
        //             shelfdtl.Z = shelfz;
        //         }
        //     } else {
        //         var shelfz = get_textbox_z(p_mod_index, shelf_cnt, p_x, p_y, p_width, p_height, p_pog_index);
        //         shelfdtl.Z = shelfz;
        //     }
        // }
        //ASA-1652 #3 End
        logDebug("function : add_text_box", "E");
        return parseInt(mesh.id);
    } catch (err) {
        error_handling(err);
    }
}

async function get_images(p_module_index, p_shelf_index, p_item_arr, p_item_index_arr, p_pogcrImgMaxWidth, p_pogcrImgMaxHeight, p_pogcrImgCompressRation) {
    logDebug("function : get_images ; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index, "S");
    try {
        var completed = "N";
        var i = 0;
        for (const items of p_item_arr) {
            var img_exists = "N";
            if (items.ImgExists == "Y") {
                var details = g_orientation_json[items.Orientation];
                var details_arr = details.split("###");
                var j = 0;
                for (const images_arr of g_ItemImages) {
                    // $.each(g_ItemImages, function (j, images_arr) {
                    if (items.Item == images_arr.Item && details_arr[0] == images_arr.Orientation && items.MerchStyle == images_arr.MerchStyle) {
                        img_exists = "Y";
                        break; //return false;
                    }
                    // });
                    j++;
                }
                if (img_exists == "N") {
                    ItemImageInfo = {};
                    ItemImageInfo["Item"] = items.Item;
                    ItemImageInfo["MIndex"] = p_module_index;
                    ItemImageInfo["SIndex"] = p_shelf_index;
                    ItemImageInfo["IIndex"] = i;
                    ItemImageInfo["Orientation"] = details_arr[0];
                    ItemImageInfo["ItemImage"] = null;
                    ItemImageInfo["MerchStyle"] = items.MerchStyle;
                    g_ItemImages.push(ItemImageInfo);
                    var return_val = await call_ajax(p_module_index, p_shelf_index, p_item_index_arr[i], details_arr[0], g_ItemImages.length - 1, items.Item, items.MerchStyle, p_pogcrImgMaxWidth, p_pogcrImgMaxHeight, p_pogcrImgCompressRation);
                }
            }
            i++;
        }
        logDebug("function : get_images", "E");
        return "success";
    } catch (err) {
        error_handling(err);
    }
}

function call_ajax(p_module_index, p_shelf_index, p_item_index, p_item_type, p_img_index, p_item_code, p_merch_style, p_pogcrImgMaxWidth, p_pogcrImgMaxHeight, p_pogcrImgCompressRation) {
    try {
        logDebug("function : call_ajax ; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index + "; i_item_index : " + p_item_index + "; item_type : " + p_item_type + "; img_index : " + p_img_index + "; item_code : " + p_item_code, "S");
        return new Promise(function (resolve, reject) {
            var new_merch_style;
            if (p_merch_style == "0") {
                new_merch_style = "U";
            } else if (p_merch_style == "1") {
                new_merch_style = "T";
            } else if (p_merch_style == "2") {
                new_merch_style = "C";
            } else if (p_merch_style == "3") {
                new_merch_style = "D";
            }

            var p = apex.server.process(
                "ITEM_BASE64",
                {
                    x01: p_item_code,
                    x02: p_item_type,
                    x03: new_merch_style,
                },
                {
                    dataType: "html",
                }
            );
            // When the process is done, call functions
            p.done(function (data) {
                if ($.trim(data) !== "") {
                    var details;
                    async function doSomething(Imagedata) {
                        var image = new Image();
                        image.src = "data:image/jpeg;base64," + Imagedata;
                        image.onload = function () {
                            async function imageLoad(image) {
                                details = await resizeImage(image, p_pogcrImgMaxWidth, p_pogcrImgMaxHeight, p_pogcrImgCompressRation);
                                compress_image = details.split(",");
                                g_ItemImages[p_img_index].ItemImage = compress_image[1]; //$.trim(data);
                                logDebug("function : call_ajax", "E");
                                resolve("success");
                            }
                            imageLoad(image);
                        };
                    }
                    doSomething($.trim(data));
                } else {
                    if (p_img_index == 0) {
                        g_ItemImages.splice(p_img_index, p_img_index + 1);
                    } else {
                        g_ItemImages.splice(p_img_index, 1);
                    }
                    logDebug("function : call_ajax", "E");
                    resolve("success");
                }
            });
        });
    } catch (err) {
        error_handling(err);
    }
}

async function resizeImage(p_img, p_MaxWidth, p_MaxHeight, p_compress_ratio) {
    try {
        logDebug("function : resizeImage ; MaxWidth : " + p_MaxWidth + "; MaxHeight : " + p_MaxHeight, "S");
        var canvas = document.createElement("canvas");
        var width = p_img.width;
        var height = p_img.height;
        var max_width = p_MaxWidth;
        var max_height = p_MaxHeight;
        // calculate the width and height, constraining the proportions
        if (width > height) {
            if (width > max_width) {
                //height *= max_width / width;
                height = Math.round((height *= max_width / width));
                width = max_width;
            }
        } else {
            if (height > max_height) {
                //width *= max_height / height;
                width = Math.round((width *= max_height / height));
                height = max_height;
            }
        }
        // resize the canvas and draw the image data into it
        canvas.width = width;
        canvas.height = height;
        var ctx = canvas.getContext("2d");
        ctx.drawImage(p_img, 0, 0, width, height);

        //preview.appendChild(canvas); // do the actual resized preview
        logDebug("function : resizeImage", "E");
        return canvas.toDataURL("image/jpeg", p_compress_ratio);
    } catch (err) {
        error_handling(err);
    }
}

function base64toBlob(p_base64Data, p_contentType) {
    logDebug("function : base64toBlob ; contentType : " + p_contentType, "E");
    p_contentType = p_contentType || "";
    var sliceSize = 1024;
    var byteCharacters = atob(p_base64Data);
    var bytesLength = byteCharacters.length;
    var slicesCount = Math.ceil(bytesLength / sliceSize);
    var byteArrays = new Array(slicesCount);

    for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
        var begin = sliceIndex * sliceSize;
        var end = Math.min(begin + sliceSize, bytesLength);

        var bytes = new Array(end - begin);
        for (var offset = begin, i = 0; offset < end; ++i, ++offset) {
            bytes[i] = byteCharacters[offset].charCodeAt(0);
        }
        byteArrays[sliceIndex] = new Uint8Array(bytes);
    }
    logDebug("function : base64toBlob", "E");
    return new Blob(byteArrays, {
        type: p_contentType,
    });
}

function add_item_borders(p_module_index, p_shelf_index, p_item_index, p_item_object, p_width, p_height, p_item_horiz_facing, p_pog_index, p_chest_ind) {
    //Bug-26122 - splitting the chest
    try {
        logDebug("function : add_item_borders; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index + "; i_item_index : " + p_item_index + "; width : " + p_width + "; height : " + p_height + "; item_horiz_facing : " + p_item_horiz_facing, "S");
        if (p_chest_ind == "Y") {
            //Bug-26122 - splitting the chest
            var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ChestInfo[p_shelf_index];
        } else {
            var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
        }

        var items = shelfdtl.ItemInfo[p_item_index];
        horiz_facing = p_item_horiz_facing !== -1 ? p_item_horiz_facing : items.BHoriz;
        vert_facing = items.BVert;
        var nesting = items.ItemNesting;
        var nesting_val = items.NVal;
        var cap_style = items.CapStyle;
        var cap_count = items.CapCount;
        var [org_width, org_height, item_depth, actualHeight, actualWidth, actualDepth] = get_new_orientation_dim(items.Orientation, items.OW, items.OH, items.OD);
        //var org_height = items.OH;
        //var org_width = items.OW;
        //var item_depth = items.OD;
        var real_height = items.RH;

        var rotation = shelfdtl.Rotation;
        var shelf_depth = shelfdtl.D;
        var shelfhorizgap = shelfdtl.HorizGap;
        var spread_product = shelfdtl.SpreadItem;
        var verti_values = [],
            horiz_values = [],
            nesting_negetive = "N",
            curr_width = 0,
            curr_vert_value = 0,
            curr_height = 0;
        var l_horz_start = 0 - parseFloat(p_width) / 2;
        var l_vert_start = 0 - parseFloat(p_height) / 2;
        var l_horz_end = 0 + parseFloat(p_width) / 2;
        var l_vert_end = 0 + parseFloat(p_height) / 2;
        var points = [];

        //var geometry = new THREE.Geometry();

        if (nesting_val !== 0 && (vert_facing > 1 || horiz_facing > 1) && shelfhorizgap == 0 && spread_product !== "F" && nesting !== "D") {
            if (nesting_val < 0) {
                nesting_val = nesting_val * -1;
                nesting_negetive = "Y";
            }
            if (nesting == "H") {
                if (nesting_negetive == "N") {
                    curr_vert_value = l_vert_start + org_height;
                    verti_values.push(curr_vert_value);
                } else {
                    curr_vert_value = l_vert_start;
                }
                for (i = 1; i < vert_facing; i++) {
                    curr_vert_value += parseFloat(nesting_val);
                    if (curr_vert_value < l_vert_end) {
                        verti_values.push(curr_vert_value);
                    } else {
                        break;
                    }
                }

                for (i = 0; i < verti_values.length; i++) {
                    points.push(new THREE.Vector3(l_horz_start, verti_values[i], 0));
                    points.push(new THREE.Vector3(l_horz_end, verti_values[i], 0));
                }
                if (horiz_facing > 1) {
                    curr_width = p_width / horiz_facing;

                    var curr_horiz_value = l_horz_start;
                    for (i = 1; i < horiz_facing; i++) {
                        curr_horiz_value += parseFloat(curr_width);
                        horiz_values.push(curr_horiz_value);
                    }
                    for (i = 0; i < horiz_values.length; i++) {
                        points.push(new THREE.Vector3(horiz_values[i], l_vert_start, 0));
                        points.push(new THREE.Vector3(horiz_values[i], l_vert_end, 0));
                    }
                }
            } else if (nesting == "W") {
                if (nesting_negetive == "N") {
                    curr_vert_value = l_horz_start + org_width;
                    horiz_values.push(curr_vert_value);
                } else {
                    curr_vert_value = l_horz_start;
                }
                for (i = 1; i < horiz_facing; i++) {
                    curr_vert_value += parseFloat(nesting_val);
                    if (curr_vert_value < l_horz_end) {
                        horiz_values.push(curr_vert_value);
                    } else {
                        break;
                    }
                }

                for (i = 0; i < horiz_values.length; i++) {
                    points.push(new THREE.Vector3(horiz_values[i], l_vert_start, 0));
                    points.push(new THREE.Vector3(horiz_values[i], l_vert_end, 0));
                }
                if (vert_facing > 1) {
                    curr_height = p_height / vert_facing;

                    curr_vert_value = l_vert_start;
                    for (i = 1; i < vert_facing; i++) {
                        curr_vert_value += parseFloat(curr_height);
                        if (curr_vert_value < l_vert_end) {
                            verti_values.push(curr_vert_value);
                        } else {
                            break;
                        }
                    }
                    for (i = 0; i < verti_values.length; i++) {
                        points.push(new THREE.Vector3(l_horz_start, verti_values[i], 0));
                        points.push(new THREE.Vector3(l_horz_end, verti_values[i], 0));
                    }
                }
            }
        } else if (cap_style !== "0") {
            var items_cnt = 0;
            if (cap_style == "1") {
                curr_vert_value = l_vert_start;
                for (i = 1; i <= vert_facing; i++) {
                    curr_vert_value += parseFloat(org_height);
                    if (curr_vert_value < l_vert_end) {
                        verti_values.push(curr_vert_value);
                    } else {
                        break;
                    }
                }
                for (i = 1; i < cap_count; i++) {
                    // curr_vert_value += parseFloat(item_depth);//ASA-1170
                    curr_vert_value += parseFloat(items.CapHeight); //ASA-1170
                    if (curr_vert_value < l_vert_end) {
                        verti_values.push(curr_vert_value);
                    } else {
                        break;
                    }
                }
                for (i = 0; i < verti_values.length; i++) {
                    points.push(new THREE.Vector3(l_horz_start, verti_values[i], 0));
                    points.push(new THREE.Vector3(l_horz_end, verti_values[i], 0));
                }
            } else if (cap_style == "2") {
                curr_vert_value = l_vert_start;
                for (i = 1; i <= vert_facing; i++) {
                    curr_vert_value += org_height;
                    verti_values.push(curr_vert_value);
                }
                for (i = 1; i < cap_count; i++) {
                    // curr_vert_value += parseFloat(item_depth);//ASA-1170
                    curr_vert_value += parseFloat(items.CapHeight); //ASA-1170
                    if (curr_vert_value < l_vert_end) {
                        verti_values.push(curr_vert_value);
                    } else {
                        break;
                    }
                }

                for (i = 0; i < verti_values.length; i++) {
                    points.push(new THREE.Vector3(l_horz_start, verti_values[i], 0));
                    points.push(new THREE.Vector3(l_horz_end, verti_values[i], 0));
                }
            } else if (cap_style == "3") {
                curr_vert_value = l_vert_start + org_height;
                verti_values.push(curr_vert_value);
                for (i = 1; i < cap_count; i++) {
                    // curr_vert_value += parseFloat(item_depth);//ASA-1170
                    curr_vert_value += parseFloat(items.CapHeight); //ASA-1170
                    if (curr_vert_value < l_vert_end) {
                        verti_values.push(curr_vert_value);
                    } else {
                        break;
                    }
                }

                for (i = 0; i < verti_values.length; i++) {
                    points.push(new THREE.Vector3(l_horz_start, verti_values[i], 0));
                    points.push(new THREE.Vector3(l_horz_end, verti_values[i], 0));
                }
            }
            if (horiz_facing > 1) {
                curr_width = p_width / horiz_facing;

                var curr_horiz_value = l_horz_start;
                for (i = 1; i < horiz_facing; i++) {
                    curr_horiz_value += parseFloat(curr_width);
                    if (curr_horiz_value < l_vert_end) {
                        horiz_values.push(curr_horiz_value);
                    } else {
                        break;
                    }
                }
                for (i = 0; i < horiz_values.length; i++) {
                    points.push(new THREE.Vector3(horiz_values[i], l_vert_start, 0));
                    points.push(new THREE.Vector3(horiz_values[i], l_vert_end, 0));
                }
            }
        } else {
            if (vert_facing > 1) {
                curr_height = p_height / vert_facing;
                curr_vert_value = l_vert_start;
                for (i = 1; i < vert_facing; i++) {
                    curr_vert_value += parseFloat(curr_height);
                    verti_values.push(curr_vert_value);
                }
                for (i = 0; i < verti_values.length; i++) {
                    points.push(new THREE.Vector3(l_horz_start, verti_values[i], 0));
                    points.push(new THREE.Vector3(l_horz_end, verti_values[i], 0));
                }
            }
            if (horiz_facing > 1) {
                curr_width = p_width / horiz_facing;

                var curr_horiz_value = l_horz_start;
                for (i = 1; i < horiz_facing; i++) {
                    curr_horiz_value += parseFloat(curr_width);
                    horiz_values.push(curr_horiz_value);
                }
                for (i = 0; i < horiz_values.length; i++) {
                    points.push(new THREE.Vector3(horiz_values[i], l_vert_start, 0));
                    points.push(new THREE.Vector3(horiz_values[i], l_vert_end, 0));
                }
            }
        }
        let geometry = new THREE.BufferGeometry().setFromPoints(points);
        var material = new THREE.LineBasicMaterial({
            color: 0x000000,
        });

        var line = new THREE.LineSegments(geometry, material);

        line.position.z = 0.0006;
        p_item_object.add(line);
        logDebug("function : add_item_borders", "E");
    } catch (err) {
        error_handling(err);
    }
}

async function add_items_with_image(p_uuid, p_width, p_height, p_depth, p_color, p_x, p_y, p_z, p_module_index, p_shelf_index, p_item_index, p_horiz_facing, p_vert_facing, p_item_code, p_item_type, p_angle, p_recreate, p_fresh_item, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_pog_index) {
    logDebug("function : add_items_with_image; uuid : " + p_uuid + "; width : " + p_width + "; height : " + p_height + "; depth : " + p_depth + "; color : " + p_color + "; x : " + p_x + "; y : " + p_y + "; z : " + p_z + "; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index + "; i_item_index : " + p_item_index + "; horiz_facing : " + p_horiz_facing + "; vert_facing : " + p_vert_facing + "; item_code : " + p_item_code + "; item_type : " + p_item_type + "; angle : " + p_angle + "; recreate : " + p_recreate, "S");
    try {
        var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
        var itemdepth = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].D;
        if (g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ObjType == "SHELF" || g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ObjType == "HANGINGBAR") {
            shelfdtl.AvlSpace = wpdSetFixed(shelfdtl.AvlSpace - p_width); //.toFixed(3));
        }
        if (g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ObjType == "ROD") {
            shelfdtl.AvlSpace = wpdSetFixed(shelfdtl.D - itemdepth); //.toFixed(3));
        }
        var spread_product = shelfdtl.SpreadItem; //Prasanna get spread product if combine, because first shelf in combine would be different.
        var [currCombinationIndex, currShelfCombIndx] = getCombinationShelf(p_pog_index, shelfdtl.Shelf);
        if (currCombinationIndex !== -1) {
            spread_product = g_combinedShelfs[currCombinationIndex].SpreadItem;
        }
        p_vert_facing = parseInt(p_vert_facing); //ASA-1273 -- temporary fix. need to remove once found out where string is being passed to this function.
        var item_info = shelfdtl.ItemInfo[p_item_index];
        var cap_merch = item_info.CapMerch;
        var cap_orient = item_info.CapOrientaion;
        var cap_detail_arr = []; //Regression issue 20240510
        var cap_details = g_orientation_json[cap_orient];
        if (typeof cap_details !== "undefined") {
            //TASK-25959 Kush added DUE TO AFTER MASS UPDATE WE NEED CAPHEIGHT TO BE ADDED
            cap_detail_arr = cap_details.split("###"); //Regression issue 20240510
            var object = g_world.getObjectById(item_info.ObjID);
            g_world.remove(object);
        }

        var item_orientation = item_info.Orientation;
        var details = g_orientation_json[item_orientation];
        var cap_style = item_info.CapStyle;
        //ASA-1970 Start
        var horiz_facing = item_info.BHoriz;
        if (item_info.CrushHoriz > 0 && horiz_facing > 1 && spread_product == "F") {
            p_width = item_info.RW * (1 - item_info.CrushHoriz / 100) + item_info.SpreadItem * (horiz_facing - 1);
        }
        //ASA-1970 End
        var [org_width, org_height, org_depth, actualHeight, actualWidth, actualDepth] = get_new_orientation_dim(item_info.Orientation, item_info.OW, item_info.OH, item_info.OD, org_width, org_height, org_depth, item_info.Item);
        if (item_info.CrushHoriz > 0) {
            org_width = item_info.W / item_info.BHoriz;
        }
        if (item_info.CrushVert > 0) {
            // org_height = item_info.RH / item_info.BVert; //ASA-1410 issue 13
            org_height = item_info.H / item_info.BVert; //ASA-1933 Issue1
        }
        var details_arr = details.split("###");
        var pegID = item_info.PegID;

        return new Promise(function (resolve, reject) {
            var item_info = shelfdtl.ItemInfo[p_item_index];
            var nesting_val = item_info.NVal;
            var rotation = shelfdtl.Rotation;
            var slope = shelfdtl.Slope;
            var merch_style = item_info.MerchStyle;
            if (p_merchStyle == "0") {
                merch_style = "U";
            } else if (p_merchStyle == "1") {
                merch_style = "T";
            } else if (p_merchStyle == "2") {
                merch_style = "C";
            } else if (p_merchStyle == "3") {
                merch_style = "D";
            }
            var img_exists = "N";
            var cap_index = -1;
            var img_index = -1;
            if (p_pogcrLoadImgFrom == "DB") {
                var j = 0;
                for (const images_arr of g_ItemImages) {
                    if (p_item_code == images_arr.Item && details_arr[0] == images_arr.Orientation && images_arr.ItemImage !== null && images_arr.MerchStyle == item_info.MerchStyle) {
                        img_exists = "Y";
                        img_index = j;
                        break; //return false;
                    }
                    j++;
                }
                var j = 0;
                for (const images_arr of g_ItemImages) {
                    if (p_item_code == images_arr.Item && cap_detail_arr[0] == images_arr.Orientation && images_arr.ItemImage !== null && images_arr.MerchStyle == cap_merch) {
                        cap_index = j;
                        break; //return false;
                    }
                    j++;
                }
            } else {
                img_exists = "Y";
            }

            if (img_exists == "Y") {
                // Set image source
                if (p_pogcrLoadImgFrom == "DB") {
                    // Create an image
                    var image = new Image(); // or document.createElement('img' );
                    // Create texture
                    var tex = new THREE.Texture(image);
                    tex.format = THREE.RGBAFormat;
                    // On image load, update texture
                    image.onload = () => {
                        tex.needsUpdate = true;
                    };
                    image.src = "data:image/jpeg;base64," + g_ItemImages[img_index].ItemImage;

                    if (cap_index !== -1) {
                        var image_cap = new Image(); // or document.createElement('img' );
                        // Create texture
                        var texture_cap = new THREE.Texture(image_cap);
                        texture_cap.format = THREE.RGBAFormat;
                        // On image load, update texture
                        image_cap.onload = () => {
                            texture_cap.needsUpdate = true;
                        };
                        image_cap.src = "data:image/jpeg;base64," + g_ItemImages[cap_index].ItemImage;
                        var material_cap = new THREE.MeshStandardMaterial({
                            map: texture_cap,
                        });
                    }
                } else {
                    console.log("Wrong Parameter value for pogcrLoadImgFrom", p_pogcrLoadImgFrom);
                }

                if (rotation !== 0 || slope !== 0) {
                    var geometry = new THREE.BoxBufferGeometry(p_width, p_height, p_depth);
                    var material = new THREE.MeshBasicMaterial({
                        map: tex,
                        transparent: true,
                    });
                    if (nesting_val == 0) {
                        tex.wrapS = THREE.RepeatWrapping;
                        tex.wrapT = THREE.RepeatWrapping;
                        if (p_angle == 90 || p_angle == 270) {
                            tex.repeat.set(p_vert_facing, p_horiz_facing);
                        } else {
                            tex.repeat.set(p_horiz_facing, p_vert_facing);
                        }
                        if (p_angle == 90) {
                            p_angle = 270;
                        } else if (p_angle == 270) {
                            p_angle = 90;
                        }
                        tex.rotation = (p_angle * Math.PI) / 180;
                    }
                    var items = new THREE.Mesh(geometry, material); //to make it standard

                    var selectedObject = g_world.getObjectById(shelfdtl.SObjID);
                    if (p_recreate == "N") {
                        p_x = wpdSetFixed(0 - (shelfdtl.W / 2 - p_width / 2 - item_info.Distance));
                        p_y = wpdSetFixed(shelfdtl.H / 2 + p_height / 2);
                        p_z = wpdSetFixed(shelfdtl.D / 2 - p_depth / 2);

                        item_info.RotationX = p_x;
                        item_info.RotationY = p_y;
                        item_info.RotationZ = p_z;
                    }

                    items.applyMatrix4(new THREE.Matrix4().makeTranslation(p_x, p_y, p_z));

                    g_scene.updateMatrixWorld();
                    items.matrixAutoUpdate = false;
                    if (typeof selectedObject !== "undefined") {
                        items.applyMatrix4(selectedObject.matrix);
                    }
                } else {
                    var geometry = new THREE.BoxGeometry(p_width, p_height, 0.001);
                    var material = new THREE.MeshStandardMaterial({
                        map: tex,
                    });
                    if (spread_product == "F") {
                        var colorValue = parseInt(p_color.replace("#", "0x"), 16);
                        var hex_decimal = new THREE.Color(colorValue);
                        var items = new THREE.Mesh( //added var to make it standard
                            new THREE.BoxGeometry(p_width, p_height, 0.001),
                            new THREE.MeshBasicMaterial({
                                color: hex_decimal,
                                transparent: true,
                                opacity: 0,
                            })
                        );
                        if (nesting_val == 0 && cap_style == "0") {
                            if (p_angle == 90 || p_angle == 270) {
                                tex.repeat.set(p_vert_facing, 1);
                            } else {
                                tex.repeat.set(1, p_vert_facing);
                            }
                        }
                        tex.wrapS = THREE.RepeatWrapping;
                        tex.wrapT = THREE.RepeatWrapping;
                        if (p_angle == 90) {
                            p_angle = 270;
                        } else if (p_angle == 270) {
                            p_angle = 90;
                        }
                        tex.rotation = (p_angle * Math.PI) / 180;
                        var img_item = [];
                        var next_start = 0;
                        var item_info = item_info;
                        var spread = item_info.SpreadItem;
                        if (cap_style == "0") {
                            for (k = 0; k < p_horiz_facing; k++) {
                                if (p_vert_facing > 1) {
                                    var geometry1 = new THREE.BoxGeometry(org_width, p_height, 0.001);
                                } else {
                                    var geometry1 = new THREE.BoxGeometry(org_width, org_height, 0.001);
                                }
                                img_item.push(new THREE.Mesh(geometry1, material));
                                items.add(img_item[img_item.length - 1]);
                                if (k == 0) {
                                    //ASA-1970 Issue2 Start
                                    // next_start = -(item_info.W / 2) + org_width + spread;
                                    // img_item[0].position.x = -(item_info.W / 2) + org_width / 2;
                                    next_start = -((item_info.CrushHoriz > 0 ? p_width : item_info.W) / 2) + org_width + spread;
                                    img_item[0].position.x = -((item_info.CrushHoriz > 0 ? p_width : item_info.W) / 2) + org_width / 2;
                                    //ASA-1970 Issue2 End
                                } else {
                                    img_item[k].position.x = next_start + org_width / 2;
                                    next_start = next_start + org_width + spread;
                                }
                            }
                        } else {
                            var vert_loop = p_vert_facing + item_info.CapCount;
                            var vert_start = 0;
                            var item_depth = item_info.OD;
                            var capHeight = item_info.CapHeight; //ASA-1170
                            console.log(item_info.CapHeight, capHeight);
                            var vert_facing_cnt = p_vert_facing;
                            var new_z = 0.001;
                            var child_uuid = "facings";
                            for (p = 0; p < vert_loop; p++) {
                                var next_start = 0;
                                var new_y = -1;
                                if (p == 0) {
                                    vert_start = -(item_info.H / 2) + org_height;
                                    new_y = -(item_info.H / 2) + org_height / 2;
                                    vert_facing_cnt = vert_facing_cnt - 1;
                                } else {
                                    if (vert_facing_cnt > 0) {
                                        new_y = vert_start + org_height / 2;
                                        vert_start = vert_start + org_height;
                                        vert_facing_cnt = vert_facing_cnt - 1;
                                        child_uuid = "facings";
                                    } else {
                                        var calc_height = vert_start + capHeight; //item_depth;
                                        new_y = calc_height - org_height / 2;
                                        vert_start = calc_height;
                                        new_z = new_z - 0.00001;
                                        child_uuid = "cap";
                                    }
                                }
                                for (k = 0; k < p_horiz_facing; k++) {
                                    var geometry1 = new THREE.BoxGeometry(org_width, org_height, 0.001);

                                    img_item.push(new THREE.Mesh(geometry1, material));
                                    img_item[img_item.length - 1].uuid = child_uuid;
                                    items.add(img_item[img_item.length - 1]);
                                    if (k == 0) {
                                        next_start = -(item_info.W / 2) + org_width + spread;
                                        img_item[img_item.length - 1].position.x = -(item_info.W / 2) + org_width / 2;
                                    } else {
                                        img_item[img_item.length - 1].position.x = next_start + org_width / 2;
                                        next_start = next_start + org_width + spread;
                                    }
                                    img_item[img_item.length - 1].position.y = new_y;
                                    //img_item[img_item.length - 1].position.z = new_z; //ASA-1766 Task 2
                                }
                            }
                        }
                    } else {
                        if (nesting_val == 0 && cap_style == "0") {
                            if (p_angle == 90 || p_angle == 270) {
                                tex.repeat.set(p_vert_facing, p_horiz_facing);
                            } else {
                                tex.repeat.set(p_horiz_facing, p_vert_facing);
                            }
                        }
                        tex.wrapS = THREE.RepeatWrapping;
                        tex.wrapT = THREE.RepeatWrapping;
                        if (p_angle == 90) {
                            p_angle = 270;
                        } else if (p_angle == 270) {
                            p_angle = 90;
                        }
                        tex.rotation = (p_angle * Math.PI) / 180;

                        if (cap_style == "0") {
                            items = new THREE.Mesh(geometry, material);
                        } else {
                            var colorValue = parseInt(p_color.replace("#", "0x"), 16);
                            var hex_decimal = new THREE.Color(colorValue);
                            items = new THREE.Mesh(
                                new THREE.BoxGeometry(p_width, p_height, 0.001),
                                new THREE.MeshBasicMaterial({
                                    color: hex_decimal,
                                    transparent: false, //true,
                                    opacity: 1, //0,
                                })
                            );
                            var img_item = [];
                            var next_start = 0;
                            var item_info = item_info;
                            var vert_loop = p_vert_facing + item_info.CapCount;
                            var vert_start = 0;
                            var item_depth = item_info.OD;
                            var capHeight = item_info.CapHeight; //ASA-1170
                            var vert_facing_cnt = p_vert_facing;
                            var new_z = 0.001;
                            var child_uuid = "facings";
                            for (p = 0; p < vert_loop; p++) {
                                var next_start = 0;
                                var new_y = -1;
                                if (p == 0) {
                                    vert_start = -(item_info.H / 2) + org_height;
                                    new_y = -(item_info.H / 2) + org_height / 2;
                                    vert_facing_cnt = vert_facing_cnt - 1;
                                } else {
                                    if (vert_facing_cnt > 0) {
                                        new_y = vert_start + org_height / 2;
                                        vert_start = vert_start + org_height;
                                        vert_facing_cnt = vert_facing_cnt - 1;
                                        child_uuid = "facings";
                                    } else {
                                        var calc_height = vert_start + capHeight; //item_depth;
                                        new_y = calc_height - capHeight / 2;
                                        vert_start = calc_height;
                                        new_z = new_z - 0.00001;
                                        child_uuid = "cap";
                                    }
                                }

                                for (k = 0; k < p_horiz_facing; k++) {
                                    var new_mat;
                                    if (p < p_vert_facing) {
                                        var geometry1 = new THREE.BoxGeometry(org_width, org_height, 0.001);
                                        new_mat = material;
                                    } else {
                                        var geometry1 = new THREE.BoxGeometry(org_width, capHeight, 0.001);
                                        if (cap_index !== -1) {
                                            texture_cap.wrapS = THREE.RepeatWrapping;
                                            texture_cap.wrapT = THREE.RepeatWrapping;
                                            p_angle = cap_detail_arr[1];
                                            if (cap_detail_arr[1] == 90) {
                                                p_angle = 270;
                                            } else if (cap_detail_arr[1] == 270) {
                                                p_angle = 90;
                                            }
                                            texture_cap.rotation = (p_angle * Math.PI) / 180;
                                        }
                                        new_mat = cap_index !== -1 ? material_cap : material;
                                    }
                                    img_item.push(new THREE.Mesh(geometry1, new_mat));
                                    img_item[img_item.length - 1].uuid = child_uuid;
                                    items.add(img_item[img_item.length - 1]);
                                    if (k == 0) {
                                        next_start = -(item_info.W / 2) + org_width;
                                        img_item[img_item.length - 1].position.x = -(item_info.W / 2) + org_width / 2;
                                    } else {
                                        img_item[img_item.length - 1].position.x = next_start + org_width / 2;
                                        next_start = next_start + org_width;
                                    }
                                    img_item[img_item.length - 1].position.y = new_y;
                                    //img_item[img_item.length - 1].position.z = new_z; //ASA-1766 Task 2
                                }
                            }
                        }
                    }

                    items.position.x = p_x;
                    if (shelfdtl.ObjType == "PEGBOARD" || isShelfOnPegboard(shelfdtl.X, shelfdtl.Y, p_module_index, p_pog_index, shelfdtl, g_pog_json)) {
                        //ASA-1769 Issue 3
                        items.position.z = 0.016;
                    } else if (shelfdtl.ObjType == "PALLET") {
                        items.position.z = 0.001 + shelfdtl.D / 1000 - item_info.Z / 1000;
                    } else {
                        items.position.z = 0.001 + shelfdtl.D / 1000; // ASA- 1573 Issue 1 (0.001) 0.005,ASA- 1608 Issue 1
                    }
                    items.position.y = p_y;
                }
                material.transparent = true;
                items.uuid = p_uuid;
                g_world.add(items);
                var l_wireframe_id = add_wireframe(items, 2);
                items.WFrameID = l_wireframe_id;
                items.WireframeObj.material.transparent = true;
                items.WireframeObj.material.opacity = 0.0025;
                var return_val = update_item_label(p_module_index, p_shelf_index, p_item_index, items, g_show_item_label, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pog_index, "N"); //Bug-26122 - splitting the chest
                //ASA 1847.4 Issue 2 Start
                if (g_item_vertical_text_display === "Y") {
                    var new_camera = get_canvas_camera("LABEL");
                    var retval = show_single_item_desc(p_module_index, p_shelf_index, p_item_index, g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index], items, g_camera, p_pogcrItemLabelColor, p_pogcrDisplayItemInfo, p_pog_index);
                }
                //ASA 1847.4 Issue 2 End               
                items.ImageExists = "Y";
            } else {
                var colorValue = parseInt(p_color.replace("#", "0x"), 16);
                var hex_decimal = new THREE.Color(colorValue);
                if (rotation !== 0 || slope !== 0) {
                    var items = new THREE.Mesh( //added var to make it standard
                        new THREE.BoxGeometry(p_width, p_height, p_depth),
                        new THREE.MeshBasicMaterial({
                            color: hex_decimal,
                        })
                    );

                    var selectedObject = g_world.getObjectById(shelfdtl.SObjID);

                    if (p_recreate == "N") {
                        p_x = wpdSetFixed(0 - (shelfdtl.W / 2 - p_width / 2 - item_info.Distance));
                        p_y = wpdSetFixed(shelfdtl.H / 2 + p_height / 2);
                        p_z = wpdSetFixed(shelfdtl.D / 2 - p_depth / 2);

                        item_info.RotationX = p_x;
                        item_info.RotationY = p_y;
                        item_info.RotationZ = p_z;
                    }

                    items.applyMatrix4(new THREE.Matrix4().makeTranslation(p_x, p_y, p_z));
                    g_scene.updateMatrixWorld();
                    items.matrixAutoUpdate = false;
                    if (typeof selectedObject !== "undefined") {
                        items.applyMatrix4(selectedObject.matrix);
                    }
                } else {
                    if (spread_product == "F" && p_horiz_facing > 1) {
                        var items = new THREE.Mesh( //added var to make it standard
                            new THREE.BoxGeometry(p_width, p_height, 0.001),
                            new THREE.MeshBasicMaterial({
                                color: hex_decimal,
                                transparent: true,
                                opacity: 0,
                            })
                        );
                        var img_item = [];
                        var next_start = 0;
                        var material = new THREE.MeshStandardMaterial({
                            color: hex_decimal,
                        });
                        var item_info = item_info;
                        var spread = item_info.SpreadItem; // / (horiz_facing - 1) : item_info.SpreadItem;
                        for (k = 0; k < p_horiz_facing; k++) {
                            var final_width = (final_height = 0);
                            if (p_vert_facing > 1 || cap_style !== "0") {
                                var geometry1 = new THREE.BoxGeometry(org_width, p_height, 0.001);
                                final_width = org_width;
                                final_height = p_height;
                            } else {
                                var geometry1 = new THREE.BoxGeometry(org_width, org_height, 0.001);
                                final_width = org_width;
                                final_height = org_height;
                            }
                            img_item.push(new THREE.Mesh(geometry1, material));
                            var l_wireframe_id = add_wireframe(img_item[img_item.length - 1], 2);
                            add_item_borders(p_module_index, p_shelf_index, p_item_index, img_item[img_item.length - 1], final_width, final_height, 1, p_pog_index, "N"); //Bug-26122 - splitting the chest
                            items.add(img_item[img_item.length - 1]);
                            if (k == 0) {
                                //ASA-1970 Start
                                // next_start = -(item_info.W / 2) + org_width + spread;
                                // img_item[0].position.x = -(item_info.W / 2) + org_width / 2;
                                next_start = -((item_info.CrushHoriz > 0 ? p_width : item_info.W) / 2) + org_width + spread;
                                img_item[0].position.x = -((item_info.CrushHoriz > 0 ? p_width : item_info.W) / 2) + org_width / 2;
                                //ASA-1970 End
                            } else {
                                img_item[k].position.x = next_start + org_width / 2;
                                next_start = next_start + org_width + spread;
                            }
                        }
                    } else {
                        var items = new THREE.Mesh( //using local variable
                            new THREE.BoxGeometry(p_width, p_height, 0.001),
                            new THREE.MeshStandardMaterial({
                                color: hex_decimal,
                            })
                        );
                    }

                    items.position.x = p_x;
                    if (shelfdtl.ObjType == "PEGBOARD" || isShelfOnPegboard(shelfdtl.X, shelfdtl.Y, p_module_index, p_pog_index, shelfdtl, g_pog_json)) {
                        //ASA-1769 Issue 3
                        items.position.z = 0.016;
                    } else if (shelfdtl.ObjType == "PALLET") {
                        items.position.z = 0.001 + shelfdtl.D / 1000 - item_info.Z / 1000;
                    } else {
                        items.position.z = 0.001 + shelfdtl.D / 1000; // ASA- 1573 Issue 1 (0.001), ASA- 1608 Issue 1
                    }
                    items.position.y = p_y;
                }
                items.uuid = p_uuid;

                shelfdtl.AvlSpace = wpdSetFixed(shelfdtl.AvlSpace - p_width); //.toFixed(3));

                var l_wireframe_id = add_wireframe(items, 2);
                items.WFrameID = l_wireframe_id;
                g_world.add(items);
                if (spread_product !== "F" || (spread_product == "F" && p_horiz_facing == 1)) {
                    add_item_borders(p_module_index, p_shelf_index, p_item_index, items, p_width, p_height, -1, p_pog_index, "N"); //Bug-26122 - splitting the chest
                }
                var return_val = update_item_label(p_module_index, p_shelf_index, p_item_index, items, g_show_item_label, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pog_index, "N"); //Bug-26122 - splitting the chest
                var new_camera = get_canvas_camera("LABEL");
                var retval = show_single_item_desc(p_module_index, p_shelf_index, p_item_index, g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index], items, g_camera, p_pogcrItemLabelColor, p_pogcrDisplayItemInfo, p_pog_index);
                items.ImageExists = "N";
            }
            var item_info = item_info;
            items.ItemID = item_info.Item;
            items.Description = item_info.Desc;
            items.HorizFacing = item_info.BHoriz;
            items.VertFacing = item_info.BVert;
            items.DFacing = item_info.BaseD;
            items.ClassName = item_info.ClassName;
            items.DimUpdate = item_info.DimUpdate;
            items.SellingPrice = item_info.SellingPrice;
            items.SalesUnit = item_info.SalesUnit;
            items.NetSales = item_info.NetSales;
            items.CogsAdj = item_info.CogsAdj;
            items.RegMovement = item_info.RegMovement;
            items.AvgSales = item_info.AvgSales;
            items.ItemStatus = item_info.ItemStatus;
            items.CDTLvl1 = item_info.CDTLvl1; //ASA-1130
            items.CDTLvl2 = item_info.CDTLvl2; //ASA-1130
            items.CDTLvl3 = item_info.CDTLvl3; //ASA-1130
            items.ActualDPP = item_info.ActualDPP; //ASA-1182 ASA-1277-(3)
            items.StoreSOH = item_info.StoreSOH; //ASA-1182 ASA-1277-(3)
            items.DPPLoc = item_info.DPPLoc; //ASA-1308 Task-3
            items.StoreNo = item_info.StoreNo; //ASA-1277-(3)
            items.WeeksOfInventory = item_info.WeeksOfInventory; //ASA-1277-(3)
            //ASA-2013 Start
            items.ShelfPrice = item_info.ShelfPrice;
            items.PromoPrice = item_info.PromoPrice;
            items.DiscountRate = item_info.DiscountRate;
            items.PriceChangeDate = item_info.PriceChangeDate;
            items.WeeksOfInventory = item_info.WeeksOfInventory;
            items.Qty = item_info.Qty;
            items.WhStock = item_info.WhStock;
            items.StoreStock = item_info.StoreStock;
            items.StockIntransit = item_info.StockIntransit;
            //ASA-2013 End
            items.GrossProfit = item_info.GrossProfit;
            items.WeeksCount = item_info.WeeksCount;
            items.MovingItem = item_info.MovingItem;
            items.Profit = item_info.Profit;
            items.TotalMargin = item_info.TotalMargin;
            items.W = item_info.W;
            items.H = item_info.H;
            items.D = item_info.D;
            items.Color = item_info.Color;
            items.Barcode = item_info.Barcode;
            items.Desc = item_info.Desc;
            items.Brand = item_info.Brand;
            items.BrandType = item_info.BrandType; //ASA-1113
            items.Group = item_info.Group;
            items.Dept = item_info.Dept;
            items.Class = item_info.Class;
            items.SubClass = item_info.SubClass;
            items.StdUOM = item_info.StdUOM;
            items.SizeDesc = item_info.SizeDesc;
            items.Supplier = item_info.Supplier;
            items.SupplierName = item_info.SupplierName;
            items.LocID = item_info.LocID;
            items.Supplier = item_info.Supplier;
            items.ItemDim = g_msg_h + ": " + (item_info.OH * 100).toFixed(2) + " (" + g_msg_Sq + " : " + item_info.CrushVert + ")" + " " + g_msg_w + ": " + (item_info.OW * 100).toFixed(2) + " (" + g_msg_Sq + " : " + item_info.CrushHoriz + ")" + " " + g_msg_d + ": " + (item_info.OD * 100).toFixed(2) + " (" + g_msg_Sq + " : " + item_info.CrushD + ")"; //ASA-1407 Task 1-E ,//ASA-1407 issue 5
            items.OrientationDesc = item_info.OrientationDesc;
            items.StoreCnt = item_info.StoreCnt;
            items.RotationDegree = rotation;
            items.OW = item_info.OW * 100;
            items.OH = item_info.OH * 100;
            items.OD = item_info.OD * 100;
            items.CrushW = item_info.CrushHoriz; //ASA-1758
            items.CrushH = item_info.CrushVert; //ASA-1758
            items.CrushD = item_info.CrushD; //ASA-1758
            items.Shelf = shelfdtl.Shelf;
            items.Rotation = 0;
            items.ItemSlope = 0;
            items.UnitperCase = item_info.UnitperCase;
            items.UnitperTray = item_info.UnitperTray;
            items.DescSecond = item_info.DescSecond;
            items.DfacingUpd = item_info.DfacingUpd;
            items.ItmDescChi = item_info.ItmDescChi; //ASA-1407 Task 1,//ASA-1407 issue 5
            items.ItmDescEng = item_info.ItmDescEng; //ASA-1273 Prasanna
            //items.ItmDescEng = items.Brand + " " + items.Desc + " " + items.SizeDesc;
            items.TotalUnitsCalc = item_info.BHoriz * item_info.BVert * item_info.BaseD;
            items.PkSiz = item_info.PkSiz;
            items.CapFacing = item_info.CapFacing; //ASA-1341
            items.CapDepth = item_info.CapDepth; //ASA-1341
            items.CapHorz = item_info.CapHorz; //ASA-1341
            var cap_capacity = item_info.CapFacing * item_info.CapDepth * item_info.CapHorz; //ASA-1273 Prasanna
            items.Cpct = item_info.BHoriz * item_info.BVert * item_info.BaseD + (!isNaN(cap_capacity) ? cap_capacity : 0);
            items.Brand_Category = item_info.Brand_Category; //ASA-1158-S
            items.Uda_item_status = item_info.Uda_item_status;
            items.Gobecobrand = item_info.Gobecobrand;
            items.Internet = item_info.Internet; //ASA-1158-E
            items.Categ = item_info.Categ;
            if (typeof item_info.SizeDesc !== "undefined" && item_info.SizeDesc !== "") {
                ////Regression issue 10
                var det_arr = item_info.SizeDesc.split("*");
            } else {
                var det_arr = "";
            }

            items.GoGreen = item_info.GoGreen;
            items.ItemSize = item_info.ItemSize;
            items.SplrLbl = item_info.SplrLbl;
            items.COO = item_info.COO;
            items.EDLP = item_info.EDLP;
            items.LoGrp = item_info.LoGrp;
            items.SqzPer = (typeof item_info.CrushHoriz !== "undefined" ? item_info.CrushHoriz : 0) + ":" + (typeof item_info.CrushVert !== "undefined" ? item_info.CrushVert : 0) + ":" + (typeof item_info.CrushD !== "undefined" ? item_info.CrushD : 0);
            items.InternationalRng = item_info.InternationalRng;
            items.NewItem = item_info.NewItem; //ASA-1182
            items.LiveNewItem = item_info.LiveNewItem; //ASA-1250
            items.DaysOfSupply = item_info.DaysOfSupply;
            items.CapDepthChanged = item_info.CapDepthChanged; //ASA-1273
            items.Orientation = item_info.Orientation; //ASA-1289
            items.MassCrushH = item_info.MassCrushH; //Task-02_25977 KUSH FOR MASS UPDATE FOR AUTO CRUSH IN CHEST
            items.MassCrushV = item_info.MassCrushV; //Task-02_25977 KUSH FOR MASS UPDATE FOR AUTO CRUSH IN CHEST
            items.MassCrushD = item_info.MassCrushD; //Task-02_25977 KUSH FOR MASS UPDATE FOR AUTO CRUSH IN CHEST
            items.UDA751 = item_info.UDA751; //ASA-1407 Task 1 -S
            items.UDA755 = item_info.UDA755; //ASA-1407 Task 1 -E
            items.MPogDepthFacings = item_info.MPogDepthFacings; //ASA-1408
            items.MPogHorizFacings = item_info.MPogHorizFacings; //ASA-1408
            items.MPogVertFacings = item_info.MPogVertFacings; //ASA-1408
            items.Status = item_info.Status; //ASA-1407 issue 5
            items.MerchStyle = item_info.MerchStyle; //ASA-1605
            items.CapMerch = item_info.CapMerch; //ASA-1605
            //ASA-1640 Start
            items.ItemCondition = item_info.ItemCondition;
            items.AUR = item_info.AUR;
            items.ItemRanking = item_info.ItemRanking;
            items.WeeklySales = item_info.WeeklySales;
            items.WeeklyNetMargin = item_info.WeeklyNetMargin;
            items.WeeklyQty = item_info.WeeklyQty;
            items.NetMarginPercent = item_info.NetMarginPercent;
            items.CumulativeNM = item_info.CumulativeNM;
            items.TOP80B2 = item_info.TOP80B2;
            items.ItemBrandC = item_info.ItemBrandC;
            items.ItemPOGDept = item_info.ItemPOGDept;
            items.ItemRemark = item_info.ItemRemark;
            items.RTVStatus = item_info.RTVStatus;
            items.Pusher = item_info.Pusher;
            items.Divider = item_info.Divider;
            items.BackSupport = item_info.BackSupport;
            //ASA-1640 End
            items.CWPerc = item_info.CWPerc; //ASA-1640 #5
            items.CHPerc = item_info.CHPerc; //ASA-1640 #5
            items.CDPerc = item_info.CDPerc; //ASA-1640 #5

            items.OOSPerc = item_info.OOSPerc; //ASA-1688 Added for OOS%
            items.InitialItemDesc = item_info.InitialItemDesc; //ASA-1734 Issue 1
            items.InitialBrand = item_info.InitialBrand; //ASA-1787 Request #6
            items.InitialBarcode = item_info.InitialBarcode; //ASA-1787 Request #6
            items.RotationFlag = rotation !== 0 || slope !== 0 ? "Y" : "N";

            // 1902 Available space should be calculated
            if (shelfdtl.ObjType == "SHELF") {
                var k = 0;
                var sum_width = 0;
                for (const items of shelfdtl.ItemInfo) {
                    sum_width += items.W;
                    k++;
                }
                if (shelfdtl.SpreadItem !== "E") {
                    var horizGap = shelfdtl.HorizGap ? shelfdtl.HorizGap : 0;
                    var horizGapSpace = (k > 1) ? horizGap * (k - 1) : 0;
                    sum_width += horizGapSpace;
                }
                shelfdtl.AvlSpace = wpdSetFixed((shelfdtl.W - sum_width) * 100); //.toFixed(3));
                var shelfObj = g_world.getObjectById(shelfdtl.SObjID);
                if (typeof shelfObj !== "undefined" && shelfdtl.ObjType == "SHELF") {
                    shelfObj.AvlSpace = shelfdtl.AvlSpace;
                }
            }
            //ASA-1970 Start
            //ASA-1946
            // if (shelfdtl.SpreadItem == "F" && shelfdtl.ItemInfo?.length == 1 && (shelfdtl.ObjType == "SHELF" || shelfdtl.ObjType == "HANGINGBAR")) {
            //     var itemWidth = shelfdtl.ItemInfo[0]?.CrushHoriz > 0 ? shelfdtl.ItemInfo[0]?.W : shelfdtl.ItemInfo[0]?.RW;  //ASA-1946 Issue1
            // 	shelfdtl.AvlSpace = wpdSetFixed((shelfdtl.W - itemWidth) * 100);
            // 	if (typeof shelfObj !== "undefined" && shelfdtl.ObjType == "SHELF") {
            // 		shelfObj.AvlSpace = shelfdtl.AvlSpace;
            // 	}
            // }
            if (shelfdtl.SpreadItem == "F" && (shelfdtl.ObjType == "SHELF" || shelfdtl.ObjType == "HANGINGBAR")) {
                var itemWidth = 0;
                for (const item of shelfdtl.ItemInfo) {
                    // itemWidth += item?.RW;
                    itemWidth += item?.CrushHoriz > 0 ? item?.W : item?.RW;
                }
                shelfdtl.AvlSpace = wpdSetFixed((shelfdtl.W - itemWidth) * 100);
                if (typeof shelfObj !== "undefined" && shelfdtl.ObjType == "SHELF") {
                    shelfObj.AvlSpace = shelfdtl.AvlSpace;
                }
            }
            //ASA-1970 End
            var selectedObject = g_world.getObjectById(items.id);
            if (items.DimUpdate == "E" && typeof items.DimUpdate !== "undefined") {
                selectedObject.BorderColour = g_dim_error_color;
                selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
            } else if (nvl(items.Status) == "N") {
                selectedObject.BorderColour = g_status_error_color;
                selectedObject.Status = "N";
                selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
            } else if (nvl(items.MovingItem) == "No" && g_pogcr_auto_hlite_non_mv_item == "Y") {
                selectedObject.BorderColour = g_nonMovingItemColor;
                selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
            } else {
                if (nvl(items.OOSPerc) > 80 && g_pogcr_enbl_oos_border == "Y") {
                    selectedObject.BorderColour = g_pogcr_oos_border_color; //ASA-1688 Added to give blue border to item
                    selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                } else {
                    selectedObject.BorderColour = 0x000000;
                }
            }

            var selectedObject = g_world.getObjectById(items.id);
            var objectType = shelfdtl.ObjType;
            if (typeof pegID !== "undefined" || pegID !== "") {
                if (g_show_peg_tags == "Y" && (objectType == "HANGINGBAR" || objectType == "PEGBOARD")) {
                    var res = show_pegTages("N", item_info, selectedObject, p_module_index, p_shelf_index, p_item_index, p_pog_index); //code adde by yograj to show pegtages
                }
            }
            render(p_pog_index);
            logDebug("function : add_items_with_image", "E");
            resolve(items.id);
        });
    } catch (err) {
        logDebug("function : add_items_with_image", "E");
        error_handling(err);
    }
}

async function add_items_prom(p_uuid, p_width, p_height, p_depth, p_color, p_x, p_y, p_z, p_module_index, p_shelf_index, p_item_index, p_recreate, p_fresh_item, p_pogcrDelistItemDftColor, p_pogcrItemNumLabelColor, p_pogcrDisplayItemInfo, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pog_index) {
    logDebug("function : add_items_prom; uuid : " + p_uuid + "; width : " + p_width + "; height : " + p_height + "; depth : " + p_depth + "; color : " + p_color + "; x : " + p_x + "; y : " + p_y + "; z : " + p_z + "; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index + "; i_item_index : " + p_item_index + "; recreate : " + p_recreate);
    try {
        /*if (typeof p_pog_index == "undefined") {
        p_pog_index = 0;
        }*/
        var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
        var spread_product = shelfdtl.SpreadItem; //Prasanna get spread product if combine, because first shelf in combine would be different.
        var [currCombinationIndex, currShelfCombIndx] = getCombinationShelf(p_pog_index, shelfdtl.Shelf);
        if (currCombinationIndex !== -1) {
            spread_product = g_combinedShelfs[currCombinationIndex].SpreadItem;
        }
        p_color = typeof p_color == "undefined" ? "#FFFFFF" : p_color; //ASA-1450
        objType = shelfdtl.ObjType;

        var items = shelfdtl.ItemInfo[p_item_index];
        var pegID = items.PegID;
        var pegHeadRoom = items.pegHeadRoom;
        var horiz_facing = items.BHoriz;
        var vert_facing = items.BVert;
        var cap_style = items.CapStyle;

        //ASA-1970 Start
        if (items.CrushHoriz > 0 && horiz_facing > 1 && spread_product == "F") {
            p_width = items.RW * (1 - items.CrushHoriz / 100) + items.SpreadItem * (horiz_facing - 1);
        }
        //ASA-1970 End

        if (items.Delist == "Y") {
            //ASA-696
            p_color = p_pogcrDelistItemDftColor;
            items.Color = p_pogcrDelistItemDftColor;
        }
        var [org_width, org_height, org_depth, actualHeight, actualWidth, actualDepth] = get_new_orientation_dim(items.Orientation, items.OW, items.OH, items.OD);
        if (items.CrushHoriz > 0) {
            org_width = items.W / items.BHoriz;
        }
        if (items.CrushVert > 0) {
            org_height = items.H / items.BVert;
        }
        var verti_values = [],
            horiz_values = [],
            nesting_negetive = "N",
            curr_width = 0,
            curr_vert_value = 0,
            curr_height = 0;
        var l_horz_start = 0 - parseFloat(p_width) / 2;
        var l_vert_start = 0 - parseFloat(p_height) / 2;
        var l_horz_end = 0 + parseFloat(p_width) / 2;
        var l_vert_end = 0 + parseFloat(p_height) / 2;
        var points = [];

        //var org_height = (height / vert_facing) - (spread * (vert_facing - 1));
        //var org_width = (width / horiz_facing) - (spread * (horiz_facing - 1));
        //var horiz_facing = shelfdtl.ItemInfo[i_item_index].BHoriz;
        if (pegID !== "" && typeof pegHeadRoom !== "undefined" && g_show_peg_tags == "Y") {
            if (objType == "HANGINGBAR" || objType == "PEGBOARD") {
                p_height = p_height + pegHeadRoom / 100;
                pegHeadRoom = pegHeadRoom / 2;
                p_y = p_y + pegHeadRoom / 100;
                // };
            }
        }
        return new Promise(function (resolve, reject) {
            var colorValue = parseInt(p_color.replace("#", "0x"), 16);
            var hex_decimal = new THREE.Color(colorValue);
            var rotation = shelfdtl.Rotation;
            var slope = shelfdtl.Slope;
            if (rotation !== 0 || slope !== 0) {
                items = new THREE.Mesh(
                    new THREE.BoxGeometry(p_width, p_height, p_depth),
                    new THREE.MeshStandardMaterial({
                        color: hex_decimal,
                    })
                );

                if (shelfdtl.ItemInfo[p_item_index].Rotation !== 0 && shelfdtl.ItemInfo[p_item_index].Item == "DIVIDER") {
                    items.rotateY((shelfdtl.ItemInfo[p_item_index].Rotation * Math.PI) / 180);
                }
                //items.rotateX(slope * Math.PI / 180);
                var selectedObject = g_scene_objects[p_pog_index].scene.children[2].getObjectById(shelfdtl.SObjID);
                if (p_recreate == "N") {
                    if (shelfdtl.ObjType == "PEGBOARD") {
                        p_x = 0 - shelfdtl.W / 2 + (shelfdtl.ItemInfo[p_item_index].PegBoardX + p_width / 2);
                        p_y = 0 - shelfdtl.H / 2 + (shelfdtl.ItemInfo[p_item_index].PegBoardY + p_height / 2);
                        p_z = 0.01 + p_depth / 2;
                    } else {
                        p_x = wpdSetFixed(0 - (shelfdtl.W / 2 - p_width / 2 - shelfdtl.ItemInfo[p_item_index].Distance));
                        p_y = wpdSetFixed(shelfdtl.H / 2 + p_height / 2);
                        p_z = wpdSetFixed(shelfdtl.D / 2 - p_depth / 2);
                    }
                    shelfdtl.ItemInfo[p_item_index].RotationX = p_x;
                    shelfdtl.ItemInfo[p_item_index].RotationY = p_y;
                    shelfdtl.ItemInfo[p_item_index].RotationZ = p_z;
                }

                items.applyMatrix4(new THREE.Matrix4().makeTranslation(p_x, p_y, p_z));
                // apply transforms of mesh on top
                g_scene.updateMatrixWorld();
                items.matrixAutoUpdate = false;
                items.applyMatrix4(selectedObject.matrix);
                //items.matrixWorldNeedsUpdate = true;
                g_scene_objects[p_pog_index].scene.children[2].add(items);
                //selectedObject.add(items);
                selectedObject.updateMatrix();
                var rotate_vector = new THREE.Vector3();
                rotate_vector.setFromMatrixPosition(items.matrixWorld);

                items.geometry.computeBoundingBox();
                var bounding_box = items.geometry.boundingBox;
                var box = new THREE.Box3().setFromObject(items);
                var box_dim = box.getSize(new THREE.Vector3());

                shelfdtl.ItemInfo[p_item_index].RotationWidth = parseFloat(box_dim.x);
                shelfdtl.ItemInfo[p_item_index].RotationHeight = parseFloat(box_dim.y);
                shelfdtl.ItemInfo[p_item_index].RotationDepth = parseFloat(box_dim.z);

                shelfdtl.ItemInfo[p_item_index].ItemRotateWorldX = rotate_vector.x;
                shelfdtl.ItemInfo[p_item_index].ItemRotateWorldY = rotate_vector.y;
                shelfdtl.ItemInfo[p_item_index].ItemRotateWorldZ = rotate_vector.z;
            } else {
                if (shelfdtl.ItemInfo[p_item_index].Rotation !== 0 && shelfdtl.ItemInfo[p_item_index].Item == "DIVIDER") {
                    items = new THREE.Mesh(
                        new THREE.BoxGeometry(p_width, p_height, p_depth),
                        new THREE.MeshStandardMaterial({
                            color: hex_decimal,
                        })
                    );
                    items.rotateY((shelfdtl.ItemInfo[p_item_index].Rotation * Math.PI) / 180);
                    items.position.z = p_z + shelfdtl.D / 1000;
                } else {
                    if (spread_product == "F" && horiz_facing > 1) {
                        items = new THREE.Mesh(
                            new THREE.BoxGeometry(p_width, p_height, 0.001),
                            new THREE.MeshBasicMaterial({
                                color: hex_decimal,
                                transparent: true,
                                opacity: 0,
                            })
                        );

                        var img_item = [];
                        var next_start = 0;
                        var material = new THREE.MeshStandardMaterial({
                            color: hex_decimal,
                        });
                        var item_info = shelfdtl.ItemInfo[p_item_index];
                        var spread = item_info.SpreadItem; // (horiz_facing - 1) : item_info.SpreadItem;
                        for (k = 0; k < horiz_facing; k++) {
                            var final_width = (final_height = 0);
                            if (vert_facing > 1 || cap_style !== "0") {
                                var geometry1 = new THREE.BoxGeometry(org_width, p_height, 0.001);
                                final_width = org_width;
                                final_height = p_height;
                            } else {
                                var geometry1 = new THREE.BoxGeometry(org_width, org_height, 0.001);
                                final_width = org_width;
                                final_height = org_height;
                            }
                            img_item.push(new THREE.Mesh(geometry1, material));
                            img_item[img_item.length - 1].uuid = "horiz_facing";

                            var l_wireframe_id = add_wireframe(img_item[img_item.length - 1], 2);
                            add_item_borders(p_module_index, p_shelf_index, p_item_index, img_item[img_item.length - 1], final_width, final_height, 1, p_pog_index, "N"); //Bug-26122 - splitting the chest
                            items.add(img_item[img_item.length - 1]);
                            if (k == 0) {
                                //ASA-1970 Start
                                // next_start = -(item_info.W / 2) + org_width + spread;
                                // img_item[0].position.x = -(item_info.W / 2) + org_width / 2;
                                next_start = -((item_info.CrushHoriz > 0 ? p_width : item_info.W) / 2) + org_width + spread;
                                img_item[0].position.x = -((item_info.CrushHoriz > 0 ? p_width : item_info.W) / 2) + org_width / 2;
                                //ASA-1970 End
                            } else {
                                img_item[k].position.x = next_start + org_width / 2;
                                next_start = next_start + org_width + spread;
                            }
                        }
                    } else {
                        items = new THREE.Mesh(
                            new THREE.BoxGeometry(p_width, p_height, 0.001),
                            new THREE.MeshStandardMaterial({
                                color: hex_decimal,
                            })
                        );
                    }
                    if (shelfdtl.ObjType == "PEGBOARD" || isShelfOnPegboard(shelfdtl.X, shelfdtl.Y, p_module_index, p_pog_index, shelfdtl, g_pog_json)) {
                        //ASA-1769 Issue 3
                        items.position.z = 0.016;
                    } else if (shelfdtl.ObjType == "PALLET") {
                        items.position.z = 0.001 + shelfdtl.D / 1000 - shelfdtl.ItemInfo[p_item_index].Z / 1000;
                    } else {
                        items.position.z = 0.001 + shelfdtl.D / 1000; // ASA- 1573 Issue 1 (0.001),ASA- 1608 Issue 1
                    }
                }
                items.position.x = p_x;
                items.position.y = p_y;
                g_world.add(items);
            }

            items.uuid = p_uuid;
            var item_info = shelfdtl.ItemInfo[p_item_index];
            items.ItemID = item_info.Item;
            items.Description = item_info.Desc;
            items.HorizFacing = item_info.BHoriz;
            items.VertFacing = item_info.BVert;
            items.DFacing = item_info.BaseD;
            items.ClassName = item_info.ClassName;
            items.DimUpdate = item_info.DimUpdate;
            items.SellingPrice = item_info.SellingPrice;
            items.SalesUnit = item_info.SalesUnit;
            items.NetSales = item_info.NetSales;
            items.CogsAdj = item_info.CogsAdj;
            items.GrossProfit = item_info.GrossProfit;
            items.WeeksCount = item_info.WeeksCount;
            items.MovingItem = item_info.MovingItem;
            items.RegMovement = item_info.RegMovement;
            items.AvgSales = item_info.AvgSales;
            items.ItemStatus = item_info.ItemStatus;
            items.CDTLvl1 = item_info.CDTLvl1; //ASA-1130
            items.CDTLvl2 = item_info.CDTLvl2; //ASA-1130
            items.CDTLvl3 = item_info.CDTLvl3; //ASA-1130
            items.ActualDPP = item_info.ActualDPP; //ASA-1182 ASA-1277-(3)
            items.StoreSOH = item_info.StoreSOH; //ASA-1182 ASA-1277-(3)
            items.DPPLoc = item_info.DPPLoc; //ASA-1308 Task-3
            items.StoreNo = item_info.StoreNo; //ASA-1277-(3)
            items.WeeksOfInventory = item_info.WeeksOfInventory; //ASA-1277-(3)
             //ASA-2013 Start
            items.ShelfPrice = item_info.ShelfPrice;
            items.PromoPrice = item_info.PromoPrice;
            items.DiscountRate = item_info.DiscountRate;
            items.PriceChangeDate = item_info.PriceChangeDate;
            items.WeeksOfInventory = item_info.WeeksOfInventory;
            items.Qty = item_info.Qty;
            items.WhStock = item_info.WhStock;
            items.StoreStock = item_info.StoreStock;
            items.StockIntransit = item_info.StockIntransit;
            //ASA-2013 End
            items.Profit = item_info.Profit;
            items.TotalMargin = item_info.TotalMargin;
            items.W = item_info.W;
            items.H = item_info.H;
            items.D = item_info.D;
            items.Color = item_info.Color;
            items.Barcode = item_info.Barcode;
            items.Desc = item_info.Desc;
            items.Brand = item_info.Brand;
            items.BrandType = item_info.BrandType; //ASA-1113
            items.Group = item_info.Group;
            items.Dept = item_info.Dept;
            items.Class = item_info.Class;
            items.SubClass = item_info.SubClass;
            items.StdUOM = item_info.StdUOM;
            items.SizeDesc = item_info.SizeDesc;
            items.Supplier = item_info.Supplier;
            items.SupplierName = item_info.SupplierName;
            items.LocID = item_info.LocID;
            items.ClassName = item_info.ClassName;
            items.ItemDim = g_msg_h + ": " + (item_info.OH * 100).toFixed(2) + " (" + g_msg_Sq + " : " + item_info.CrushVert + ")" + " " + g_msg_w + ": " + (item_info.OW * 100).toFixed(2) + " (" + g_msg_Sq + " : " + item_info.CrushHoriz + ")" + " " + g_msg_d + ": " + (item_info.OD * 100).toFixed(2) + " (" + g_msg_Sq + " : " + item_info.CrushD + ")"; //ASA-1407 Task 1-E ,//ASA-1407 issue 5
            items.OrientationDesc = item_info.OrientationDesc;
            items.Orientation = item_info.Orientation; //ASA-1289
            items.StoreCnt = item_info.StoreCnt;
            items.RotationDegree = rotation;
            items.OW = item_info.OW * 100;
            items.OH = item_info.OH * 100;
            items.OD = item_info.OD * 100;
            items.CrushW = item_info.CrushHoriz; //ASA-1758
            items.CrushH = item_info.CrushVert; //ASA-1758
            items.CrushD = item_info.CrushD; //ASA-1758
            items.DescSecond = item_info.DescSecond;
            items.Shelf = shelfdtl.Shelf;
            items.Rotation = 0;
            items.ItemSlope = 0;
            items.RotationFlag = rotation !== 0 || slope !== 0 ? "Y" : "N";
            items.ImageExists = "N";
            items.UnitperCase = item_info.UnitperCase;
            items.UnitperTray = item_info.UnitperTray;
            items.DfacingUpd = item_info.DfacingUpd;
            items.ItmDescChi = item_info.ItmDescChi; //ASA-1407 Task 1,//ASA-1407 issue 5
            items.ItmDescEng = item_info.ItmDescEng; //ASA-1273 Prasanna
            //items.ItmDescEng = items.Brand + " " + items.Desc + " " + items.SizeDesc;
            items.TotalUnitsCalc = item_info.BHoriz * item_info.BVert * item_info.BaseD;
            items.PkSiz = item_info.PkSiz;
            items.CapFacing = item_info.CapFacing;
            items.CapDepth = item_info.CapDepth;
            items.CapHorz = item_info.CapHorz;
            var cap_capacity = item_info.CapFacing * item_info.CapDepth * item_info.CapHorz; //ASA-1273 Prasanna
            items.Cpct = item_info.BHoriz * item_info.BVert * item_info.BaseD + (!isNaN(cap_capacity) ? cap_capacity : 0);
            items.Brand_Category = item_info.Brand_Category; //ASA-1158-S
            items.Uda_item_status = item_info.Uda_item_status;
            items.Gobecobrand = item_info.Gobecobrand;
            items.Internet = item_info.Internet; //ASA-1158-E
            items.GoGreen = item_info.GoGreen;
            items.Categ = item_info.Categ;
            if (typeof item_info.SizeDesc !== "undefined" && item_info.SizeDesc !== "") {
                //Regression issue 10
                var det_arr = item_info.SizeDesc.split("*");
            } else {
                var det_arr = "";
            }

            items.ItemSize = item_info.ItemSize;
            items.SplrLbl = item_info.SplrLbl;
            items.COO = item_info.COO;
            items.EDLP = item_info.EDLP;
            items.LoGrp = item_info.LoGrp;
            items.SqzPer = (typeof item_info.CrushHoriz !== "undefined" ? item_info.CrushHoriz : 0) + ":" + (typeof item_info.CrushVert !== "undefined" ? item_info.CrushVert : 0) + ":" + (typeof item_info.CrushD !== "undefined" ? item_info.CrushD : 0);
            items.InternationalRng = item_info.InternationalRng;
            items.NewItem = item_info.NewItem; //ASA-1182
            items.LiveNewItem = item_info.LiveNewItem; //ASA-1250
            items.DaysOfSupply = item_info.DaysOfSupply;
            items.CapDepthChanged = item_info.CapDepthChanged; //ASA-1273
            items.MassCrushH = item_info.MassCrushH; //Task-02_25977 KUSH FOR MASS UPDATE FOR AUTO CRUSH IN CHEST
            items.MassCrushV = item_info.MassCrushV; //Task-02_25977 KUSH FOR MASS UPDATE FOR AUTO CRUSH IN CHEST
            items.MassCrushD = item_info.MassCrushD; //Task-02_25977 KUSH FOR MASS UPDATE FOR AUTO CRUSH IN CHEST
            items.UDA751 = item_info.UDA751; //ASA-1407 Task 1 -S
            items.UDA755 = item_info.UDA755; //ASA-1407 Task 1 -E
            items.MPogDepthFacings = item_info.MPogDepthFacings; //ASA-1408
            items.MPogHorizFacings = item_info.MPogHorizFacings; //ASA-1408
            items.MPogVertFacings = item_info.MPogVertFacings; //ASA-1408
            items.Status = item_info.Status; //ASA-1407 issue 5
            items.MerchStyle = item_info.MerchStyle; //ASA-1605
            items.CapMerch = item_info.CapMerch; //ASA-1605
            //ASA-1640 Start
            items.ItemCondition = item_info.ItemCondition;
            items.AUR = item_info.AUR;
            items.ItemRanking = item_info.ItemRanking;
            items.WeeklySales = item_info.WeeklySales;
            items.WeeklyNetMargin = item_info.WeeklyNetMargin;
            items.WeeklyQty = item_info.WeeklyQty;
            items.NetMarginPercent = item_info.NetMarginPercent;
            items.CumulativeNM = item_info.CumulativeNM;
            items.TOP80B2 = item_info.TOP80B2;
            items.ItemBrandC = item_info.ItemBrandC;
            items.ItemPOGDept = item_info.ItemPOGDept;
            items.ItemRemark = item_info.ItemRemark;
            items.RTVStatus = item_info.RTVStatus;
            items.Pusher = item_info.Pusher;
            items.Divider = item_info.Divider;
            items.BackSupport = item_info.BackSupport;
            //ASA-1640 End
            items.CWPerc = item_info.CWPerc; //ASA-1640 #5
            items.CHPerc = item_info.CHPerc; //ASA-1640 #5
            items.CDPerc = item_info.CDPerc; //ASA-1640 #5

            items.OOSPerc = item_info.OOSPerc; //ASA-1688 Added for OOS%
            items.InitialItemDesc = item_info.InitialItemDesc; //ASA-1734 Issue 1
            items.InitialBrand = item_info.InitialBrand; //ASA-1787 Request #6
            items.InitialBarcode = item_info.InitialBarcode; //ASA-1787 Request #6

            // 1902 Available space should be calculated
            if (shelfdtl.ObjType == "SHELF" || (shelfdtl.ObjType == "HANGINGBAR" && p_fresh_item == "Y")) {
                var k = 0;
                var sum_width = 0;
                for (const items of shelfdtl.ItemInfo) {
                    sum_width += items.W;
                    k++;
                }
                if (shelfdtl.SpreadItem !== "E") {
                    var horizGap = shelfdtl.HorizGap ? shelfdtl.HorizGap : 0;
                    var horizGapSpace = (k > 1) ? horizGap * (k - 1) : 0;
                    sum_width += horizGapSpace;
                }
                shelfdtl.AvlSpace = wpdSetFixed((shelfdtl.W - sum_width) * 100); //.toFixed(3));
                var shelfObj = g_world.getObjectById(shelfdtl.SObjID);
                if (typeof shelfObj !== "undefined" && shelfdtl.ObjType == "SHELF") {
                    shelfObj.AvlSpace = shelfdtl.AvlSpace;
                }
            }
            //ASA-1970 Start
            //ASA-1946
            // if (shelfdtl.SpreadItem == "F" && shelfdtl.ItemInfo?.length == 1 && (shelfdtl.ObjType == "SHELF" || shelfdtl.ObjType == "HANGINGBAR")) {
            //     var itemWidth = shelfdtl.ItemInfo[0]?.CrushHoriz > 0 ? shelfdtl.ItemInfo[0]?.W : shelfdtl.ItemInfo[0]?.RW;  //ASA-1946 Issue1
            // 	shelfdtl.AvlSpace = wpdSetFixed((shelfdtl.W - itemWidth) * 100);
            // 	if (typeof shelfObj !== "undefined" && shelfdtl.ObjType == "SHELF") {
            // 		shelfObj.AvlSpace = shelfdtl.AvlSpace;
            // 	}
            // }
            if (shelfdtl.SpreadItem == "F" && (shelfdtl.ObjType == "SHELF" || shelfdtl.ObjType == "HANGINGBAR")) {
                var itemWidth = 0;
                for (const item of shelfdtl.ItemInfo) {
                    // itemWidth += item?.RW;
                    itemWidth += item?.CrushHoriz > 0 ? item?.W : item?.RW;
                }
                shelfdtl.AvlSpace = wpdSetFixed((shelfdtl.W - itemWidth) * 100);
                if (typeof shelfObj !== "undefined" && shelfdtl.ObjType == "SHELF") {
                    shelfObj.AvlSpace = shelfdtl.AvlSpace;
                }
            }
            //ASA-1970 End
            if (shelfdtl.ObjType == "ROD" && p_fresh_item == "Y") {
                shelfdtl.AvlSpace = wpdSetFixed(shelfdtl.D - item_info.D); //.toFixed(3));
                var shelfObj = g_world.getObjectById(shelfdtl.SObjID);
                if (typeof shelfObj !== "undefined" && shelfdtl.ObjType == "ROD") {
                    shelfObj.AvlSpace = shelfdtl.AvlSpace;
                }
            }

            var return_val = update_item_label(p_module_index, p_shelf_index, p_item_index, items, g_show_item_label, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pog_index, "N"); //Bug-26122 - splitting the chest

            var l_wireframe_id = add_wireframe(items, 2);
            items.WFrameID = l_wireframe_id;
            var retval = show_single_item_desc(p_module_index, p_shelf_index, p_item_index, g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index], items, g_camera, p_pogcrItemLabelColor, p_pogcrDisplayItemInfo, p_pog_index);

            if (spread_product !== "F" || (spread_product == "F" && horiz_facing == 1)) {
                add_item_borders(p_module_index, p_shelf_index, p_item_index, items, p_width, p_height, -1, p_pog_index, "N"); //Bug-26122 - splitting the chest
            }

            var selectedObject = g_world.getObjectById(items.id);
            if (items.DimUpdate == "E" && typeof items.DimUpdate !== "undefined") {
                selectedObject.BorderColour = g_dim_error_color;
                selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
            } else if (nvl(items.Status) == "N") {
                selectedObject.BorderColour = g_status_error_color;
                selectedObject.Status = "N";
                selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
            } else if (nvl(items.MovingItem) == "No" && g_pogcr_auto_hlite_non_mv_item == "Y") {
                selectedObject.BorderColour = g_nonMovingItemColor;
                selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
            } else {
                if (nvl(items.OOSPerc) > 80 && g_pogcr_enbl_oos_border == "Y") {
                    selectedObject.BorderColour = g_pogcr_oos_border_color; //ASA-1688 Added to give blue border to item
                    selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                } else {
                    selectedObject.BorderColour = 0x000000;
                }
            }
            var objectType = shelfdtl.ObjType;
            if (typeof pegID !== "undefined" || pegID !== "") {
                if (g_show_peg_tags == "Y" && (objectType == "HANGINGBAR" || objectType == "PEGBOARD")) {
                    var res = show_pegTages("N", shelfdtl.ItemInfo[p_item_index], selectedObject, p_module_index, p_shelf_index, p_item_index, p_pog_index); //code adde by yograj to show pegtages
                }
            }
            resolve(items.id);
            logDebug("function : add_items_prom", "E");
        });
    } catch (err) {
        logDebug("function : add_items_prom", "E");
        error_handling(err);
    }
}

function add_items(p_uuid, p_width, p_height, p_depth, p_color, p_x, p_y, p_z, p_module_index, p_shelf_index, p_item_index, p_rotation, p_pog_index) {
    try {
        logDebug("function : add_items; uuid : " + p_uuid + "; width : " + p_width + "; height : " + p_height + "; depth : " + p_depth + "; color : " + p_color + "; x : " + p_x + "; y : " + p_y + "; z : " + p_z + "; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index + "; i_item_index : " + p_item_index + "; rotation : " + p_rotation, "S");
        var colorValue = parseInt(p_color.replace("#", "0x"), 16);
        var hex_decimal = new THREE.Color(colorValue);

        var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
        var p_rotation = shelfdtl.Rotation;
        var slope = shelfdtl.Slope;
        if (p_rotation !== 0 || slope !== 0) {
            items = new THREE.Mesh(
                new THREE.BoxGeometry(p_width, p_height, p_depth),
                new THREE.MeshStandardMaterial({
                    color: hex_decimal,
                })
            );

            if (shelfdtl.ItemInfo[p_item_index].Rotation !== 0 && shelfdtl.ItemInfo[p_item_index].Item == "DIVIDER") {
                items.rotateY((shelfdtl.ItemInfo[p_item_index].Rotation * Math.PI) / 180);
            }
            //items.rotateX(slope * Math.PI / 180);
            var selectedObject = g_world.getObjectById(shelfdtl.SObjID);

            if (shelfdtl.ObjType == "PEGBOARD") {
                p_x = 0 - shelfdtl.W / 2 + (shelfdtl.ItemInfo[p_item_index].PegBoardX + p_width / 2);
                p_y = 0 - shelfdtl.H / 2 + (shelfdtl.ItemInfo[p_item_index].PegBoardY + p_height / 2);
                p_z = 0.01 + p_depth / 2;
            } else {
                p_x = wpdSetFixed(0 - (shelfdtl.W / 2 - p_width / 2 - shelfdtl.ItemInfo[p_item_index].Distance));
                p_y = wpdSetFixed(shelfdtl.H / 2 + p_height / 2);
                p_z = wpdSetFixed(shelfdtl.D / 2 - p_depth / 2);
            }
            shelfdtl.ItemInfo[p_item_index].RotationX = p_x;
            shelfdtl.ItemInfo[p_item_index].RotationY = p_y;
            shelfdtl.ItemInfo[p_item_index].RotationZ = p_z;

            items.applyMatrix4(new THREE.Matrix4().makeTranslation(p_x, p_y, p_z));
            // apply transforms of mesh on top
            g_scene.updateMatrixWorld();
            items.matrixAutoUpdate = false;
            items.applyMatrix4(selectedObject.matrix);
            items.FixelID = shelfdtl.ItemInfo[p_item_index].ItemID;
            items.Module = g_pog_json[p_pog_index].ModuleInfo[p_module_index].Module;

            items.POGCode = g_pog_json[p_pog_index].POGCode; //ASA-1243
            items.Version = g_pog_json[p_pog_index].Version; //ASA-1243
            //Start ASA-1305
            items.X = wpdSetFixed(shelfdtl.ItemInfo[p_item_index].X * 100 - (shelfdtl.ItemInfo[p_item_index].W * 100) / 2); //.toFixed(2);
            items.Y = wpdSetFixed(shelfdtl.ItemInfo[p_item_index].Y * 100 - (shelfdtl.ItemInfo[p_item_index].H * 100) / 2); //toFixed(roundNumber(shelfdtl.ItemInfo[p_item_index].Y * 100 - ((shelfdtl.ItemInfo[p_item_index].H * 100) / 2), 3));
            items.Z = wpdSetFixed(shelfdtl.ItemInfo[p_item_index].Z * 100); //.toFixed(2);
            //items.X = Math.round(shelfdtl.ItemInfo[p_item_index].X * 100); // ASA-1243 //ASA-1305
            //items.Y = Math.round(shelfdtl.ItemInfo[p_item_index].Y * 100); // ASA-1243 //ASA-1305
            //items.Z = Math.round(shelfdtl.ItemInfo[p_item_index].Z * 100); // ASA-1243 //ASA-1305
            //End ASA-1305
            items.Desc = shelfdtl.Desc; //ASA-1243

            //items.matrixWorldNeedsUpdate = true;
            g_world.add(items);
            //selectedObject.add(items);
            selectedObject.updateMatrix();
            var rotate_vector = new THREE.Vector3();
            rotate_vector.setFromMatrixPosition(items.matrixWorld);
            shelfdtl.ItemInfo[p_item_index].ItemRotateWorldX = rotate_vector.x;
            shelfdtl.ItemInfo[p_item_index].ItemRotateWorldY = rotate_vector.y;
            shelfdtl.ItemInfo[p_item_index].ItemRotateWorldZ = rotate_vector.z;
        } else {
            items = new THREE.Mesh(
                new THREE.BoxGeometry(p_width, p_height, 0.001),
                new THREE.MeshStandardMaterial({
                    color: hex_decimal,
                })
            );
            items.position.x = p_x;
            items.position.z = 0.001 + shelfdtl.D / 1000;
            items.position.y = p_y;
            items.uuid = p_uuid;
            var item_info = shelfdtl.ItemInfo[p_item_index];
            items.FixelID = item_info.ItemID;
            items.Module = g_pog_json[p_pog_index].ModuleInfo[p_module_index].Module;
            items.W = item_info.W;
            items.H = item_info.H;
            items.D = item_info.D;
            items.Color = item_info.Color;
            items.Rotation = 0;
            items.ItemSlope = 0;
            items.Rotation = p_rotation !== 0 || slope !== 0 ? "Y" : "N";
            items.ImageExists = "N";
            items.POGCode = g_pog_json[p_pog_index].POGCode; //ASA-1243
            items.Version = g_pog_json[p_pog_index].Version; //ASA-1243
            //Start ASA-1305
            items.X = wpdSetFixed(shelfdtl.ItemInfo[p_item_index].X * 100 - (shelfdtl.ItemInfo[p_item_index].W * 100) / 2); //.toFixed(2);
            items.Y = wpdSetFixed(shelfdtl.ItemInfo[p_item_index].Y * 100 - (shelfdtl.ItemInfo[p_item_index].H * 100) / 2); //toFixed(roundNumber(shelfdtl.ItemInfo[p_item_index].Y * 100 - ((shelfdtl.ItemInfo[p_item_index].H * 100) / 2), 3));
            items.Z = wpdSetFixed(shelfdtl.ItemInfo[p_item_index].Z * 100); //.toFixed(2);
            //items.X = Math.round(shelfdtl.ItemInfo[p_item_index].X * 100); // ASA-1243 //ASA-1305
            //items.Y = Math.round(shelfdtl.ItemInfo[p_item_index].Y * 100); // ASA-1243 //ASA-1305
            //items.Z = Math.round(shelfdtl.ItemInfo[p_item_index].Z * 100); // ASA-1243 //ASA-1305
            //End ASA-1305
            items.Desc = shelfdtl.Desc; //ASA-1243

            g_world.add(items);
        }

        var l_wireframe_id = add_wireframe(items, 2);

        add_item_borders(p_module_index, p_shelf_index, p_item_index, items, p_width, p_height, -1, p_pog_index, "N"); //Bug-26122 - splitting the chest
        var shelf_arr = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo;
        var j = 0;
        var auto_divider_ind = "N"; //ASA-1406
        var val_found = false;
        for (const shelfs of shelf_arr) {
            if (shelfs.Shelf == shelfdtl.ItemInfo[p_item_index].ItemID) {
                g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[j].ShelfDivObjID = items.id;
                if (shelfs.DivHeight > 0 && (shelfs.DivPbtwFace == "Y" || shelfs.DivPed == "Y" || shelfs.DivPst == "Y")) {
                    //ASA-1406 //Task_27734
                    auto_divider_ind = "Y";
                    val_found = true;
                }
                break; //return false;
            }
            j++;
        }
        if (!val_found) {
            //Task_27734
            if (shelfdtl.DivHeight > 0 && (shelfdtl.DivPbtwFace == "Y" || shelfdtl.DivPed == "Y" || shelfdtl.DivPst == "Y")) {
                // && shelfdtl.ItemInfo[p_item_index].AutoDiv == 'Y') {//ASA-1406 //Task_27734 //ASA-1406 issue 6
                auto_divider_ind = "Y";
            }
        }
        show_div_id = shelfdtl.NoDivIDShow !== "undefined" && auto_divider_ind == "Y" ? shelfdtl.NoDivIDShow : "N"; //ASA-1406
        if (g_show_fixel_label == "Y" && show_div_id == "N") {
            //ASA-1406
            var hex_color = shelfdtl.ItemInfo[p_item_index].Color;
            if (hexToRgb(hex_color) == null) {
                var red = parseInt("FF", 16);
                var green = parseInt("FF", 16);
                var blue = parseInt("FF", 16);
            } else {
                var red = hexToRgb(hex_color).r;
                var green = hexToRgb(hex_color).r;
                var blue = hexToRgb(hex_color).g;
            }

            var text_color;

            //if (red * 0.299 + green * 0.587 + blue * 0.114 > 186) {
            text_color = "#ffffff";
            /*} else {
            text_color = "#ffffff";
            }*/
            var return_obj = addlabelText(shelfdtl.ItemInfo[p_item_index].ItemID, g_labelFont, g_labelActualSize, text_color, "center", "");
            items.add(return_obj);
            return_obj.position.x = 0;
            return_obj.position.y = 0;
            if (shelfdtl.Rotation !== 0 || shelfdtl.Slope !== 0) {
                return_obj.position.z = shelfdtl.ItemInfo[p_item_index].D / 2 + 0.005;
            } else {
                return_obj.position.z = 0.005;
            }
            shelfdtl.ItemInfo[p_item_index].LObjID = return_obj.id;
            var shelf_arr = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo;
            $.each(shelf_arr, function (j, shelfs) {
                if (shelfs.Shelf == shelfdtl.ItemInfo[p_item_index].ItemID) {
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[j].LObjID = return_obj.id;
                    return false;
                }
            });
        }
        logDebug("function : add_items", "E");
        return items.id;
    } catch (err) {
        error_handling(err);
    }
}

async function update_rotate_shelfs(p_pog_index) {
    logDebug("function : update_rotate_shelfs", "S");
    try {
        var j = 0;
        for (const Modules of g_pog_json[p_pog_index].ModuleInfo) {
            if (Modules.ParentModule == null) {
                var i = 0;
                for (const Shelf of Modules.ShelfInfo) {
                    if (Shelf.ObjType !== "BASE" && Shelf.ObjType !== "NOTCH" && Shelf.ObjType !== "DIVIDER" && (Shelf.Rotation !== 0 || Shelf.Slope !== 0)) {
                        var shelf_obj = g_world.getObjectById(Shelf.SObjID);
                        if (Shelf.Rotation !== 0) {
                            shelf_obj.quaternion.copy(g_camera.quaternion);
                            shelf_obj.lookAt(g_pog_json[p_pog_index].CameraX, g_pog_json[p_pog_index].CameraY, g_pog_json[p_pog_index].CameraZ);
                            shelf_obj.rotateY((Shelf.Rotation * Math.PI) / 180);
                            var slope = 0;
                            if (Shelf.Slope > 0) {
                                slope = 0 - Shelf.Slope;
                            } else if (Shelf.Slope < 0) {
                                slope = -Shelf.Slope;
                            } else {
                                slope = 0;
                            }
                            shelf_obj.rotateX((slope * Math.PI) / 180);
                            shelf_obj.updateMatrix();
                        }

                        if (g_pog_json[p_pog_index].ModuleInfo[j].ShelfInfo[i].ItemInfo.length > 0) {
                            g_scene.updateMatrixWorld();
                            async function doSomething() {
                                let result = await set_all_items(j, i, Shelf.X, Shelf.Y, g_shelf_edit_flag, "N", "Y", p_pog_index, p_pog_index);
                            }
                            doSomething();
                        }
                    }
                    i++;
                }
            }
            j++;
        }
        logDebug("function : update_rotate_shelfs", "E");
    } catch (err) {
        error_handling(err);
    }
}
//Start Bug-26122 - splitting the chest
async function update_item_distance(p_module_index, p_shelf_index, p_pog_index, p_chest_ind = "N") {
    logDebug("function : update_item_distance; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index, "S");
    try {
        if (p_chest_ind == "Y") {
            var shelf_dtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ChestInfo[p_shelf_index];
        } else {
            var shelf_dtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
        }

        var items_arr = shelf_dtl.ItemInfo;
        var l_shelf_object_type = shelf_dtl.ObjType;
        var shelf_start = shelf_dtl.X - shelf_dtl.W / 2;
        var shelf_start_Y = shelf_dtl.Y + shelf_dtl.H / 2;
        var shelf_begin_y = shelf_dtl.Y - shelf_dtl.H / 2;
        var basket_spread = shelf_dtl.BsktSpreadProduct;

        if (l_shelf_object_type == "BASKET" && basket_spread == "BT") {
            $.each(items_arr, function (i, items) {
                shelf_dtl.ItemInfo[i].Distance = items.Y - items.H / 2 - shelf_start_Y;
            });
        } else if (l_shelf_object_type == "PEGBOARD" || (l_shelf_object_type == "CHEST" && g_chest_as_pegboard == "Y")) {
            $.each(items_arr, function (i, items) {
                shelf_dtl.ItemInfo[i].PegBoardX = items.X - items.W / 2 - shelf_start;
                shelf_dtl.ItemInfo[i].PegBoardY = items.Y - items.H / 2 - shelf_begin_y;
                shelf_dtl.ItemInfo[i].Distance = items.X - items.W / 2 - shelf_start;
            });
        } else {
            $.each(items_arr, function (i, items) {
                shelf_dtl.ItemInfo[i].Distance = items.X - items.W / 2 - shelf_start;
                shelf_dtl.ItemInfo[i].YDistance = items.Y - shelf_start_Y;
            });
        }
        logDebug("function : update_item_distance", "E");
    } catch (err) {
        error_handling(err);
    }
}
//End Bug-26122 - splitting the chest

//ASA-1898 Divider is showing in the front of the textbox in AutoPosition added new Parameter p_isAutoPosition
async function set_all_items(p_module_index, p_shelf_index, p_a, p_y, p_shelf_edit_flag, p_resetType, p_set_axis, p_pog_index, p_sceneIndex, p_isAutoPosition) {
    logDebug("function : set_all_items; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index + "; a : " + p_a + "; y : " + p_y + "; p_shelf_edit_flag : " + p_shelf_edit_flag + "; resetType : " + p_resetType + "; set_axis : " + p_set_axis, "S");
    try {
        var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
        if (shelfdtl.ItemInfo.length > 0 && p_shelf_edit_flag == "Y") {
            var items_arr = shelfdtl.ItemInfo;
            var shelf_width = shelfdtl.W;
            var shelf_height = shelfdtl.H;
            var shelf_depth = shelfdtl.D;
            var l_object_type = shelfdtl.ObjType;
            var spread_product = shelfdtl.SpreadItem;
            var basket_spread = shelfdtl.BsktSpreadProduct;
            var rotation = shelfdtl.Rotation;
            var slope = shelfdtl.Slope;
            var item_x = 0,
                item_y = 0;

            if ((rotation !== 0 && rotation !== "N") || slope !== 0) {
                var i = 0;
                var selectedObject = g_scene_objects[p_sceneIndex].scene.children[2].getObjectById(shelfdtl.SObjID);
                for (const items of items_arr) {
                    var item_obj = g_scene_objects[p_sceneIndex].scene.children[2].getObjectById(items.ObjID);
                    var x = items.RotationX;
                    var p_y = items.RotationY;
                    var z = items.RotationZ;
                    var relativeMeshOffset = new THREE.Vector3(x, p_y, z);

                    var offsetPosition = relativeMeshOffset.applyMatrix4(selectedObject.matrixWorld);

                    item_obj.position.x = offsetPosition.x;
                    item_obj.position.y = offsetPosition.y;
                    item_obj.position.z = offsetPosition.z;
                    item_obj.quaternion.copy(selectedObject.quaternion);
                    item_obj.updateMatrix();
                    var rotate_vector = new THREE.Vector3();
                    rotate_vector.setFromMatrixPosition(item_obj.matrixWorld);
                    if (!isNaN(rotate_vector.x)) {
                        shelfdtl.ItemInfo[i].ItemRotateWorldX = rotate_vector.x;
                        shelfdtl.ItemInfo[i].ItemRotateWorldY = rotate_vector.y;
                        shelfdtl.ItemInfo[i].ItemRotateWorldZ = rotate_vector.z;
                    }
                    i = i + 1;
                }
                render(p_pog_index);
            } else {
                if (l_object_type == "BASKET" && basket_spread == "BT") {
                    var i = 0;
                    for (const items of items_arr) {
                        // $.each(items_arr, function (i, items) {
                        var selectedObject = g_scene_objects[p_sceneIndex].scene.children[2].getObjectById(items.ObjID);
                        if (typeof selectedObject !== "undefined") {
                            //Task_27734
                            item_x = p_a - shelf_width / 2 + items.W / 2;
                            item_y = p_y + shelf_height / 2 + items.Distance + items.H / 2;
                            selectedObject.position.set(item_x, item_y, selectedObject.position.z);
                            if (p_set_axis == "Y") {
                                shelfdtl.ItemInfo[i].X = item_x;
                                shelfdtl.ItemInfo[i].Y = item_y;
                            }
                        }
                        //});
                        i++;
                    }
                } else if (l_object_type == "HANGINGBAR") {
                    var i = 0;
                    for (const items of items_arr) {
                        // $.each(items_arr, function (i, items) {
                        var selectedObject = g_scene_objects[p_sceneIndex].scene.children[2].getObjectById(items.ObjID);
                        if (typeof selectedObject !== "undefined") {
                            //Task_27734
                            item_x = p_a - shelf_width / 2 + items.Distance + items.W / 2;
                            item_y = p_y - items.H / 2;
                            selectedObject.position.set(item_x, item_y, selectedObject.position.z);
                            if (p_set_axis == "Y") {
                                shelfdtl.ItemInfo[i].X = item_x;
                                shelfdtl.ItemInfo[i].Y = item_y;
                            }
                        }
                        // });
                        i++;
                    }
                } else if (g_shelf_object_type == "ROD") {
                    var i = 0;
                    for (const items of items_arr) {
                        // $.each(items_arr, function (i, items) {
                        var selectedObject = g_scene_objects[p_sceneIndex].scene.children[2].getObjectById(items.ObjID);
                        if (typeof selectedObject !== "undefined") {
                            //Task_27734
                            item_x = p_a;
                            item_y = p_y - shelf_height / 2 - items.H / 2;
                            selectedObject.position.set(item_x, item_y, selectedObject.position.z);
                            if (p_set_axis == "Y") {
                                shelfdtl.ItemInfo[i].X = item_x;
                                shelfdtl.ItemInfo[i].Y = item_y;
                            }
                        }
                        //});
                        i++;
                    }
                } else if (g_shelf_object_type == "PEGBOARD" || (g_shelf_object_type == "CHEST" && g_chest_as_pegboard == "Y")) {
                    var i = 0;
                    for (const items of items_arr) {
                        var selectedObject = g_scene_objects[p_sceneIndex].scene.children[2].getObjectById(items.ObjID);
                        if (typeof selectedObject !== "undefined") {
                            //Task_27734
                            item_x = p_a - shelf_width / 2 + items.PegBoardX + items.W / 2;
                            item_y = p_y - shelf_height / 2 + items.PegBoardY + items.H / 2;
                            selectedObject.position.set(item_x, item_y, 0.016);
                            if (p_set_axis == "Y") {
                                shelfdtl.ItemInfo[i].X = item_x;
                                shelfdtl.ItemInfo[i].Y = item_y;
                            }
                        }
                        i++;
                    }
                } else {
                    var i = 0;
                    for (const items of items_arr) {
                        var oldItemHeight = items.OldItemHeight;
                        if (p_resetType == "E") {
                            if (typeof oldItemHeight == "undefined" || oldItemHeight === null) {
                                oldItemHeight = items.H;
                            }
                        } else {
                            oldItemHeight = items.H;
                        }
                        var selectedObject = g_scene_objects[p_sceneIndex].scene.children[2].getObjectById(items.ObjID);
                        if (typeof selectedObject !== "undefined") {
                            //Task_27734
                            if (typeof items.BottomObjID !== "undefined" && items.BottomObjID !== "") {
                                var oldItemHeight1;
                                var j = 0;
                                for (const items_info of items_arr) {
                                    oldItemHeight1 = items_info.OldItemHeight;
                                    if (p_resetType == "E") {
                                        if (typeof oldItemHeight1 == "undefined") {
                                            oldItemHeight1 = items_info.H;
                                        }
                                    } else {
                                        oldItemHeight1 = items_info.H;
                                    }
                                    if (items.BottomObjID == items_info.ObjID) {
                                        item_x = p_a - shelf_width / 2 + items_info.Distance + items_info.W / 2;
                                        item_y = p_y + shelf_height / 2 + items.TotalHeight + items.H / 2;
                                        break; //return false;
                                    }
                                    j++;
                                }
                            } else {
                                //ASA-1892 Issue Fix
                                // for (const items_info of items_arr) {
                                //     oldItemHeight1 = items_info.OldItemHeight;
                                //     if (p_resetType == "E") {
                                //         if (typeof oldItemHeight1 == "undefined") {
                                //             oldItemHeight1 = items_info.H;
                                //         }
                                //     } else {
                                //         oldItemHeight1 = items_info.H;
                                //     }
                                //     if (items.BottomObjID == items_info.ObjID) {
                                //         var shelf_item_gap = items_info.H;
                                //         break;
                                //     }
                                // }
                                item_x = p_a - shelf_width / 2 + items.Distance + items.W / 2;
                                item_y = p_y + shelf_height / 2 + oldItemHeight / 2;
                            }
                            if (l_object_type == "BASKET" && items.Item == "DIVIDER") {
                                item_y = p_y + shelf_height / 2 + items.YDistance + items.H / 2;
                                selectedObject.position.set(item_x, item_y, g_drag_z);
                            } 
                            //ASA-2010.3 Start
                            if (l_object_type == "PALLET") { 
                                selectedObject.position.x = item_x;
                                selectedObject.position.y = item_y;
                            }
                            //ASA-2010.3 End
                            /*else if (l_object_type == "SHELF") { //ASA-1573 Issue 2 ,ASA- 1608 Issue 1
                                selectedObject.position.set(item_x, item_y, 0.002); // 0.004
                            }*/ else 
                            {
                                p_isAutoPosition === "Y" ? selectedObject.position.set(item_x, item_y) : selectedObject.position.set(item_x, item_y, g_drag_z);	//ASA-1898 Divider is showing in the front of the textbox in AutoPosition
                            }

                            if (p_set_axis == "Y") {
                                shelfdtl.ItemInfo[i].X = item_x;
                                shelfdtl.ItemInfo[i].Y = item_y;
                            }
                            shelfdtl.ItemInfo[i].H = oldItemHeight;
                        }
                        // });
                        i++;
                    }
                }
            }
        }
        logDebug("function : set_all_items", "E");
    } catch (err) {
        error_handling(err);
    }
}

function get_y_distance(p_module_index, p_shelf_index, p_item_index, p_itemX, p_itemY, p_pog_index) {
    logDebug("function : get_y_distance; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index + "; i_item_index : " + p_item_index + "; itemX : " + p_itemX + "; itemY : " + p_itemY, "S");
    try {
        var new_items_arr = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo;
        var total_height = 0;
        var j = 0;
        for (const items of new_items_arr) {
            if (wpdSetFixed(p_itemX) == wpdSetFixed(items.X) && wpdSetFixed(items.Y) < wpdSetFixed(p_itemY)) {
                total_height += items.H;
            }
            j++;
        }

        logDebug("function : get_y_distance", "E");
        return total_height;
    } catch (err) {
        error_handling(err);
    }
}

//Start Bug-26122 - splitting the chest
function update_item_label(p_module_index, p_shelf_index, p_item_index, p_item_obj, p_show_item_label, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pog_index, p_chest_ind = "N") {
    logDebug("function : update_item_label; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index + "; i_item_index : " + p_item_index + "; g_show_item_label : " + p_show_item_label, "S");
    try {
        if (p_chest_ind == "Y") {
            var shelf_dtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ChestInfo[p_shelf_index];
        } else {
            var shelf_dtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
        }
        if (p_show_item_label == "Y" && shelf_dtl.ItemInfo[p_item_index].LocID !== "" && typeof shelf_dtl.ItemInfo[p_item_index].LocID !== "undefined") {
            var back_color = p_pogcrItemLabelColor,
                text_color;
            if (hexToRgb(back_color) == null) {
                var red = parseInt("FF", 16);
                var green = parseInt("FF", 16);
                var blue = parseInt("FF", 16);
            } else {
                var red = hexToRgb(back_color).r;
                var green = hexToRgb(back_color).r;
                var blue = hexToRgb(back_color).g;
            }
            text_color = getTextColor(red, green, blue); //ASA-1095
            if (g_fixel_label == "N") {
                var return_obj = addlabelText(shelf_dtl.ItemInfo[p_item_index].LocID, g_labelFont, g_labelActualSize, text_color, "center", back_color);
            } else {
                var text = get_type(shelf_dtl.ItemInfo[p_item_index].BrandType);
                if (typeof text == "undefined" || text == "") {
                    text = shelf_dtl.ItemInfo[p_item_index].LocID;
                } else {
                    text = text + " " + shelf_dtl.ItemInfo[p_item_index].LocID;
                }
                var return_obj = addlabelText(text, g_labelFont, g_labelActualSize, text_color, "center", back_color);
            }

            p_item_obj.add(return_obj);
            return_obj.position.x = 0;

            if (p_pogcrItemNumLabelPosition == "CENTER") {
                return_obj.position.y = 0;
            } else if (p_pogcrItemNumLabelPosition == "BOTTOM") {
                return_obj.position.y = 0 - shelf_dtl.ItemInfo[p_item_index].H / 2 + 0.0015625 * g_labelFont;
            } else {
                return_obj.position.y = shelf_dtl.ItemInfo[p_item_index].H / 2 + 0.0015625 * g_labelFont;
            }

            if (shelf_dtl.Rotation !== 0 || shelf_dtl.Slope !== 0) {
                return_obj.position.z = shelf_dtl.ItemInfo[p_item_index].D / 2 + 0.005;
            } else {
                // return_obj.position.z = 0.005;
                return_obj.position.z = 0.0015;
            }
            shelf_dtl.ItemInfo[p_item_index].LObjID = return_obj.id;
        }
        logDebug("function : update_item_label", "E");
        return "success";
    } catch (err) {
        error_handling(err);
    }
}
//End Bug-26122 - splitting the chest

function show_item_labels(p_show_label_ind, p_pogcrItemBackLabelColor, p_pogcrItemLabelPosition, p_pog_index) {
    try {
        logDebug("function : show_item_labels; show_label_ind : " + p_show_label_ind + "; pogcrItemBackLabelColor : " + p_pogcrItemBackLabelColor + "; pogcrItemLabelPosition : " + p_pogcrItemLabelPosition, "S");
        var module_details = g_pog_json[p_pog_index].ModuleInfo;
        var details = {};
        var is_driver = "N";
        var finalAction;
        if (typeof g_undoRedoAction == "undefined") {
            g_undoRedoAction = "REDO";
        }
        if (g_undoRedoAction == "REDO") {
            finalAction = "U";
        } else {
            finalAction = "R";
        }
        var i = 0;

        if (p_show_label_ind == "Y") {
            for (const modules of module_details) {
                if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                    var l_shelf_details = modules.ShelfInfo;
                    var j = 0;
                    for (const shelfs of l_shelf_details) {
                        if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX") {
                            if (shelfs.ItemInfo.length > 0) {
                                var item_Details = shelfs.ItemInfo;
                                var k = 0;
                                for (const items of item_Details) {
                                    if (items.Item !== "DIVIDER" && items.LocID !== "" && typeof items.LocID !== "undefined") {
                                        var item_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(items.ObjID);
                                        if (typeof item_obj !== "undefined") {
                                            if (typeof items.LObjID !== "undefined" && items.LObjID !== -1) {
                                                var label_obj = item_obj.getObjectById(items.LObjID);
                                                item_obj.remove(label_obj);
                                            }
                                            var back_color = p_pogcrItemBackLabelColor,
                                                text_color;
                                            if (hexToRgb(back_color) == null) {
                                                var red = parseInt("FF", 16);
                                                var green = parseInt("FF", 16);
                                                var blue = parseInt("FF", 16);
                                            } else {
                                                var red = hexToRgb(back_color).r;
                                                var green = hexToRgb(back_color).r;
                                                var blue = hexToRgb(back_color).g;
                                            }
                                            var text_color = getTextColor(red, green, blue); //ASA-1095
                                            if (g_fixel_label == "Y") {
                                                var text = get_type(items.BrandType);
                                                if (typeof text == "undefined" || text == "") {
                                                    text = items.LocID;
                                                } else {
                                                    text = text + "" + items.LocID;
                                                }
                                                var return_obj = addlabelText(text, g_labelFont, g_labelActualSize, text_color, "center", back_color);
                                            } else {
                                                var return_obj = addlabelText(items.LocID, g_labelFont, g_labelActualSize, text_color, "center", back_color);
                                            }
                                            item_obj.add(return_obj);
                                            return_obj.position.x = 0;
                                            if (p_pogcrItemLabelPosition == "CENTER") {
                                                return_obj.position.y = 0;
                                            } else if (p_pogcrItemLabelPosition == "BOTTOM") {
                                                return_obj.position.y = 0 - items.H / 2 + 0.0015625 * g_labelFont;
                                            } else {
                                                return_obj.position.y = items.H / 2 + 0.0015625 * g_labelFont;
                                            }

                                            if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                                return_obj.position.z = items.D / 2 + 0.0005;
                                            } else {
                                                return_obj.position.z = 0.0015;
                                            }
                                            g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].ItemInfo[k].LObjID = return_obj.id;
                                        }
                                    } else if (items.Item !== "DIVIDER") {
                                        if (typeof items.LObjID !== "undefined" && items.LObjID !== -1) {
                                            var item_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(items.ObjID);
                                            if (typeof item_obj !== "undefined") {
                                                var label_obj = item_obj.getObjectById(items.LObjID);
                                                item_obj.remove(label_obj);
                                            }
                                        }
                                    }
                                    k = k + 1;
                                }
                            }
                        }
                        j = j + 1;
                    }
                }
                i = i + 1;
            }
        } else {
            var i = 0;
            for (const modules of module_details) {
                if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                    var l_shelf_details = modules.ShelfInfo;
                    var j = 0;
                    for (const shelfs of l_shelf_details) {
                        if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX") {
                            if (shelfs.ItemInfo.length > 0) {
                                var item_Details = shelfs.ItemInfo;
                                var k = 0;
                                for (const items of item_Details) {
                                    if (items.Item !== "DIVIDER" && items.LocID !== "" && typeof items.LocID !== "undefined") {
                                        var item_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(items.ObjID);
                                        if (typeof item_obj !== "undefined") {
                                            if (typeof items.LObjID !== "undefined" && items.LObjID !== -1) {
                                                var label_obj = item_obj.getObjectById(items.LObjID);
                                                item_obj.remove(label_obj);
                                            }
                                            g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].ItemInfo[k].LObjID = -1;
                                        }
                                    }
                                    k = k + 1;
                                }
                            }
                        }
                        j = j + 1;
                    }
                }
                i = i + 1;
            }
        }
        var oldLabelStatus;
        if (p_show_label_ind == "Y") {
            oldLabelStatus = "N";
        } else {
            oldLabelStatus = "Y";
        }
        details["show_item_labels"] = oldLabelStatus;
        g_undo_details = [];
        g_undo_details.push(details);
        if (finalAction == "U") {
            g_delete_details.multi_delete_shelf_ind = "N";
            g_undo_all_obj_arr = [];

            g_undo_all_obj_arr.push(g_undo_details);
            g_undo_all_obj_arr.push(g_cut_copy_arr);
            g_undo_all_obj_arr.previousAction = "ITEM_LABEL";
            if (g_cut_support_obj_arr.length > 0) {
                //yrc
                g_undo_all_obj_arr.hasSupportArr = "Y";
            } else {
                g_undo_all_obj_arr.hasSupportArr = "N";
            }
            g_undo_all_obj_arr.g_MultiObjects = "N";
            g_undo_all_obj_arr.multi_delete_shelf_ind = "N";
            g_undo_final_obj_arr.push(g_undo_all_obj_arr);
            g_delete_details = [];
            g_multi_drag_shelf_arr = [];
            g_multi_drag_item_arr = [];
            g_cut_copy_arr = [];
            g_undo_details = [];
        } else {
            g_delete_details.multi_delete_shelf_ind = "N";
            g_redo_all_obj_arr = [];
            g_redo_all_obj_arr.push(g_undo_details);
            g_redo_all_obj_arr.push(g_cut_copy_arr);
            g_redo_all_obj_arr.previousAction = "ITEM_LABEL";
            if (g_cut_support_obj_arr.length > 0) {
                //yrc
                g_redo_all_obj_arr.hasSupportArr = "Y";
            } else {
                g_redo_all_obj_arr.hasSupportArr = "N";
            }
            g_redo_all_obj_arr.g_MultiObjects = "N";
            g_redo_all_obj_arr.multi_delete_shelf_ind = "N";
            g_redo_final_obj_arr.push(g_redo_all_obj_arr);
            g_delete_details = [];
            g_multi_drag_shelf_arr = [];
            g_multi_drag_item_arr = [];
            g_cut_copy_arr = [];
            g_undo_details = [];
        }
        animate_pog(p_pog_index);
        render(p_pog_index);
        logDebug("function : show_item_labels", "E");
    } catch (err) {
        error_handling(err);
    }
}

//Start ASA-1290 should show bottom of shelf
function update_single_fixel_label(p_shelfs, p_pog_index, p_module_index, p_shelf_index) {
    var l_obj_id = -1;
    var shelf_dtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index]; //ASA-1573 Issue 3
    var modules = g_pog_json[p_pog_index].ModuleInfo[p_module_index];
    if (p_shelfs.ObjType == "DIVIDER") {
        var new_shelf_detail = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo;
        $.each(new_shelf_detail, function (k, shelfs_detail) {
            if (shelfs_detail.ObjType !== "BASE" && shelfs_detail.ObjType !== "NOTCH" && shelfs_detail.ObjType !== "DIVIDER") {
                $.each(shelfs_detail.ItemInfo, function (l, items) {
                    if (items.Item == "DIVIDER") {
                        if (p_shelfs.ShelfDivObjID == items.ObjID) {
                            div_mod_index = i;
                            div_shelf_index = k;
                            div_item_index = l;
                            l_obj_id = items.LObjID;
                        }
                    }
                });
            }
        });
        var shelf_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(p_shelfs.ShelfDivObjID);
    } else {
        l_obj_id = p_shelfs.LObjID;
        var shelf_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(p_shelfs.SObjID);
    }
    if (typeof shelf_obj !== "undefined") {
        if (typeof l_obj_id !== "undefined" && l_obj_id !== -1) {
            var label_obj = shelf_obj.getObjectById(l_obj_id);
            shelf_obj.remove(label_obj);
        }
        var hex_color = p_shelfs.Color;
        if (hexToRgb(hex_color) == null) {
            var red = parseInt("FF", 16);
            var green = parseInt("FF", 16);
            var blue = parseInt("FF", 16);
        } else {
            var red = hexToRgb(hex_color).r;
            var green = hexToRgb(hex_color).r;
            var blue = hexToRgb(hex_color).g;
        }

        var text_color = getTextColor(red, green, blue);
        if (g_fixel_label == "Y") {
            /*Start ASA-1371_26842
            var cap_count = 100;
            var notch_no = 0;
            for (k = 0; k < cap_count; k++) {
                if (p_shelfs.Y + (p_shelfs.H / 2) < g_pog_json[p_pog_index].BaseH + (modules.NotchStart / 2) && modules.NotchStart > 0) {
                    notch_no = 0;
                    break;
                } else if (p_shelfs.Y + (p_shelfs.H / 2) <= g_pog_json[p_pog_index].BaseH + (modules.NotchStart / 2) && modules.NotchStart > 0) {
                    notch_no = 0;
                    break;
                } else if (p_shelfs.Y + (p_shelfs.H / 2) <= g_pog_json[p_pog_index].BaseH && modules.NotchStart == 0) {
                    notch_no = 0;
                    break;
                } else if (p_shelfs.Y + (p_shelfs.H / 2) < ((g_pog_json[p_pog_index].BaseH + modules.NotchStart)) + modules.NotchSpacing * k) {
                    notch_no = k;
                    break;
                }
            }*/
            var notch_no = get_notch_no(modules, p_pog_index, p_shelfs.Y + p_shelfs.H / 2); //ASA-1371_26842
            //End ASA-1371_26842

            var shelf = p_shelfs.Shelf + " " + p_shelfs.Desc + " " + parseFloat(p_shelfs.Y * 100 - (p_shelfs.H / 2) * 100).toFixed(2) + get_message("POGCR_FIXEL_CM") + " " + notch_no;
            var return_obj = addlabelText(shelf, g_labelFont, g_labelActualSize, text_color, "center", "");
        } else {
            var return_obj = addlabelText(p_shelfs.Shelf, g_labelFont, g_labelActualSize, text_color, "center", "");
        }
        shelf_obj.add(return_obj);

        return_obj.position.y = -0.005;
        if (p_shelfs.Rotation !== 0 || p_shelfs.Slope !== 0) {
            return_obj.position.z = p_shelfs.D / 2 + 0.005;
        } else {
            return_obj.position.z = 0.005;
        }
        if (p_shelfs.ObjType == "DIVIDER" && div_mod_index !== -1) {
            return_obj.position.x = 0;
            g_pog_json[p_pog_index].ModuleInfo[div_mod_index].ShelfInfo[div_shelf_index].ItemInfo[div_item_index].LObjID = return_obj.id;
            shelf_dtl.LObjID = return_obj.id;
        } else {
            if (g_fixel_label !== "Y") {
                return_obj.position.x = 0 - (p_shelfs.W / 2.4 + 0.01);
            } else {
                return_obj.position.x = 0 - (p_shelfs.W / 2.4 - 0.02);
            }
            shelf_dtl.LObjID = return_obj.id;
        }
    }
}
//End ASA-1290 should show bottom of shelf

function show_fixel_labels(p_show_label_ind, p_pog_index) {
    try {
        logDebug("function : show_fixel_labels; show_label_ind : " + p_show_label_ind, "S");
        var module_details = g_pog_json[p_pog_index].ModuleInfo;
        var div_mod_index = -1,
            div_shelf_index = -1,
            div_item_index = -1,
            no_show_div_id = "N"; //ASA-1406 //Task_27734
        var details = {};
        var is_driver = "N";
        var finalAction;
        if (typeof g_undoRedoAction == "undefined") {
            g_undoRedoAction = "REDO";
        }
        if (g_undoRedoAction == "REDO") {
            finalAction = "U";
        } else {
            finalAction = "R";
        }
        var i = 0;
        if (p_show_label_ind == "Y") {
            for (const modules of module_details) {
                if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                    var l_shelf_details = modules.ShelfInfo;
                    var j = 0;
                    for (const shelfs of l_shelf_details) {
                        no_show_div_id = "N"; // Task_27734
                        console.log("ObjType TextBox", shelfs.ObjType);
                        if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "TEXTBOX") {
                            var l_obj_id = -1;
                            if (shelfs.ObjType == "DIVIDER") {
                                var new_shelf_detail = g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo;
                                $.each(new_shelf_detail, function (k, shelfs_detail) {
                                    if (shelfs_detail.ObjType !== "BASE" && shelfs_detail.ObjType !== "NOTCH" && shelfs_detail.ObjType !== "DIVIDER") {
                                        $.each(shelfs_detail.ItemInfo, function (l, items) {
                                            if (items.Item == "DIVIDER") {
                                                if (shelfs.ShelfDivObjID == items.ObjID) {
                                                    div_mod_index = i;
                                                    div_shelf_index = k;
                                                    div_item_index = l;
                                                    l_obj_id = items.LObjID;
                                                    if (shelfs.DivHeight > 0 && (shelfs.DivPbtwFace == "Y" || shelfs.DivPst == "Y" || shelfs.DivPed == "Y")) {
                                                        //Start Task_27734
                                                        if (typeof shelfs.NoDivIDShow !== "undefined") {
                                                            no_show_div_id = shelfs.NoDivIDShow; //ASA-1406
                                                        } else if (typeof shelfs_detail.NoDivIDShow !== "undefined") {
                                                            no_show_div_id = shelfs_detail.NoDivIDShow; //ASA-1406
                                                        } else {
                                                            no_show_div_id = "N";
                                                        }
                                                    } else {
                                                        no_show_div_id = "N";
                                                    } //End Task_27734
                                                }
                                            }
                                        });
                                    }
                                });
                                var shelf_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(shelfs.ShelfDivObjID); //ASA-1406 //Task_27734
                                //var shelf_obj = no_show_div_id == 'N' ? g_scene_objects[p_pog_index].scene.children[2].getObjectById(shelfs.ShelfDivObjID) : undefined;//ASA-1406 //Task_27734
                            } else {
                                l_obj_id = shelfs.LObjID;
                                var shelf_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(shelfs.SObjID);
                            }
                            if (typeof shelf_obj !== "undefined") {
                                if (typeof l_obj_id !== "undefined" && l_obj_id !== -1) {
                                    var label_obj = shelf_obj.getObjectById(l_obj_id);
                                    shelf_obj.remove(label_obj);
                                }
                                var hex_color = shelfs.Color;
                                if (hexToRgb(hex_color) == null) {
                                    var red = parseInt("FF", 16);
                                    var green = parseInt("FF", 16);
                                    var blue = parseInt("FF", 16);
                                } else {
                                    var red = hexToRgb(hex_color).r;
                                    var green = hexToRgb(hex_color).r;
                                    var blue = hexToRgb(hex_color).g;
                                }

                                var text_color = getTextColor(red, green, blue); //ASA-1095
                                if (g_fixel_label == "Y") {
                                    //ASA-1113
                                    //Start ASA-1371_26842
                                    /*var cap_count = 100;
                                    var notch_no = 0;
 
                                    for (k = 0; k < cap_count; k++) {
                                        if (shelfs.Y + (shelfs.H / 2) < g_pog_json[p_pog_index].BaseH + (modules.NotchStart / 2) && modules.NotchStart > 0) {
                                            notch_no = 0;
                                            break;
                                        } else if (shelfs.Y + (shelfs.H / 2) <= g_pog_json[p_pog_index].BaseH + (modules.NotchStart / 2) && modules.NotchStart > 0) {
                                            notch_no = 0;
                                            break;
                                        } else if (shelfs.Y + (shelfs.H / 2) <= g_addlabelText$''pog_json[p_pog_index].BaseH && modules.NotchStart == 0) {
                                            notch_no = 0;
                                            break;
                                        } else if (shelfs.Y + (shelfs.H / 2) < ((g_pog_json[p_pog_index].BaseH + modules.NotchStart)) + modules.NotchSpacing * k) {
                                            notch_no = k;
                                            break;
                                        }
                                    }*/
                                    if (no_show_div_id == "N") {
                                        //Task_27734
                                        var notch_no = get_notch_no(modules, p_pog_index, shelfs.Y + shelfs.H / 2); //ASA-1371_26842
                                        //End ASA-1371_26842
                                        //ASA-1290 should show bottom of shelf
                                        var shelf = shelfs.Shelf + " " + shelfs.Desc + " " + parseFloat(shelfs.Y * 100 - (shelfs.H / 2) * 100).toFixed(2) + get_message("POGCR_FIXEL_CM") + " " + notch_no;
                                        var return_obj = addlabelText(shelf, g_labelFont, g_labelActualSize, text_color, "center", "");
                                    }
                                } else {
                                    if (no_show_div_id == "N") {
                                        //Task_27734
                                        var return_obj = addlabelText(shelfs.Shelf, g_labelFont, g_labelActualSize, text_color, "center", "");
                                    }
                                }
                                if (no_show_div_id == "N") {
                                    //Task_27734
                                    shelf_obj.add(return_obj);

                                    //return_obj.position.y = -0.005; commented for ASA-1701
                                    if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                        return_obj.position.z = shelfs.D / 2 + 0.005;
                                    } else {
                                        return_obj.position.z = 0.005; //0.0005  ASA-1095
                                    }
                                    if (shelfs.ObjType == "DIVIDER" && div_mod_index !== -1) {
                                        return_obj.position.x = 0;
                                        g_pog_json[p_pog_index].ModuleInfo[div_mod_index].ShelfInfo[div_shelf_index].ItemInfo[div_item_index].LObjID = return_obj.id;
                                        g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].LObjID = return_obj.id;
                                    } else {
                                        if (g_fixel_label !== "Y") {
                                            var x = ((return_obj.material.map.image.width / return_obj.material.map.image.height) * g_labelActualSize) / 2; //ASA-1677 #5 Added to calculate value for X
                                            return_obj.position.x = 0 - shelfs.W / 2 + x + 0.01;
                                            return_obj.position.y = 0; // ASA-1701 Added
                                            //return_obj.position.x = 0 - (shelfs.W / 2.4 + 0.01);
                                        } else {
                                            var x = ((return_obj.material.map.image.width / return_obj.material.map.image.height) * g_labelActualSize) / 2; //ASA-1677 #5 Added to calculate value for X
                                            return_obj.position.x = 0 - shelfs.W / 2 + x + 0.01;
                                            return_obj.position.y = -0.005; // ASA-1701 Added
                                            //return_obj.position.x = 0 - (shelfs.W / 2.4 - 0.02); //ASA-1113
                                        }
                                        g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].LObjID = return_obj.id;
                                    }
                                }
                            }
                        }
                        j = j + 1;
                    }
                }
                i = i + 1;
            }
        } else {
            var i = 0;
            for (const modules of module_details) {
                if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                    var l_shelf_details = modules.ShelfInfo;
                    var j = 0;
                    for (const shelfs of l_shelf_details) {
                        if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH") {
                            var l_obj_id = -1;
                            if (shelfs.ObjType == "DIVIDER") {
                                var new_shelf_detail = g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo;
                                $.each(new_shelf_detail, function (k, shelfs_detail) {
                                    if (shelfs_detail.ObjType !== "BASE" && shelfs_detail.ObjType !== "NOTCH" && shelfs_detail.ObjType !== "DIVIDER") {
                                        $.each(shelfs_detail.ItemInfo, function (l, items) {
                                            if (items.Item == "DIVIDER") {
                                                if (shelfs.ShelfDivObjID == items.ObjID) {
                                                    div_mod_index = i;
                                                    div_shelf_index = k;
                                                    div_item_index = l;
                                                    l_obj_id = items.LObjID;
                                                }
                                            }
                                        });
                                    }
                                });

                                var shelf_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(shelfs.ShelfDivObjID);
                            } else {
                                l_obj_id = shelfs.LObjID;
                                var shelf_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(shelfs.SObjID);
                            }
                            if (typeof l_obj_id !== "undefined" && l_obj_id !== -1) {
                                var label_obj = shelf_obj.getObjectById(l_obj_id);
                                shelf_obj.remove(label_obj);
                            }
                            g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].LObjID = -1;
                        }
                        j = j + 1;
                    }
                }
                i = i + 1;
            }
            if (g_fixel_label == "Y") {
                show_notch_labels("N", "", "Y", p_pog_index);
            }
        }

        var oldLabelStatus;
        if (p_show_label_ind == "Y") {
            oldLabelStatus = "N";
        } else {
            oldLabelStatus = "Y";
        }
        details["show_fixel_labels"] = oldLabelStatus;
        g_undo_details = [];
        g_undo_details.push(details);
        if (finalAction == "U") {
            g_delete_details.multi_delete_shelf_ind = "N";
            g_undo_all_obj_arr = [];

            g_undo_all_obj_arr.push(g_undo_details);
            g_undo_all_obj_arr.push(g_cut_copy_arr);
            g_undo_all_obj_arr.previousAction = "FIXEL_LABEL";
            if (g_cut_support_obj_arr.length > 0) {
                //yrc
                g_undo_all_obj_arr.hasSupportArr = "Y";
            } else {
                g_undo_all_obj_arr.hasSupportArr = "N";
            }
            g_undo_all_obj_arr.g_MultiObjects = "N";
            g_undo_all_obj_arr.multi_delete_shelf_ind = "N";
            g_undo_final_obj_arr.push(g_undo_all_obj_arr);
            g_delete_details = [];
            g_multi_drag_shelf_arr = [];
            g_multi_drag_item_arr = [];
            g_cut_copy_arr = [];
            g_undo_details = [];
        } else {
            g_delete_details.multi_delete_shelf_ind = "N";
            g_redo_all_obj_arr = [];
            g_redo_all_obj_arr.push(g_undo_details);
            g_redo_all_obj_arr.push(g_cut_copy_arr);
            g_redo_all_obj_arr.previousAction = "FIXEL_LABEL";
            if (g_cut_support_obj_arr.length > 0) {
                //yrc
                g_redo_all_obj_arr.hasSupportArr = "Y";
            } else {
                g_redo_all_obj_arr.hasSupportArr = "N";
            }
            g_redo_all_obj_arr.g_MultiObjects = "N";
            g_redo_all_obj_arr.multi_delete_shelf_ind = "N";
            g_redo_final_obj_arr.push(g_redo_all_obj_arr);
            g_delete_details = [];
            g_multi_drag_shelf_arr = [];
            g_multi_drag_item_arr = [];
            g_cut_copy_arr = [];
            g_undo_details = [];
        }
        animate_pog(p_pog_index);
        render(p_pog_index);
        logDebug("function : show_fixel_labels", "E");
    } catch (err) {
        error_handling(err);
    }
}

function show_notch_labels(p_show_label_ind, p_notchHead, p_updateUndo = "Y", p_pog_index) {
    try {
        logDebug("function : show_notch_labels; show_label_ind : " + p_show_label_ind, "S");
        var module_details = g_pog_json[p_pog_index].ModuleInfo;
        var notch_label = g_notch_label_position.toUpperCase();
        var div_mod_index = -1,
            div_shelf_index = -1,
            div_item_index = -1;
        var details = {};
        var is_driver = "N";
        var finalAction;
        var posX, posY;
        if (typeof g_undoRedoAction == "undefined") {
            g_undoRedoAction = "REDO";
        }
        if (g_undoRedoAction == "REDO") {
            finalAction = "U";
        } else {
            finalAction = "R";
        }
        var i = 0;
        if (p_show_label_ind == "Y") {
            for (const modules of module_details) {
                if ((typeof modules.ParentModule == "undefined" || modules.ParentModule == null) && modules.NotchW > 0) {
                    var l_shelf_details = modules.ShelfInfo;
                    var j = 0;
                    for (const shelfs of l_shelf_details) {
                        if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX") {
                            var shelf_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(shelfs.SObjID);
                            if (typeof shelfs.NotchLabelObjID !== "undefined" && shelfs.NotchLabelObjID !== -1) {
                                var label_obj = shelf_obj.getObjectById(shelfs.NotchLabelObjID);
                                shelf_obj.remove(label_obj);
                            }
                            /*Start ASA-1371_26842
                            var cap_count = 100;
                            var notch_no = -1; //change in 1254 to start value from 0
                            for (k = 0; k < cap_count; k++) { //ASA-1290
                                if (shelfs.Y + (shelfs.H / 2) < g_pog_json[p_pog_index].BaseH + (modules.NotchStart / 2) && modules.NotchStart > 0) {
                                    notch_no = 0;
                                    break;
                                } else if (shelfs.Y + (shelfs.H / 2) <= g_pog_json[p_pog_index].BaseH + (modules.NotchStart / 2) && modules.NotchStart > 0) {
                                    notch_no = 0;
                                    break;
                                } else if (shelfs.Y + (shelfs.H / 2) <= g_pog_json[p_pog_index].BaseH && modules.NotchStart == 0) {
                                    notch_no = 0;
                                    break;
                                } else if (shelfs.Y + (shelfs.H / 2) < ((g_pog_json[p_pog_index].BaseH + modules.NotchStart)) + modules.NotchSpacing * k) {
                                    notch_no = k;
                                    break;
                                }
                            }*/
                            var notch_no = get_notch_no(modules, p_pog_index, shelfs.Y + shelfs.H / 2); //ASA-1371_26842
                            //End ASA-1371_26842
                            shelfs.NotchNo = notch_no;

                            var hex_color = shelfs.Color;
                            if (hexToRgb(hex_color) == null) {
                                var red = parseInt("FF", 16);
                                var green = parseInt("FF", 16);
                                var blue = parseInt("FF", 16);
                            } else {
                                var red = hexToRgb(hex_color).r;
                                var green = hexToRgb(hex_color).r;
                                var blue = hexToRgb(hex_color).g;
                            }

                            var text_color;

                            // ASA-1095
                            if (notch_label == "CENTER") {
                                text_color = getTextColor(red, green, blue); //ASA-1095
                            } else {
                                text_color = "#000000";
                            }
                            var return_obj = addlabelText(p_notchHead + " " + notch_no, g_labelFont, g_labelActualSize, text_color, "center", "");
                            shelf_obj.add(return_obj);

                            if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                return_obj.position.z = shelfs.D / 2 + 0.005;
                            } else {
                                return_obj.position.z = 0.005; // 0.0005 --ASA-1095
                            }

                            [posX, posY] = getLabelPosition(shelfs, "S", notch_label); // ASA-1095
                            return_obj.position.x = posX;
                            return_obj.position.y = posY;
                            g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].NotchLabelObjID = return_obj.id;
                        }
                        j = j + 1;
                    }
                }
                i = i + 1;
            }
        } else {
            for (const modules of module_details) {
                if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                    var l_shelf_details = modules.ShelfInfo;
                    var j = 0;
                    for (const shelfs of l_shelf_details) {
                        if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX") {
                            var shelf_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(shelfs.SObjID);

                            if (typeof shelfs.NotchLabelObjID !== "undefined" && shelfs.NotchLabelObjID !== -1) {
                                var label_obj = shelf_obj.getObjectById(shelfs.NotchLabelObjID);
                                shelf_obj.remove(label_obj);
                            }
                            g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].NotchLabelObjID = -1;
                        }
                        j = j + 1;
                    }
                }
                i = i + 1;
            }
        }
        var oldLabelStatus;
        if (p_show_label_ind == "Y") {
            oldLabelStatus = "N";
        } else {
            oldLabelStatus = "Y";
        }
        details["show_notch_labels"] = oldLabelStatus;
        g_undo_details = [];
        p_updateUndo == "Y" ? g_undo_details.push(details) : "";
        if (p_updateUndo == "Y") {
            if (finalAction == "U") {
                g_delete_details.multi_delete_shelf_ind = "N";
                g_undo_all_obj_arr = [];

                p_updateUndo == "Y" ? g_undo_all_obj_arr.push(g_undo_details) : "";
                p_updateUndo == "Y" ? g_undo_all_obj_arr.push(g_cut_copy_arr) : "";
                g_undo_all_obj_arr.previousAction = "NOTCH_LABEL";
                if (g_cut_support_obj_arr.length > 0) {
                    g_undo_all_obj_arr.hasSupportArr = "Y";
                } else {
                    g_undo_all_obj_arr.hasSupportArr = "N";
                }
                g_undo_all_obj_arr.g_MultiObjects = "N";
                g_undo_all_obj_arr.multi_delete_shelf_ind = "N";
                g_undo_final_obj_arr.push(g_undo_all_obj_arr);
                g_delete_details = [];
                g_multi_drag_shelf_arr = [];
                g_multi_drag_item_arr = [];
                g_cut_copy_arr = [];
                g_undo_details = [];
            } else {
                g_delete_details.multi_delete_shelf_ind = "N";
                g_redo_all_obj_arr = [];
                g_redo_all_obj_arr.push(g_undo_details);
                g_redo_all_obj_arr.push(g_cut_copy_arr);
                g_redo_all_obj_arr.previousAction = "NOTCH_LABEL";
                if (g_cut_support_obj_arr.length > 0) {
                    //yrc
                    g_redo_all_obj_arr.hasSupportArr = "Y";
                } else {
                    g_redo_all_obj_arr.hasSupportArr = "N";
                }
                g_redo_all_obj_arr.g_MultiObjects = "N";
                g_redo_all_obj_arr.multi_delete_shelf_ind = "N";
                g_redo_final_obj_arr.push(g_redo_all_obj_arr);
                g_delete_details = [];
                g_multi_drag_shelf_arr = [];
                g_multi_drag_item_arr = [];
                g_cut_copy_arr = [];
                g_undo_details = [];
            }
        }
        render(p_pog_index);
        logDebug("function : show_notch_labels", "E");
    } catch (err) {
        error_handling(err);
    }
}

function addlabelText(p_text, p_textHeight, p_actualFontSize, p_font_color, p_txt_align, p_back_color) {
    try {
        logDebug("function : addlabelText; text : " + p_text + "; textHeight : " + p_textHeight + "; actualFontSize : " + p_actualFontSize + "; font_color : " + p_font_color + "; txt_align : " + p_txt_align + "; back_color : " + p_back_color, "S");
        // 2d duty
        var text_canvas = document.createElement("canvas");
        var context = text_canvas.getContext("2d");
        context.fillStyle = "#000000";
        var metrics = context.measureText(p_text);
        var textWidth = metrics.width;
        var [width, height] = get_visible_text_dim(p_text, p_textHeight);

        text_canvas.width = width;
        text_canvas.height = height;

        context.font = "normal " + p_textHeight + "px Arial";
        context.textAlign = p_txt_align;
        context.textBaseline = "middle";
        if (p_back_color !== "") {
            context.fillStyle = p_back_color;
            context.fillRect(0, 0, text_canvas.width, text_canvas.height);
        }
        context.fillStyle = p_font_color;
        context.fillText(p_text, width / 2, height / 2);

        let tex = new THREE.CanvasTexture(text_canvas);
        tex.minFilter = THREE.LinearFilter;
        var material = new THREE.SpriteMaterial({
            map: tex,
        });
        material.map.minFilter = THREE.LinearFilter;
        var sprite = new THREE.Sprite(material);
        sprite.scale.set((width / height) * p_actualFontSize, p_actualFontSize, 1);
        logDebug("function : addlabelText", "E");
        sprite.uuid = p_text;
        return sprite;
    } catch (err) {
        error_handling(err);
    }
}

async function clearThree(obj) {
    while (obj.children.length > 0) {
        clearThree(obj.children[0]);
        obj.remove(obj.children[0]);
    }
    if (obj.geometry) obj.geometry.dispose();

    if (obj.material) {
        //in case of map, bumpMap, normalMap, envMap ...
        Object.keys(obj.material).forEach((prop) => {
            if (!obj.material[prop]) return;
            if (obj.material[prop] !== null && typeof obj.material[prop].dispose === "function") obj.material[prop].dispose();
        });
        obj.material.dispose();
    }
    if (obj.texture) obj.texture.dispose();
    if (obj.map) obj.map.dispose();
}

async function init_pdf(p_canWidth, p_canHeight, p_scale, p_addWorld = "N", p_rendering = "Y") {
    try {
        logDebug("function : init_pdf", "S");

        if (typeof g_scene_pdf !== "undefined") await clearThree(g_scene_pdf);

        if (typeof g_renderer_pdf !== "undefined" && g_renderer_pdf !== null && g_renderer_pdf !== "") {
            //Bug_26122 pdf error issue
            g_renderer_pdf.forceContextLoss();
            g_renderer_pdf.dispose();
        }

        g_scene_pdf = {};
        g_camera_pdf = {};

        g_new_canvas = document.createElement("canvas");
        w = p_canWidth;
        h = p_canHeight;
        scale = p_scale;
        g_new_canvas.width = w * scale;
        g_new_canvas.height = h * scale;
        g_renderer_pdf = new THREE.WebGLRenderer({
            canvas: g_new_canvas,
        });


        if (p_rendering == "Y") {
            g_renderer_pdf.domElement.style.imageRendering = "pixelated";
        }
        g_renderer_pdf.domElement.style.width = w * scale + "px";
        g_renderer_pdf.domElement.style.height = h * scale + "px";

        g_scene_pdf = new THREE.Scene();
        g_camera_pdf = new THREE.PerspectiveCamera(25, g_new_canvas.width / g_new_canvas.height, 0.1, 700); //set 700 to squeeze the FPS.
        g_camera_pdf.lookAt(new THREE.Vector3(0, 0, 0));

        if (p_rendering == "Y") {
            g_renderer_pdf.setPixelRatio(1);
        } else {
            g_renderer_pdf.setPixelRatio(window.devicePixelRatio);
        }
        g_camera_pdf.add(new THREE.PointLight(0xdcd9d9, 0.1)); // point light at g_camera_pdf position
        g_scene_pdf.add(g_camera_pdf);
        g_renderer_pdf.setClearColor(0xffffff); //0xe2dede);
        g_renderer_pdf.setSize(g_new_canvas.width, g_new_canvas.height);
        var directionlight = new THREE.DirectionalLight(0xffffff, 1);
        directionlight.position.set(-1, 2, 4).normalize();
        g_scene_pdf.add(directionlight);
        g_camera_pdf.aspect = g_new_canvas.width / g_new_canvas.height;
        g_camera_pdf.updateProjectionMatrix();
        if (p_addWorld == "Y") {
            g_world_pdf = new THREE.Object3D();
            g_scene_pdf.add(g_world_pdf);
            g_renderer_pdf.render(g_scene_pdf, g_camera_pdf);
        }
        logDebug("function : init_pdf", "E");
    } catch (err) {
        error_handling(err);
    }
}

async function create_scene(p_module_index, p_new_item_label, p_show_item_desc, p_mod_count, p_show_live_img, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_noDataModuleWidth = 0, p_pog_index) {
    logDebug("function : create_scene; p_module_index : " + p_module_index + "; new_item_label : " + p_new_item_label, "S");
    try {
        if (typeof g_pog_json[p_pog_index].ModuleInfo[p_module_index].ParentModule == "undefined" || g_pog_json[p_pog_index].ModuleInfo[p_module_index].ParentModule == null) {
            if (g_pog_json[p_pog_index].BaseH > 0) {
                var colorValue = parseInt(g_pog_json[p_pog_index].ModuleInfo[p_module_index].Color.replace("#", "0x"), 16);
                var hex_decimal = new THREE.Color(colorValue);
                var POGBase = new THREE.Mesh(
                    new THREE.BoxGeometry(g_pog_json[p_pog_index].ModuleInfo[p_module_index].W + p_noDataModuleWidth, g_pog_json[p_pog_index].BaseH, 0.001),
                    new THREE.MeshStandardMaterial({
                        color: hex_decimal,
                    })
                );
                var l_wireframe_id = add_wireframe(POGBase, 2);
                POGBase.position.x = (g_pog_json[p_pog_index].ModuleInfo[p_module_index].W + p_noDataModuleWidth) / 2;
                POGBase.position.y = g_pog_json[p_pog_index].BaseH / 2;
                POGBase.position.z = 0;
                g_scene_pdf.add(POGBase);
                var moduleY = g_pog_json[p_pog_index].ModuleInfo[p_module_index].H / 2 + g_pog_json[p_pog_index].BaseH;
            } else {
                var moduleY = g_pog_json[p_pog_index].ModuleInfo[p_module_index].H / 2;
            }
            g_world = g_scene_objects[p_pog_index].scene.children[2];
            var module = g_world.getObjectById(g_pog_json[p_pog_index].ModuleInfo[p_module_index].MObjID);
            var moduleX = g_pog_json[p_pog_index].ModuleInfo[p_module_index].W / 2;
            var new_module = module.clone(true);
            new_module.material = module.material.clone(true);
            g_scene_pdf.add(new_module);
            new_module.position.set(moduleX, moduleY, 0);
            if (g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo.length > 0) {
                j = 0;
                for (const shelfs of g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo) {
                    if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.SplitChest !== "Y") {
                        //Bug-26122 - splitting the chest
                        var shelf = g_world.getObjectById(shelfs.SObjID);
                        var shelfX = -1;
                        var created_ind = "N";
                        if (shelfs.ObjType == "TEXTBOX") {
                            if ((shelfs.W < g_pog_json[p_pog_index].W && p_mod_count > 1) || p_mod_count == 1) {
                                var new_shelf = new THREE.Mesh(shelf.geometry, shelf.material);
                                new_shelf.material.transparent = false;
                                var l_wireframe_id = add_wireframe(new_shelf, 12);
                                if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                    if (shelfs.Slope > 0) {
                                        slope = 0 - shelfs.Slope;
                                    } else {
                                        slope = -shelfs.Slope;
                                    }

                                    new_shelf.rotateY((shelfs.Rotation * Math.PI) / 180);
                                    if (shelfs.Rotation == 0) {
                                        new_shelf.rotateX(((slope / 2) * Math.PI) / 180);
                                    } else {
                                        new_shelf.rotateX((slope * Math.PI) / 180);
                                    }
                                }
                                created_ind = "Y";
                                shelfX = shelfs.X - (g_pog_json[p_pog_index].ModuleInfo[p_module_index].X - g_pog_json[p_pog_index].ModuleInfo[p_module_index].W / 2);
                                if (typeof shelfs.MergeTextbox !== "undefined") {
                                    if (shelfs.MergeTextbox == "Y") {
                                        shelfX = moduleX;
                                    }
                                }
                            }
                        } else if (shelfs.ObjType == "CHEST" && g_pogcr_pdf_chest_split == "Y") {
                            var new_shelf = new THREE.Mesh(
                                new THREE.BoxGeometry(shelfs.W, shelfs.H, 0.0001), //shelfs.D),
                                new THREE.MeshStandardMaterial({
                                    color: shelfs.Color,
                                })
                            );
                            var l_wireframe_id = add_wireframe(new_shelf, 2);
                            new_shelf.material = shelf.material.clone(true);

                            // var new_shelf = shelf.clone(true);
                            shelfX = shelfs.X - (g_pog_json[p_pog_index].ModuleInfo[p_module_index].X - g_pog_json[p_pog_index].ModuleInfo[p_module_index].W / 2);
                            created_ind = "Y";
                        } else {
                            var new_shelf = shelf.clone(true);
                            shelfX = shelfs.X - (g_pog_json[p_pog_index].ModuleInfo[p_module_index].X - g_pog_json[p_pog_index].ModuleInfo[p_module_index].W / 2);
                            new_shelf.material = shelf.material.clone(true);
                            var l_wireframe_id = add_wireframe(new_shelf, 4);
                            created_ind = "Y";
                        }
                        if (created_ind == "Y") {
                            g_scene_pdf.add(new_shelf);
                            var shelf_start = shelfX - shelfs.W / 2;
                            g_scene_pdf.updateMatrixWorld();

                            var shelfZ = 0;

                            if (shelfs.ObjType == "TEXTBOX") {
                                shelfZ = g_world.getObjectById(shelfs.SObjID).position.z; //shelfs.Z > 0.0021 ? 0.0021 : shelfs.Z == 0 ? 0.0006 : shelfs.Z;   //ASA-1652 #10
                            } else if (shelfs.ObjType == "PEGBOARD") {
                                shelfZ = 0.003;
                            } else {
                                if (isShelfOnPegboard(shelfs.X, shelfs.Y, p_module_index, p_pog_index, shelfs, g_pog_json)) {
                                    shelfZ = 0.005;
                                } else {
                                    // shelfZ = 0.0005;
                                    shelfZ= g_world.getObjectById(shelfs.SObjID).position.z//ASA-2024.2
                                } //ASA - 1544 Issue 2
                            }
                            new_shelf.position.set(shelfX, shelfs.Y, shelfZ);
                        }
                        k = 0;
                        update_item_distance(p_module_index, j, p_pog_index, "N"); //Bug-26122 - splitting the chest

                        for (const items of shelfs.ItemInfo) {
                            var item = g_world.getObjectById(items.ObjID);
                            if (typeof item !== "undefined") {
                                var new_item = new THREE.Mesh(item.geometry, item.material);
                                // if (shelfs.SpreadItem == "F" || items.CapStyle !== "0" || show_item_desc == "Y") {
                                for (const objects of item.children) {
                                    if (objects.uuid !== "wireframe") {
                                        var child_item = objects.clone(true);
                                        child_item.uuid = objects.uuid;
                                        var new_z;
                                        if (child_item.uuid == "facings") {
                                            new_z = 0.001;
                                        } else if (child_item.uuid == "cap") {
                                            new_z = new_z - 0.0001;
                                        } else if (child_item.uuid == "ITEM_DESC") {
                                            // new_z = 0.005; //ASA-1729 Issue 7
                                            new_z = 0.0006; //ASA-1839 0.0008; //ASA-1729 Issue 7
                                        } else {
                                            new_z = objects.position.z; //ASA-1538    //ASA-1729  //0.009
                                        }
                                        child_item.position.z = new_z;
                                        new_item.add(child_item);
                                    }
                                }
                                // }
                                g_scene_pdf.updateMatrixWorld();
                                new_item.updateMatrixWorld();
                                if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                    var x = items.RotationX;
                                    var y = items.RotationY;
                                    var z = items.RotationZ;
                                    var relativeMeshOffset = new THREE.Vector3(x, y, z);

                                    var offsetPosition = relativeMeshOffset.applyMatrix4(new_shelf.matrixWorld);

                                    new_item.position.x = offsetPosition.x;
                                    new_item.position.y = offsetPosition.y;
                                    new_item.position.z = offsetPosition.z;
                                    new_item.quaternion.copy(new_shelf.quaternion);
                                    new_item.updateMatrix();
                                } else {
                                    if (shelfs.ObjType == "PEGBOARD") {
                                        var new_z = 0.016;
                                    } else {
                                        if (isShelfOnPegboard(shelfs.X, shelfs.Y, p_module_index, p_pog_index, shelfs, g_pog_json)) {
                                            var new_z = 0.005 + shelfs.D / 1000;
                                        } else {
                                            var new_z = 0.001 + shelfs.D / 1000; // ASA - 1573 Issue 1 (0.001 ), ASA- 1608 Issue 1
                                        } //ASA - 1544 Issue 2
                                    }
                                    var new_x = -1;
                                    if (shelfs.ObjType == "BASKET" && shelfs.BsktSpreadProduct == "BT") {
                                        new_x = shelf_start + items.W / 2;
                                    } else {
                                        new_x = shelf_start + items.Distance + items.W / 2;
                                    }
                                    new_item.position.set(new_x, items.Y, new_z);
                                }
                                g_scene_pdf.add(new_item);
                                var l_wireframe_id = add_wireframe(new_item, 4);
                                add_item_borders(p_module_index, j, k, new_item, items.W, items.H, items.BHoriz, p_pog_index, "N"); //Bug-26122 - splitting the chest
                                if (p_new_item_label == "Y") {
                                    var return_val = update_item_label(p_module_index, j, k, new_item, "Y", p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pog_index, "N"); //Bug-26122 - splitting the chest
                                }
                            }
                            k = k + 1;
                        }
                    }
                    j = j + 1;
                }
            }
            //Start Bug-26122 - splitting the chest
            //ASA-1506 issue 1, 2
            if (nvl(g_pog_json[p_pog_index].ModuleInfo[p_module_index].ChestInfo) !== 0 && g_pog_json[p_pog_index].ModuleInfo[p_module_index].ChestInfo.length > 0) {
                j = 0;
                for (const shelfs of g_pog_json[p_pog_index].ModuleInfo[p_module_index].ChestInfo) {
                    var shelf = g_world.getObjectById(shelfs.SObjID);
                    var shelfX = -1;
                    var created_ind = "N";
                    if (shelfs.ObjType == "CHEST" && g_pogcr_pdf_chest_split == "Y") {
                        var new_shelf = new THREE.Mesh(
                            new THREE.BoxGeometry(shelfs.W, shelfs.H, 0.0001), //shelfs.D),
                            new THREE.MeshStandardMaterial({
                                color: shelfs.Color,
                            })
                        );
                        var l_wireframe_id = add_wireframe(new_shelf, 2);
                        new_shelf.material = shelf.material.clone(true);

                        // var new_shelf = shelf.clone(true);
                        shelfX = shelfs.X - (g_pog_json[p_pog_index].ModuleInfo[p_module_index].X - g_pog_json[p_pog_index].ModuleInfo[p_module_index].W / 2);
                        created_ind = "Y";
                    }
                    if (created_ind == "Y") {
                        g_scene_pdf.add(new_shelf);
                        var shelf_start = shelfX - shelfs.W / 2;
                        g_scene_pdf.updateMatrixWorld();
                        var shelfZ = 0;
                        shelfZ = 0.0005;
                        new_shelf.position.set(shelfX, shelfs.Y, shelfZ);
                    }
                    k = 0;
                    update_item_distance(p_module_index, j, p_pog_index, "Y");

                    for (const items of shelfs.ItemInfo) {
                        var item = g_world.getObjectById(items.ObjID);
                        if (typeof item !== "undefined") {
                            var new_item = new THREE.Mesh(item.geometry, item.material);
                            // if (shelfs.SpreadItem == "F" || items.CapStyle !== "0" || show_item_desc == "Y") {
                            for (const objects of item.children) {
                                if (objects.uuid !== "wireframe") {
                                    var child_item = objects.clone(true);
                                    child_item.uuid = objects.uuid;
                                    var new_z;
                                    if (child_item.uuid == "facings") {
                                        new_z = 0.001;
                                    } else if (child_item.uuid == "cap") {
                                        new_z = new_z - 0.0001;
                                    } else if (child_item.uuid == "ITEM_DESC") {
                                        // new_z = 0.005; //ASA-1729 Issue 7
                                        new_z = 0.0006; //ASA-1839 0.0008; //ASA-1729 Issue 7
                                    } else {
                                        new_z = objects.position.z; //ASA-1538    //ASA-1729  //0.009
                                    }
                                    child_item.position.z = new_z;
                                    new_item.add(child_item);
                                }
                            }
                            // }
                            g_scene_pdf.updateMatrixWorld();
                            new_item.updateMatrixWorld();
                            if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                var x = items.RotationX;
                                var y = items.RotationY;
                                var z = items.RotationZ;
                                var relativeMeshOffset = new THREE.Vector3(x, y, z);

                                var offsetPosition = relativeMeshOffset.applyMatrix4(new_shelf.matrixWorld);

                                new_item.position.x = offsetPosition.x;
                                new_item.position.y = offsetPosition.y;
                                new_item.position.z = offsetPosition.z;
                                new_item.quaternion.copy(new_shelf.quaternion);
                                new_item.updateMatrix();
                            } else {
                                var new_z = 0.001 + shelfs.D / 1000;
                                var new_x = -1;
                                new_x = shelf_start + items.Distance + items.W / 2;
                                new_item.position.set(new_x, items.Y, new_z);
                            }
                            g_scene_pdf.add(new_item);
                            var l_wireframe_id = add_wireframe(new_item, 4);
                            add_item_borders(p_module_index, j, k, new_item, items.W, items.H, items.BHoriz, p_pog_index, "Y"); //Bug-26122 - splitting the chest
                            if (p_new_item_label == "Y") {
                                var return_val = update_item_label(p_module_index, j, k, new_item, "Y", p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pog_index, "Y"); //Bug-26122 - splitting the chest
                            }
                        }
                        k = k + 1;
                    }
                    j = j + 1;
                }
            }
            //End Bug-26122 - splitting the chest
            if (g_renderer_pdf !== null) {
                animate_pog_pdf();
            }
        }
        logDebug("function : create_scene", "E");
        return "success";
    } catch (err) {
        error_handling(err);
        throw err;
    }
}

async function merge_textboxes_pdf(p_new_pogjson, p_pog_index) {
    try {
        var max_y = -1;
        for (const modules of p_new_pogjson[p_pog_index].ModuleInfo) {
            if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                for (const shelfs of modules.ShelfInfo) {
                    if (shelfs.ObjType == "TEXTBOX") {
                        max_y = Math.max(max_y, shelfs.Y);
                    }
                }
            }
        }
        l_cnt = 0;
        l_index_arr = [];
        var i = 0;
        for (const modules of p_new_pogjson[p_pog_index].ModuleInfo) {
            if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                var j = 0;
                for (const shelfs of modules.ShelfInfo) {
                    if (shelfs.ObjType == "TEXTBOX") {
                        if (shelfs.W > modules.W && shelfs.W < p_new_pogjson[p_pog_index].W && shelfs.Y >= max_y) {
                            l_cnt++;
                            l_index_arr.push(j);
                        }
                    }
                    j++;
                }
            }
        }
        if (l_cnt > 1) {
            var i = 0;
            for (const modules of p_new_pogjson[p_pog_index].ModuleInfo) {
                if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                    var j = 0;
                    var hit = "N";
                    for (const module_in of p_new_pogjson[p_pog_index].ModuleInfo) {
                        if (hit == "Y") {
                            hit = "N";
                            break;
                        }
                        if ((typeof module_in.ParentModule == "undefined" || module_in.ParentModule == null) && i !== j) {
                            var k = 0;
                            for (const shelfs of module_in.ShelfInfo) {
                                if (shelfs.ObjType == "TEXTBOX") {
                                    var shelf_start = shelfs.X - shelfs.W / 2;
                                    var shelf_end = shelfs.X + shelfs.W / 2;
                                    if (modules.X - modules.W / 2 + modules.W / 3 >= shelf_start && modules.X + modules.W / 2 <= shelf_end && shelfs.Y >= max_y) {
                                        shelfs.MergeTextbox = "Y";
                                        p_new_pogjson[p_pog_index].ModuleInfo[i].ShelfInfo.push(shelfs);
                                        hit = "Y";
                                        break;
                                    }
                                }
                                k++;
                            }
                        }
                        j++;
                    }
                }
                i++;
            }
            var i = 0;
            for (const modules of p_new_pogjson[p_pog_index].ModuleInfo) {
                if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                    var mod_start = modules.X - modules.W / 2;
                    var mod_end = modules.X + modules.W / 2;
                    var k = 0;
                    for (const shelfs of modules.ShelfInfo) {
                        if (shelfs.ObjType == "TEXTBOX") {
                            var shelf_start = shelfs.X - shelfs.W / 2;
                            var shelf_end = shelfs.X + shelfs.W / 2;
                            if (((shelf_start > mod_start && shelf_start >= mod_end) || (shelf_start < mod_start && shelf_end <= mod_start)) && shelfs.Y >= max_y) {
                                p_new_pogjson[p_pog_index].ModuleInfo[i].ShelfInfo.splice(k, 1);
                            }
                        }
                        k++;
                    }
                }
                i++;
            }
        }
        return p_new_pogjson;
    } catch (err) {
        error_handling(err);
        throw err;
    }
}

function getCanvasBlob(p_canvas) {
    return new Promise(function (resolve, reject) {
        p_canvas.toBlob(
            function (blob) {
                resolve(blob);
            },
            "image/jpeg",
            0.5
        );
    });
}

function blobToBase64(p_blob) {
    return new Promise((resolve, _) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.readAsDataURL(p_blob);
    });
}

function send_to_db(p_pog_code, p_img_arr) {
    logDebug("function : send_to_db; pog_code : " + p_pog_code, "S");
    return new Promise(function (resolve, reject) {
        //var pClob = JSON.stringify(p_img_arr);
        var p = apex.server.process(
            "SAVE_MODULE_IMG",
            {
                x01: p_pog_code,
                p_clob_01: JSON.stringify(p_img_arr),
            },
            {
                dataType: "html",
            }
        );
        // When the process is done, call functions
        p.done(function (data) {
            logDebug("function : send_to_db", "E");
            resolve("success");
        });
    });
}

//ASA-1870 Added new parameters from p_enhance_pdf_image to p_pog_pdf_request
async function create_pdf(p_pog_details, p_save_pdf, p_save_pog, p_camera, p_draftPogInd, p_pogcrItemBackLabelColor, p_pogcrItemLabelPosition, p_pogcrDescListArr, p_NotchHead, p_resetZoomInd = "Y", p_pog_index, p_genLiveImg, p_allPogFlag, p_MerchStyle, p_LoadImgFrom, p_Buid, p_ItemNumLblColor, p_ItemNumLblPos, p_DispItemInfo, p_DelistDftColor, p_WorkflowSave = "N", p_DraftSeqID = "", p_ItemDtlList, p_create_img = "Y",
    p_enhance_pdf_image, p_enhance_pdf_ratio, p_canvas_size, p_vdate, p_pog_default_color, p_pog_module_default_color, p_pogcr_dft_spread_product, p_pegb_dft_horiz_spacing, p_pegboard_dft_vert_spacing, p_basket_dft_wall_thickness, p_chest_wall_thickness, p_pegb_max_arrange, p_default_wrap_text, p_cr_default_text_size, p_textbox_default_color, p_shelf_default_color, p_div_color, p_slot_divider, p_slot_orientation, p_fixed_divider, p_pog_item_default_color, p_default_basket_fill, p_default_basket_spread, p_bay_live_image, p_bay_without_live_image, p_bulk_pdf_request) {
    try {
        console.log('textbox cache', g_textbox_merge_pdf);

        logDebug("function : create_pdf; p_pog_details : " + p_pog_details + "; save_pdf : " + p_save_pdf + "; save_pog : " + p_save_pog, "S");
        if (p_resetZoomInd == "Y") {
            reset_zoom(p_pog_index);
        }
        var details_arr = p_pog_details.TemplateDetails.split("-");
      
        var new_live_image = "N";
        var new_item_label = "N";
        var donot_recreate = "N";
        p_create_img = (p_create_img || "").trim() || "Y"; //ASA-1975.1
        if ((details_arr[1] == "Y" && g_show_notch_label == "N") || (details_arr[1] == "Y" && g_show_notch_label == "Y") || (details_arr[1] == "N" && g_show_notch_label == "Y")) {
            show_notch_labels("Y", p_NotchHead, "Y", p_pog_index);
        } else if (details_arr[1] == "N") {
            show_notch_labels("N", p_NotchHead, "Y", p_pog_index);
        }
        if ((details_arr[2] == "Y" && g_show_fixel_label == "N") || (details_arr[2] == "Y" && g_show_fixel_label == "Y") || (details_arr[2] == "N" && g_show_fixel_label == "Y")) {
            show_fixel_labels("Y", p_pog_index);
        } else if (details_arr[2] == "N") {
            show_fixel_labels("N", p_pog_index);
        }
        add_merch("Y", p_pog_index); //ASA-1531 issue 21
        add_merch("N", p_pog_index); //ASA-1531 issue 21
        if (details_arr[6] == "Y" && g_show_item_desc == "N" && p_create_img == "Y") {
            if (g_show_live_image == "Y") {
                var return_val = await recreate_image_items("N", p_MerchStyle, p_LoadImgFrom, p_Buid, p_ItemNumLblColor, p_ItemNumLblPos, p_DispItemInfo, p_DelistDftColor, p_NotchHead, p_pog_index, "N", "", p_ItemDtlList);
                new_live_image = "N";
            }
            var res = await showHideItemDescription("Y", p_pogcrItemBackLabelColor, p_pogcrDescListArr, p_pog_index);
        } else if (details_arr[6] == "N" && g_show_item_desc == "Y" && p_create_img == "Y") {
            var res = await showHideItemDescription("N", p_pogcrItemBackLabelColor, p_pogcrDescListArr, p_pog_index);
        }
        var old_fixel_label = g_show_fixel_label,
            old_notch_label = g_show_notch_label,
            old_item_label = g_show_item_label,
            old_item_desc = g_show_item_desc;

        //if (g_show_live_image == "N" && details_arr[7] == "Y" && details_arr[6] == "N" && p_create_img == "Y") {
        if ((p_save_pdf == "Y" || g_show_live_image === "N") && details_arr[7] === "Y" && details_arr[6] === "N" && p_create_img === "Y") { //Regression 4 
            var return_val = await recreate_image_items("Y", p_MerchStyle, p_LoadImgFrom, p_Buid, p_ItemNumLblColor, p_ItemNumLblPos, p_DispItemInfo, p_DelistDftColor, p_NotchHead, p_pog_index, "N", "", p_ItemDtlList);
            new_live_image = "Y";
        } else if (g_show_live_image == "Y" && details_arr[7] == "N" && p_create_img == "Y") {
            var return_val = await recreate_image_items("N", p_MerchStyle, p_LoadImgFrom, p_Buid, p_ItemNumLblColor, p_ItemNumLblPos, p_DispItemInfo, p_DelistDftColor, p_NotchHead, p_pog_index, "N", "", p_ItemDtlList);
            new_live_image = "N";
        } else if (g_show_days_of_supply == "Y" && details_arr[12] == "N" && g_show_live_image == "Y") {  //ASA-1975.2 Start
            //ASA-1608 Issue 1
            //await showHideDaysOfSupplyLabel("N", "N", p_pog_index, "Y", "N", "", p_ItemDtlList);
            await showHideDaysOfSupplyLabel("Y", "N", p_pog_index, "Y", "N", "", p_ItemDtlList); //ASA-1975.2
            new_live_image = g_show_live_image;
        }else if (g_show_days_of_supply == "Y" && details_arr[12] == "Y") {         
            await showHideDaysOfSupplyLabel("N", "N", p_pog_index, "Y", "N", "", p_ItemDtlList);
            new_live_image = g_show_live_image;
        }  //ASA-1975.2 End
         else {
            new_live_image = g_show_live_image;
        }
        if (g_sublabel_type !== "") {
            //ASA-1533
            showItemSubLabel(g_sublabel_type, "Y", p_ItemNumLblColor, p_ItemNumLblPos, p_pog_index);
        }
        animate_pog(p_pog_index);
        old_live_iamge = g_show_item_desc == "N" ? g_show_live_image : "N";

        if (details_arr[3] == "Y" && g_show_item_label == "N") {
            new_item_label = "Y";
            show_item_labels("Y", p_pogcrItemBackLabelColor, p_pogcrItemLabelPosition, p_pog_index);
        } else if (details_arr[3] == "N") {
            new_item_label = "N";
            show_item_labels("N", p_pogcrItemBackLabelColor, p_pogcrItemLabelPosition, p_pog_index);
        }
        await timeout(200);
        var retval = await set_scene(p_pog_details, p_save_pdf, old_notch_label, old_fixel_label,
            old_item_label, details_arr[4], p_save_pog, details_arr[5], new_item_label, details_arr[6], p_draftPogInd, old_item_desc, old_live_iamge, new_live_image, p_pog_index, p_genLiveImg, p_WorkflowSave, p_DraftSeqID,
            details_arr[9], details_arr[1], details_arr[2], details_arr[3],
            p_enhance_pdf_image, p_enhance_pdf_ratio, p_canvas_size, p_pogcrItemBackLabelColor, p_pogcrItemLabelPosition, p_Buid, p_MerchStyle, p_NotchHead, p_LoadImgFrom, p_pogcrDescListArr, p_DelistDftColor,
            p_vdate, p_pog_default_color, p_pog_module_default_color, p_pogcr_dft_spread_product, p_pegb_dft_horiz_spacing, p_pegboard_dft_vert_spacing, p_basket_dft_wall_thickness,
            p_chest_wall_thickness, p_pegb_max_arrange, p_default_wrap_text, p_cr_default_text_size, p_textbox_default_color, p_shelf_default_color, p_div_color, p_slot_divider, p_slot_orientation, p_fixed_divider, p_pog_item_default_color, p_default_basket_fill, p_default_basket_spread, p_bay_live_image, p_bay_without_live_image, p_bulk_pdf_request); //ASA-1870 added new parameters
        return "SUCCESS";
    } catch (err) {
        error_handling(err);
        throw err;
    }
}

//This function is used inside create_pdf to create each module in different canvas and take screenshot. to place them into pdf.
//ASA-1870, Moved from page_25_wpd_2.js to main.js and added Added new parameters from p_enhance_pdf_image to p_pog_pdf_request
async function set_scene(p_pog_details, p_save_pdf, p_notch_label, p_fixel_label, p_item_label, p_pdf_lang, p_save_pog,
    p_mime_type, p_new_item_label, p_show_item_desc, p_draftPogInd, p_item_desc, p_old_live_iamge,
    p_loaded_live_img, p_pog_index, p_generateLiveImg, p_workflowSave = "N", p_draftSeqID = "", p_combineImgInd, p_pdfnotchlabel, p_pdfFixelLabel, p_pdfItemLabel,
    p_enhance_pdf_image, p_enhance_pdf_ratio, p_canvas_size, p_pogcrItemBackLabelColor, p_pogcrItemLabelPosition, p_Buid, p_MerchStyle, p_NotchHead, p_LoadImgFrom, p_pogcrDescListArr, p_DelistDftColor,
    p_vdate, p_pog_default_color, p_pog_module_default_color, p_pogcr_dft_spread_product, p_pegb_dft_horiz_spacing, p_pegboard_dft_vert_spacing, p_basket_dft_wall_thickness,
    p_chest_wall_thickness, p_pegb_max_arrange, p_default_wrap_text, p_cr_default_text_size, p_textbox_default_color, p_shelf_default_color, p_div_color, p_slot_divider, p_slot_orientation, p_fixed_divider, p_pog_item_default_color, p_default_basket_fill, p_default_basket_spread, p_bay_live_image, p_bay_without_live_image, p_bulk_pdf_request) //ASA-1870 added new parameters 
{
    logDebug("function : set_scene; p_pog_details : " + p_pog_details + "; save_pdf : " + p_save_pdf + "; notch_label : " + p_notch_label + "; fixel_label : " + p_fixel_label + "; item_label : " + p_item_label + "; pdf_lang : " + p_pdf_lang + "; save_pog : " + p_save_pog + "; mime_type : " + p_mime_type + "; new_item_label : " + p_new_item_label, "S");
    var img_arr = [];
    render(p_pog_index);
    var base64;
    var comp_data = "";
    var noDataModuleWIdth = 0;
    var nodataModule = false;
    var enhance = 0.5;
    if (p_enhance_pdf_image == "Y") {
        enhance = parseFloat(p_enhance_pdf_ratio);
    }
    if (typeof p_combineImgInd !== "undefined") {
        var combine_details = p_combineImgInd.split("###");
    } else {
        var combine_details = [];
    }
    reset_zoom();
    var new_pogjson = [];
    if (p_bulk_pdf_request == "N") {
        set_pegid(p_pog_index);
    }
    // ASA-1235
    // Replaced new_pogjson and new_pogjson[0] to new_pogjson[p_pog_index]

    if (p_mime_type == "xlsx") {
        var res = await save_pog_to_json([g_pog_json[p_pog_index]]);
    }

    //ASA-1235 START
    var updateOrgPOGJSON = JSON.parse(JSON.stringify(g_pog_json));
    //Start Sprint 20240122 - Regression Issue 10
    // according to requirement if there is a chest spanning to more than one module then we need to split them into
    //pieces which will fit into each module for purpose of PDF.
    await get_chest_split_details(g_pogcr_pdf_chest_split, p_pog_index); // Sprint 20240122 - Regression Issue 10

    new_pogjson = JSON.parse(JSON.stringify(g_pog_json));

    //if text boxes are out of the module then we need to change that to the module where max width is occupied.
    if (g_textbox_merge_pdf == "Y") {
        var new_pogjson = await merge_textboxes_pdf(new_pogjson, p_pog_index); //0
    }
    var i = 0;
    var mod_count = 0;
    for (const modules of new_pogjson[p_pog_index].ModuleInfo) {
        if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
            mod_count++;
        }
    }

    //ASA-1702 Issue 1, shifted to dynamic action of SAVE_POG/SAVE_PDF button
    //Regression 9 20241025
    // apex.server.process(
    //     "TRUNC_MOD_IMG_COLL", {
    //     x01: "",
    // }, {
    //     dataType: "text",
    //     success: function (pData) {
    //         console.log('Module Image collection truncated');
    //     }
    // });
    var i = 0;
    //this loop will create module wise image with shelf and items.
    for (const modules of new_pogjson[p_pog_index].ModuleInfo) {
        if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
            /*if (typeof g_renderer_pdf !== "undefined" && g_renderer_pdf !== null && g_renderer_pdf !== "") { //ASA-1366
            g_renderer_pdf.forceContextLoss();
            g_renderer_pdf.context = null;
            g_renderer_pdf.domElement = null;
            g_renderer_pdf = null;
            }*/
            var can_dim_arr = p_canvas_size.split(":"); //start ASA-1310 prasanna ASA-1310_25890
            await init_pdf(parseInt(can_dim_arr[0]), parseInt(can_dim_arr[1]), 3 + (enhance == 0.5 ? 0 : 3 * enhance), "N", "Y"); //added clearthree function in init_pdf so aded await
            //end ASA-1310 prasanna ASA-1310_25890
            try {
                nodataModule = false;
                var k = 0;
                noDataModuleWIdth = 0;
                var prevModule = "-1";
                if (!modules.Module.includes(g_nodataModuleName)) {
                    var moduleX = new_pogjson[p_pog_index].ModuleInfo[i].W;
                    for (var mod of new_pogjson[p_pog_index].ModuleInfo) {
                        prevModule = modules.Module;
                        if (k > i) {
                            if (nvl(mod.ParentModule) == 0 && mod.Module.includes(g_nodataModuleName)) {
                                var module = g_world.getObjectById(mod.MObjID);
                                var moduleY = mod.H / 2 + g_pog_json[p_pog_index].BaseH;
                                noDataModuleWIdth = noDataModuleWIdth + mod.W + 0.01;
                                moduleX = moduleX + mod.W / 2 + 0.01;
                                var new_module = module.clone(true);
                                new_module.material = module.material.clone(true);
                                g_scene_pdf.add(new_module);
                                new_module.position.set(moduleX, moduleY, 0);
                                moduleX = moduleX + mod.W / 2;
                                g_scene_pdf.updateMatrixWorld();
                            }
                        }
                        k++;
                    }
                }
                //this function will create the object for one module at a time in g_new_canvas, which is hidden and will not show to the
                //user. we take screen shot of this canvas in a loop and add in array.
                var return_val = await create_scene(i, p_new_item_label, p_show_item_desc, mod_count, p_loaded_live_img, p_pogcrItemBackLabelColor, p_pogcrItemLabelPosition, noDataModuleWIdth, p_pog_index); //ASA-1870
            } catch (err) {
                error_handling(err);
            }
            var details = get_min_max_xy_module(modules, i, modules.W + noDataModuleWIdth, modules.H, modules.X + noDataModuleWIdth, new_pogjson[p_pog_index].W, mod_count);
            var details_arr = details.split("###");
            var [cameraz, new_y] = set_camera_z_offside(g_camera_pdf, parseFloat(details_arr[2]), parseFloat(details_arr[3]), parseFloat(details_arr[0]), parseFloat(details_arr[1]), g_offset_z, 0, parseFloat(details_arr[5]), true, p_pog_index);
            g_camera_pdf.position.x = parseFloat(details_arr[2]);
            g_camera_pdf.position.y = parseFloat(details_arr[3]);
            g_camera_pdf.position.z = cameraz; //ASA-1370  isssue 2 + g_offset_z
            if (g_renderer_pdf !== null) {
                animate_pog_pdf();
                g_renderer_pdf.render(g_scene_pdf, g_camera_pdf);
            }

            base64 = "";
            //g_nodataModuleName will have few module names. that do not be printed in PDF. so we avoid that.
            if (!modules.Module.includes(g_nodataModuleName)) {
                var dataURL = await g_new_canvas.toDataURL("image/jpeg", enhance);
                var img_details = {};
                img_details["Module"] = modules.Module;
                img_details["MIndex"] = i;
                img_details["Bay"] = (modules.W * 100).toFixed(2);
                img_details["TotalBay"] = (modules.H * 100).toFixed(2) + "*" + (modules.W * 100).toFixed(2);
                img_details["ImgData"] = dataURL.match(/,(.*)$/)[1];
                img_arr.push(img_details);
            }
        }
        i++;
    }

    //ASA-1627 Start
    /*
        Added a for loop because we need to remove the whitespace from each screenshot of an module.
        Except removing of whitespace all code is existing which is written under if block(if(imgCount == img_arr.length))
     */
    var imgCount = 0;
    for (const mod_img of img_arr) {
        const webglImage = "data:image/jpeg;base64," + mod_img.ImgData;
        console.log(webglImage);
        const img = new Image();
        img.src = webglImage;
        // img.onload = async function () { //ASA-1710
        await new Promise(
            (resolve) =>
            (img.onload = async function () {
                const canvas2D = document.createElement("canvas");
                canvas2D.width = img.width;
                canvas2D.height = img.height;
                const ctx2D = canvas2D.getContext("2d");
                ctx2D.drawImage(img, 0, 0);
                //ASA-1787, added combine_details[4] == "Y", crop_img_ind
                if (combine_details[4] == "Y") {
                    var [croppedCanvas, scaleToFit] = cropCanvasToContent(canvas2D); //ASA-1820
                    new_pogjson[p_pog_index].ModuleInfo[mod_img.MIndex].ScaleToFit = scaleToFit; //ASA-1820
                    if (imgCount == 0) {
                        if (scaleToFit == "Y") {
                            new_pogjson[p_pog_index].PageBreakInit = "Y"; //ASA-1820
                        } else {
                            new_pogjson[p_pog_index].PageBreakInit = "N"; //ASA-1820
                        }
                    }
                    var croppedDataURL = croppedCanvas.toDataURL("image/jpeg", enhance);
                } else {
                    var [cropCanvas, scaleToFit] = cropCanvasToContent(canvas2D); //ASA-1831
                    new_pogjson[p_pog_index].ModuleInfo[mod_img.MIndex].ScaleToFit = scaleToFit; //ASA-1831
                    var croppedCanvas = cropCanvasToContent_old(canvas2D);
                    var croppedDataURL = croppedCanvas.toDataURL("image/jpeg", enhance);
                }
                img_arr[imgCount].ImgData = croppedDataURL.match(/,(.*)$/)[1];
                imgCount++;
                if (imgCount == img_arr.length) {
                    if (img_arr.length > 0) {
                        //to send module image first and then combine so the array length is less. //ASA-1366
                        await send_to_db(g_pog_json[p_pog_index].POGCode, img_arr); //ASA -1374 passing hardcode index to pog and mulitple pog not getting the image of module g_pog_json[0] -->g_pog_json[p_pog_index]
                        img_arr = [];
                    }

                    for (const modules of new_pogjson[p_pog_index].ModuleInfo) {
                        if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                            for (const shelfs of modules.ShelfInfo) {
                                if (shelfs.ObjType == "TEXTBOX") {
                                    var shelf = g_scene_objects[p_pog_index].scene.children[2].getObjectById(shelfs.SObjID);
                                    if (typeof shelf !== "undefined") {
                                       shelf.material.transparent = true;
                                    }
                                }
                            }
                        }
                    }
                    g_pog_json = updateOrgPOGJSON; //ASA-1235 ASA-1300 this was inside the dowload pdf before recreate, but which was taken before recreate inside combine. so added before.
                    var combine_img = [];
                    if (combine_details[3] == "Y") {
                        //ASA-1730 Start
                        // var totMod = g_pog_json[p_pog_index].ModuleInfo.length;
                        var totMod = 0;
                        for (const module of g_pog_json[p_pog_index].ModuleInfo) {
                            if (typeof module.ParentModule == "undefined" || module.ParentModule == null) {
                                totMod++;
                            }
                        }
                        //ASA-1730 End
                        var bayCount = 0;
                        if (totMod <= 5) {
                            bayCount = totMod;
                        } else {
                            bayCount = parseInt(totMod / 2);
                        }
                        combine_img = await create_combine_pog(bayCount, g_show_live_image, "N", p_vdate, p_pog_default_color, p_pog_module_default_color, p_pogcr_dft_spread_product, parseFloat(p_pegb_dft_horiz_spacing), parseFloat(p_pegboard_dft_vert_spacing), parseFloat(p_basket_dft_wall_thickness), parseFloat(p_chest_wall_thickness), p_pegb_max_arrange, p_default_wrap_text, parseInt(p_cr_default_text_size), p_textbox_default_color, p_shelf_default_color, p_div_color, p_slot_divider, p_slot_orientation, p_fixed_divider, p_pog_item_default_color, p_DelistDftColor, p_MerchStyle, p_LoadImgFrom, p_Buid, p_pogcrItemBackLabelColor, p_pogcrDescListArr, p_pogcrItemLabelPosition, p_NotchHead, p_default_basket_fill, p_default_basket_spread, p_pog_index, p_pdfnotchlabel, p_pdfFixelLabel, p_pdfItemLabel, enhance, p_pogcrItemBackLabelColor, p_pogcrItemLabelPosition, p_pogcrItemBackLabelColor, p_pogcrDescListArr, combine_details[3]); //ASA-1331 kush fix
                        for (const obj of combine_img) {
                            img_arr.push(obj);
                        }
                        // animate_pog_pdf();
                        // render(p_pog_index);
                    } //ASA-1640
                    //below logic is specifically for PNSHK. where we combine multiple modules based on the setup in sm_pog_pdf_template and take screen shots
                    //and place in the PDF before report of item details.
                    else if (combine_details[0] == "Y") {
                        if (combine_details[1] == "Y") {
                            combine_img = await create_combine_pog(p_bay_live_image, "Y", "N", p_vdate, p_pog_default_color, p_pog_module_default_color, p_pogcr_dft_spread_product, parseFloat(p_pegb_dft_horiz_spacing), parseFloat(p_pegboard_dft_vert_spacing), parseFloat(p_basket_dft_wall_thickness), parseFloat(p_chest_wall_thickness), p_pegb_max_arrange, p_default_wrap_text, parseInt(p_cr_default_text_size), p_textbox_default_color, p_shelf_default_color, p_div_color, p_slot_divider, p_slot_orientation, p_fixed_divider, p_pog_item_default_color, p_DelistDftColor, p_MerchStyle, p_LoadImgFrom, p_Buid, p_pogcrItemBackLabelColor, p_pogcrDescListArr, p_pogcrItemLabelPosition, p_NotchHead, p_default_basket_fill, p_default_basket_spread, p_pog_index, p_pdfnotchlabel, p_pdfFixelLabel, p_pdfItemLabel, enhance, p_pogcrItemBackLabelColor, p_pogcrItemLabelPosition, p_pogcrItemBackLabelColor, p_pogcrDescListArr); //ASA-1331 kush fix
                            for (const obj of combine_img) {
                                img_arr.push(obj);
                            }
                        }
                        if (combine_details[2] !== "N") {
                            //ASA-1366
                            combine_img = await create_combine_pog(p_bay_without_live_image, "N", combine_details[2], p_vdate, p_pog_default_color, p_pog_module_default_color, p_pogcr_dft_spread_product, parseFloat(p_pegb_dft_horiz_spacing), parseFloat(p_pegboard_dft_vert_spacing), parseFloat(p_basket_dft_wall_thickness), parseFloat(p_chest_wall_thickness), p_pegb_max_arrange, p_default_wrap_text, parseInt(p_cr_default_text_size), p_textbox_default_color, p_shelf_default_color, p_div_color, p_slot_divider, p_slot_orientation, p_fixed_divider, p_pog_item_default_color, p_DelistDftColor, p_MerchStyle, p_LoadImgFrom, p_Buid, p_pogcrItemBackLabelColor, p_pogcrDescListArr, p_pogcrItemLabelPosition, p_NotchHead, p_default_basket_fill, p_default_basket_spread, p_pog_index, p_pdfnotchlabel, p_pdfFixelLabel, p_pdfItemLabel, enhance, p_pogcrItemBackLabelColor, p_pogcrItemLabelPosition, p_pogcrItemBackLabelColor, p_pogcrDescListArr); //ASA-1331 kush fix
                            for (const obj of combine_img) {
                                img_arr.push(obj);
                            }
                            p_loaded_live_img = "N";
                            p_item_desc = "N";
                        }
                        // animate_pog_pdf();
                        // render(p_pog_index);
                    } else {
                        var main_canvas;
                        main_canvas = await get_full_canvas(p_pog_index, 3);
                        var dataURL = main_canvas.toDataURL("image/jpeg", 0.9);
                        var img_details = {};
                        img_details["Module"] = "POG";
                        img_details["ImgData"] = dataURL.match(/,(.*)$/)[1];
                        img_arr.push(img_details);
                    }
                    //ASA-1640 #8 Start
                    imgCount = 0;
                    for (const mod_img of img_arr) {
                        const webglImage = "data:image/jpeg;base64," + mod_img.ImgData;
                        console.log(webglImage);
                        const img = new Image();
                        img.src = webglImage;
                        img.onload = async function () {
                            const canvas2D = document.createElement("canvas");
                            canvas2D.width = img.width;
                            canvas2D.height = img.height;
                            const ctx2D = canvas2D.getContext("2d");
                            ctx2D.drawImage(img, 0, 0);

                            //ASA-1787, added combine_details[4] == "Y", crop_img_ind
                            if (combine_details[3] == "Y") {
                                if (combine_details[4] == "Y") {
                                    var [croppedCanvas, scaleToFit] = cropCanvasToContent(canvas2D); //ASA-1820
                                    var croppedDataURL = croppedCanvas.toDataURL("image/jpeg", enhance);
                                } else {
                                    var croppedCanvas = cropCanvasToContent_old(canvas2D);
                                    var croppedDataURL = croppedCanvas.toDataURL("image/jpeg", enhance);
                                }
                            } else {
                                var croppedCanvas = cropCanvasToContent_old(canvas2D); //ASA-1831 To run cropCanvasToContent_old when combine_details[3] = N
                                croppedDataURL = canvas2D.toDataURL("image/jpeg", enhance);
                            } //ASA-1640 #8
                            img_arr[imgCount].ImgData = croppedDataURL.match(/,(.*)$/)[1];
                            imgCount++;
                            if (imgCount == img_arr.length) {
                                if (combine_details[3] == "Y" || combine_details[0] == "Y") {
                                    animate_pog_pdf();
                                    render(p_pog_index);
                                }
                                var return_val = await send_to_db(new_pogjson[p_pog_index].POGCode, img_arr);
                                if (p_bulk_pdf_request == "N") {
                                    await uploadImage(0);
                                }
                                else {
                                    set_pegid(new_pogjson, p_pog_index);
                                }
                                await create_item_compare(p_pog_details.POGCode, p_pog_details.POGVersion);

                                var p_pog_version = "";
                                p_pog_version = new_pogjson[p_pog_index].Version;
                                if (p_bulk_pdf_request == "Y") {
                                    //calling PDF creation function
                                    var p = apex.server.process(
                                        "DOWNLOAD_PDF", {
                                        x01: p_pog_details.SeqNo,
                                        x02: p_pog_details.POGCode,
                                        x03: p_pog_details.POGVersion,
                                        x04: p_pog_details.Selection_Type,
                                        x05: p_pog_details.Print_Type,
                                        x06: p_pog_details.TemplateId,
                                        x07: p_pog_details.SequenceId,
                                        x08: 'Y', //save_pog_pdf
                                        x09: '', // pog_module
                                        p_clob_01: JSON.stringify(new_pogjson),
                                    }, {
                                        dataType: "html",
                                    });
                                    p.done(function (data) {
                                        console.log(' download_pdf end', getDateTime());
                                        g_req_count++;
                                        removeLoadingIndicator(regionloadWait);
                                        return "success";
                                    });
                                    console.log('after download pdf');
                                }
                                else {
                                    //calling PDF creation function
                                    var p = apex.server.process(
                                        "DOWNLOAD_PDF",
                                        {
                                            x01: p_pog_details.SeqNo,
                                            x02: new_pogjson[p_pog_index].POGCode,
                                            x03: p_pog_version,
                                            x04: p_pog_details.Selection_Type,
                                            x05: "P",
                                            x06: p_pog_details.TemplateId,
                                            x07: p_workflowSave == "Y" ? p_draftSeqID : "",
                                            x08: p_save_pdf,
                                            x09: p_draftPogInd, // ASA-1444
                                            x10: $v("P25_EXISTING_DRAFT_VER"), //ASA-1444
                                            x11: $v("P25_DEFAULT_LIVE_VERSION"), //ASA-1677 #4
                                            x12: $v("P25_PREV_PDF_POG_VERSION"), //ASA-1677 #4
                                            p_clob_01: JSON.stringify(new_pogjson[p_pog_index]),
                                        },
                                        {
                                            dataType: "html",
                                        }
                                    );
                                    p.done(function (data) {
                                        //we on few labels in the WPD pog for the setup done in sm_pog_pdf_template to get the image of Module wise image.
                                        //we need to reset all the labels bask to the original that was before creating PDF.
                                        p_fixel_label == "Y" ? (g_show_fixel_label = "Y") : (g_show_fixel_label = "N");
                                        p_item_label == "Y" ? (g_show_item_label = "Y") : (g_show_item_label = "N");
                                        p_notch_label == "Y" ? (g_show_notch_label = "Y") : (g_show_notch_label = "N");
                                        p_item_desc == "Y" ? (g_show_item_desc = "Y") : (g_show_item_desc = "N");
                                        if (p_pog_version === undefined || p_pog_version === null) {
                                            //ASA-1813
                                            p_pog_version = "";
                                        }

                                        var l_url = "f?p=" + $v("pFlowId") + ":" + $v("pFlowStepId") + ":" + $v("pInstance") + ":APPLICATION_PROCESS=OPEN_PDF:NO::AI_RANDOM_STRING,P25_OPEN_POG_CODE,P25_OPEN_POG_VERSION:" + new Date().getTime() + "," + new_pogjson[p_pog_index].POGCode + "," + p_pog_version; //ASA-1553
                                        try {
                                            if (typeof regionloadWait !== "undefined" && typeof regionloadWait.remove == "function") {
                                                removeLoadingIndicator(regionloadWait);
                                            }
                                        } catch {
                                            console.log("no loading");
                                        }

                                        logDebug("function : Download PDF", "E");
                                        if (g_all_pog_flag == "N") {
                                            window.open(l_url, "new data");
                                        }

                                        async function do_something() {
                                            if (p_old_live_iamge == "N" && p_loaded_live_img == "Y" && p_generateLiveImg != "N") {
                                                var return_val = await recreate_image_items("N", p_MerchStyle, p_LoadImgFrom, p_Buid, p_pogcrItemBackLabelColor, p_pogcrItemLabelPosition, p_pogcrDescListArr, p_DelistDftColor, p_NotchHead, p_pog_index, g_show_days_of_supply, "", g_hide_show_dos_label); //ASA-1427 $v('P25_POGCR_ITEM_DETAIL_LIST') //ASA-1608 added g_show_days_of_supply, before "N"
                                            } else if (p_old_live_iamge == "Y" && p_loaded_live_img == "N" && p_generateLiveImg != "N") {
                                                var return_val = await recreate_image_items("Y", p_MerchStyle, p_LoadImgFrom, p_Buid, p_pogcrItemBackLabelColor, p_pogcrItemLabelPosition, p_pogcrDescListArr, p_DelistDftColor, p_NotchHead, p_pog_index, g_show_days_of_supply, "", g_hide_show_dos_label); //ASA-1427 $v('P25_POGCR_ITEM_DETAIL_LIST') //ASA-1608 added g_show_days_of_supply, before "N"
                                            }
                                            if (p_show_item_desc == "Y" && p_item_desc == "N") {
                                                var res = await showHideItemDescription("N", p_pogcrItemBackLabelColor, p_pogcrDescListArr, p_pog_index);
                                            } else if (p_show_item_desc == "N" && p_item_desc == "Y") {
                                                var res = await showHideItemDescription("Y", p_pogcrItemBackLabelColor, p_pogcrDescListArr, p_pog_index);
                                            }
                                            if (g_show_notch_label == "Y") {
                                                await show_notch_labels("Y", p_NotchHead, "Y", p_pog_index);
                                            } else {
                                                await show_notch_labels("N", p_NotchHead, "Y", p_pog_index);
                                            }
                                            if (g_show_fixel_label == "Y") {
                                                await show_fixel_labels("Y", p_pog_index);
                                            } else {
                                                await show_fixel_labels("N", p_pog_index);
                                            }
                                            if (g_show_item_label == "Y") {
                                                await show_item_labels("Y", p_pogcrItemBackLabelColor, p_pogcrItemLabelPosition, p_pog_index);
                                            } else {
                                                await show_item_labels("N", p_pogcrItemBackLabelColor, p_pogcrItemLabelPosition, p_pog_index);
                                            }
                                            await showItemSubLabel(g_itemSubLabel, g_itemSubLabelInd, p_pogcrItemBackLabelColor, p_pogcrItemLabelPosition, p_pog_index); //ASA-1182
                                        }
                                        do_something();
                                    });
                                }
                            }
                        };
                    }
                }
                resolve(); //ASA-1710
            })
        );
    }
    //ASA-1627 End

    logDebug("function : set_scene", "E");
}

//Replace this with new dynamic (cropCanvasToContent) once enhanced for all bu's 
//ASA-1870, Moved from page_25_wpd_1.js to main.js
function cropCanvasToContent_old(canvas) {
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;

    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    let cropTop = null, cropBottom = null, cropLeft = null, cropRight = null;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = (y * width + x) * 4;
            // ASA-1706, if (data[index] < 250 || data[index + 1] < 250 || data[index + 2] < 250) {
            if (data[index] !== 255 && data[index + 1] !== 255 && data[index + 2] !== 255) {
                if (cropTop === null) cropTop = y;
                cropBottom = y;
                if (cropLeft === null || x < cropLeft) cropLeft = x;
                if (cropRight === null || x > cropRight) cropRight = x;
            }
        }
    }

    if (cropTop === null) return canvas;

    //ASA-1925 Calculate content dimensions
    const contentWidth = cropRight - cropLeft + 1;

    var croppedWidth = cropRight - cropLeft + 40; //ASA-1706, 80
    var croppedHeight = cropBottom - cropTop + 40;
    var cropWidthDiff = width - croppedWidth;
    var cropHeightDiff = height - croppedHeight;

    const croppedCanvas = document.createElement("canvas");

    //ASA-1706
    if (cropWidthDiff >= cropHeightDiff) {
        cropWidthDiff = width - cropHeightDiff;
        croppedWidth = cropWidthDiff;
        croppedCanvas.width = cropWidthDiff;
        croppedCanvas.height = croppedHeight;
    } else {
        cropHeightDiff = height - cropWidthDiff;
        croppedHeight = cropHeightDiff;
        croppedWidth = cropRight + 40;   //ASA-1730
        croppedCanvas.width = croppedWidth;
        croppedCanvas.height = cropHeightDiff;
    }
    // croppedCanvas.width = croppedWidth; //ASA-1706
    // croppedCanvas.height = croppedHeight;//ASA-1706
    const centerX = (croppedCanvas.width - contentWidth) / 2; //ASA-1925
    const croppedCtx = croppedCanvas.getContext("2d");
    croppedCtx.fillStyle = "white";
    croppedCtx.fillRect(0, 0, croppedWidth, croppedHeight);
    // croppedCtx.drawImage(canvas, cropLeft, cropTop, croppedWidth, croppedHeight, 40, 20, croppedWidth, croppedHeight); //ASA-1706
    // croppedCtx.drawImage(canvas, cropLeft, cropTop, croppedWidth, croppedHeight, cropLeft - 40, 20, croppedWidth, croppedHeight);//ASA-1706 //ASA-1730
    // croppedCtx.drawImage(canvas, cropLeft, cropTop, croppedWidth, croppedHeight, cropLeft - 40, (cropTop - 40 < 0 ? 20 : cropTop - 40), croppedWidth, croppedHeight);//ASA-1706 //ASA-1730
    croppedCtx.drawImage(canvas, cropLeft, cropTop, croppedWidth, croppedHeight, centerX, 40, croppedWidth, croppedHeight);//ASA-1706 //ASA-1730 Issue 1 //ASA-1925
    return croppedCanvas;
}





//ASA-1787, Modfied primary logic to centre the image and maintain aspect raio
//ASA-1870, Moved from page_25_wpd_1.js to main.js
function cropCanvasToContent(canvas) {
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;

    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    let cropTop = null,
        cropBottom = null,
        cropLeft = null,
        cropRight = null;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = (y * width + x) * 4;
            // Only exclude pure white
            if (data[index] !== 255 || data[index + 1] !== 255 || data[index + 2] !== 255) {
                if (cropTop === null) cropTop = y;
                cropBottom = y;
                if (cropLeft === null || x < cropLeft) cropLeft = x;
                if (cropRight === null || x > cropRight) cropRight = x;
            }
        }
    }

    if (cropTop === null) return canvas; // all white

    const contentWidth = cropRight - cropLeft + 1;
    const contentHeight = cropBottom - cropTop + 1;

    const scaleToFit = parseFloat((contentHeight / contentWidth).toFixed(1)) >= 1.2 ? 'Y' : 'N'; //ASA-1820
    let finalWidth = contentWidth;
    let finalHeight = contentHeight;

    // Adjust to maintain original aspect ratio
    // const contentAspect = contentWidth / contentHeight;

    // if (contentAspect > originalAspect) {
    // 	// Too wide, add vertical padding
    // 	finalHeight = Math.round(contentWidth / originalAspect);
    // } else if (contentAspect < originalAspect) {
    // 	// Too tall, add horizontal padding
    // 	finalWidth = Math.round(contentHeight * originalAspect);
    // }

    const offsetX = Math.floor((finalWidth - contentWidth) / 2);
    const offsetY = Math.floor((finalHeight - contentHeight) / 2);

    const resultCanvas = document.createElement("canvas");
    resultCanvas.width = finalWidth;
    resultCanvas.height = finalHeight;

    const resultCtx = resultCanvas.getContext("2d");
    resultCtx.fillStyle = "white";
    resultCtx.fillRect(0, 0, finalWidth, finalHeight);

    resultCtx.drawImage(canvas, cropLeft, cropTop, contentWidth, contentHeight, offsetX, offsetY, contentWidth, contentHeight);

    return [resultCanvas, scaleToFit];
}

//ASA-1870, Moved from page_25_wpd_4.js to main.js and added pog code and version as a parameter
async function create_item_compare(p_pog_Code, p_pog_version) {
    var l_version = g_pog_json[g_pog_index].DraftVersion;  //ASA 2058
    $s('P25_DRAFT_VERSION', l_version);         //ASA 2058

    var v_x04 = (l_version === null || l_version === undefined || l_version === '') ? 'N' : 'Y'; //ASA 2058

    var p = apex.server.process(
        "CREATE_COMPARE_ITEM_COLL",
        {
            x01: p_pog_Code,
            x02: p_pog_version,
            x03: g_pdf_online_clck, //ASA-1531 ISSUE 16
            x04: v_x04,   //ASA 2058
        },
        {
            dataType: "html",
        }
    );
}


async function create_combine_pog(p_BayCount, p_showLiveImg, p_Desc, p_Vdate, p_PogDftColor, p_ModDftColor, p_DftSpreadProduct, p_DftHorizSpac, p_DftVertSpac, p_BskWallThick, p_ChestWallThick, p_PegItemAutoPlace, p_DftWrapText, p_TextDftSize, p_TextDftColor, p_ShelfDftColor, p_DivColor, p_SlotDivider, p_SlotOrient, p_DivFixed, p_ItemDftColor, p_DelistDftColor, p_MerchStyle, p_LoadImgFrom, p_Buid, p_ItemNumLblColor, p_DispItemInfo, p_ItemNumLblPos, p_NotchHead, p_DftBskFill, p_DftBaskSprd, p_pog_index, p_pdfnotchlabel, p_PdfFixelLabel, p_PdfItemLabel, p_enhance, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrItemBackLabelColor, p_pogcrDescListArr, p_pog_split_ind = "N" /*ASA-1640*/) {
    try {
        var old_live_image = g_show_live_image;
        var old_item_desc = g_show_item_desc;
        var mod_array = [];
        var z = 0;
        var next_mod = 0;
        var mod_width = 0;
        var base_width = 0;
        var img_arr = [];
        var total_width = 0;
        var total_height = 0;
        var total_depth = 0;
        var bay = "";
        var total_mod_cnt = 0;
        var count = 0;
        if (p_Desc == "Y" || p_Desc == "IDVURPCO" || p_Desc == "IFEC") {
            await recreate_image_items("N", p_MerchStyle, p_LoadImgFrom, p_Buid, p_ItemNumLblColor, p_ItemNumLblPos, p_DispItemInfo, p_DelistDftColor, p_NotchHead, p_pog_index, "N", "N,0.018", []);
            var res = await showHideItemDescription("Y", p_pogcrItemBackLabelColor, p_pogcrDescListArr, p_pog_index);
            render(p_pog_index);
        } else if (g_show_live_image == "N" && p_showLiveImg == "Y") {
            await recreate_image_items("Y", p_MerchStyle, p_LoadImgFrom, p_Buid, p_ItemNumLblColor, p_ItemNumLblPos, p_DispItemInfo, p_DelistDftColor, p_NotchHead, p_pog_index, "N", "N,0.018", []);
        }
        g_world = g_scene_objects[p_pog_index].scene.children[2];
        animate_pog(p_pog_index);
        var updatePogjson = JSON.parse(JSON.stringify(g_pog_json)); //ASA-1235
        var old_pogjson = JSON.parse(JSON.stringify(g_pog_json));
        var new_pogjson = JSON.parse(JSON.stringify([g_pog_json[p_pog_index]]));
        console.log("old_pogjson[0].ModuleInfo", old_pogjson[0].ModuleInfo);

        if (p_showLiveImg == "Y") {
            g_show_live_image = "Y";
            g_show_item_desc = "N";
        } else if (p_Desc == "Y" || p_Desc == "IDVURPCO" || p_Desc == "IFEC") {
            if (p_Desc == "IDVURPCO" || p_Desc == "IFEC") {
                g_temp_desc = p_Desc;
            } else {
                g_temp_desc = "N";
            }
            g_show_live_image = "N";
            g_show_item_desc = "Y";
        }
        if (p_pdfnotchlabel == "Y") {
            g_show_notch_label = "Y";
        } else {
            g_show_notch_label = "N";
        }
        if (p_PdfFixelLabel == "Y") {
            g_show_fixel_label = "Y";
        } else {
            g_show_fixel_label = "N";
        }
        if (p_PdfItemLabel == "Y") {
            g_show_item_label = "Y";
        } else {
            g_show_item_label = "N";
        }

        //ASA-1235 START
        var pogChests = [];
        var mIndex = 0;
        for (const modules of old_pogjson[p_pog_index].ModuleInfo) {
            //ASA-1331 KUSH fix
            if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                total_mod_cnt++;
                total_width = total_width + modules.W;
                total_height = Math.max(total_height, modules.H);
                total_depth = Math.max(total_depth, modules.D);

                if (g_pogcr_pdf_chest_split == "Y") {
                    var sIndex = 0;
                    var moduleStart = wpdSetFixed(modules.X - modules.W / 2); //.toFixed(4));
                    var moduleEnd = wpdSetFixed(modules.X + modules.W / 2); //.toFixed(4));
                    for (const shelf of modules.ShelfInfo) {
                        if (shelf.ObjType == "CHEST") {
                            var shelfStart = wpdSetFixed(shelf.X - shelf.W / 2); //.toFixed(4));
                            var shelfEnd = wpdSetFixed(shelf.X + shelf.W / 2); //.toFixed(4));
                            if ((moduleStart > shelfStart && moduleEnd < shelfEnd) || (moduleStart >= shelfStart && moduleEnd < shelfEnd) || (moduleStart < shelfStart && moduleEnd < shelfEnd && moduleEnd > shelfStart) || (moduleStart > shelfStart && moduleEnd > shelfEnd && moduleStart < shelfEnd)) {
                                //Regression-10 issue for chest pdf, added =
                                shelf.MIndex = mIndex;
                                shelf.SIndex = sIndex;
                                pogChests.push(shelf);
                                new_pogjson[0].ModuleInfo[mIndex].ShelfInfo.splice(sIndex, 1);
                                g_pog_json[p_pog_index].ModuleInfo[mIndex].ShelfInfo.splice(sIndex, 1); //ASA-1306
                            }
                        }
                        sIndex++;
                    }
                }
            }
            mIndex++;
        }

        if (g_pogcr_pdf_chest_split == "Y") {
            var ci = 0; //ASA-1314
            for (chest of pogChests) {
                var chest_insert = "N"; //ASA-1306
                // update old_pogjson modules with individual chest and updated item info
                var chestStart = wpdSetFixed(chest.X - chest.W / 2); //.toFixed(4));
                var chestEnd = wpdSetFixed(chest.X + chest.W / 2); //.toFixed(4));
                var chestItems = chest.ItemInfo;
                var mi = 0;
                for (const modules of new_pogjson[0].ModuleInfo) {
                    if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                        var mStart = wpdSetFixed(modules.X - modules.W / 2); //.toFixed(4));
                        var mEnd = wpdSetFixed(modules.X + modules.W / 2); //.toFixed(4));
                        var newChest = JSON.parse(JSON.stringify(chest));

                        if (mStart >= chestStart && mEnd <= chestEnd) {
                            //Regression-10 issue for chest pdf, added =
                            chest_insert = "Y"; //ASA-1306
                            newChest.W = modules.W;
                            newChest.X = modules.X;
                        } else if (mStart <= chestStart && mEnd <= chestEnd && mEnd > chestStart) {
                            //ASA-1351 issue 5
                            chest_insert = "Y"; //ASA-1306
                            newChest.W = wpdSetFixed(mEnd - chestStart); //.toFixed(4));
                            newChest.X = wpdSetFixed(chestStart + newChest.W / 2); //.toFixed(4));
                        } else if (mStart >= chestStart && mEnd >= chestEnd && mStart < chestEnd) {
                            //ASA-1351 issue 5
                            chest_insert = "Y"; //ASA-1306
                            newChest.W = wpdSetFixed(chestEnd - mStart); //.toFixed(4));
                            newChest.X = wpdSetFixed(mStart + newChest.W / 2); //.toFixed(4));
                        }
                        var newChestItems = [];
                        var newChestStart = wpdSetFixed(newChest.X - newChest.W / 2); //.toFixed(4));
                        var newChestEnd = wpdSetFixed(newChest.X + newChest.W / 2); //.toFixed(4));
                        module_no = chest.MIndex + 1; //ASA-1314 it was using mi before
                        for (items of chestItems) {
                            if (items.X >= newChestStart && items.X <= newChestEnd) {
                                items.ModuleNo = module_no; //ASA-1314
                                newChestItems.push(items);
                            }
                        }
                        if (chest_insert == "Y") {
                            //ASA-1306
                            newChest.ItemInfo = newChestItems;
                            new_pogjson[0].ModuleInfo[mi].ShelfInfo.push(newChest);
                            g_pog_json[p_pog_index].ModuleInfo[mi].ShelfInfo.push(newChest); //ASA-1306
                            chest_insert = "N";
                        }
                    }
                    mi++;
                }
                ci++;
            }
        }
        //ASA-1235 END
        var total_mod_dis = 0;
        var z = 0;
        var q = 0;
        var bay_cnt = 0;
        for (const modules of new_pogjson[0].ModuleInfo) {
            if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                modules.MIndex = z;
                mod_array.push(JSON.parse(JSON.stringify(modules)));
                next_mod++;
                base_width = base_width + modules.W;

                console.log("next_mod", next_mod, p_BayCount);
                if (next_mod == p_BayCount || total_mod_cnt == q + 1) {
                    //ASA-1730 Issue 1, was z + 1
                    /*if (typeof g_renderer_pdf !== "undefined" && g_renderer_pdf !== null && g_renderer_pdf !== "") {//Bug_26122 pdf error issue
                    g_renderer_pdf.forceContextLoss();
                    g_renderer_pdf.context = null;
                    g_renderer_pdf.domElement = null;
                    g_renderer_pdf = null;
                    }*/
                    bay_cnt++;
                    var mod_ind = 0;
                    var mod_end = 0;
                    await init_pdf(window.innerWidth, window.innerHeight, 2, "Y", "N");
                    for (obj_mod of mod_array) {
                        try {
                            g_world = g_scene_objects[p_pog_index].scene.children[2];
                            console.log("combine loop", g_world);
                            var returnval = await clone_combine_pog(obj_mod.MIndex, mod_ind, g_show_item_label, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pog_index, mod_end, base_width);
                            console.log("returnval", returnval, g_renderer_pdf);
                        } catch (err) {
                            console.log("error", err);
                            throw err;
                        }
                        mod_end = mod_end + obj_mod.W;
                        //await create_module_from_json_lib(new_pogjson, "T", "F", "N", "N", "Y", "Y", p_Vdate, p_PogDftColor, p_ModDftColor, null, false, "Y", null, p_DftSpreadProduct, p_DftHorizSpac, p_DftVertSpac, p_BskWallThick, p_ChestWallThick, p_PegItemAutoPlace, p_DftWrapText, p_TextDftSize, p_TextDftColor, p_ShelfDftColor, p_DivColor, p_SlotDivider, p_SlotOrient, p_DivFixed, p_ItemDftColor, p_DelistDftColor, g_peg_holes_active, p_ShelfDftColor, 1, p_MerchStyle, p_LoadImgFrom, p_Buid, p_DelistDftColor, p_ItemNumLblColor, p_DispItemInfo, p_ItemNumLblColor, p_ItemNumLblPos, p_NotchHead, "N", p_DftBskFill, p_DftBaskSprd, g_camera, 0, 0);
                        bay = "";

                        mod_ind++;
                    }
                    await timeout(200);

                    for (const mod_dtl of mod_array) {
                        mod_width = mod_width + mod_dtl.W;
                        if (bay == "") {
                            bay = (mod_dtl.W * 100).toFixed(2);
                        } else {
                            bay = bay + "|" + (mod_dtl.W * 100).toFixed(2);
                        }
                    }
                    //ASA-1702
                    // for (const modules of g_pog_json[0].ModuleInfo) {
                    for (const modules of g_pog_json[p_pog_index].ModuleInfo) {
                        if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                            for (const shelfs of modules.ShelfInfo) {
                                if (shelfs.ObjType == "TEXTBOX") {
                                    var selectedObject = g_world.getObjectById(shelfs.SObjID);
                                    if (typeof selectedObject !== "undefined") {
                                        selectedObject.material.transparent = false;
                                    }
                                }
                            }
                        }
                    }

                    next_mod = 0;
                    var temp_json = [];
                    var details = {};
                    details.W = base_width;
                    details.H = g_pog_json[p_pog_index].H;
                    temp_json.push(details);
                    temp_json[0].ModuleInfo = mod_array;
                    var total_width = 0;
                    if (bay_cnt > 1) {
                        total_width = total_mod_dis;
                    }
                    total_mod_dis = total_mod_dis + base_width;
                    base_width = 0;

                    var details = get_min_max_xy_combine(temp_json, total_width);
                    var details_arr = details.split("###");
                    set_camera_z(g_camera_pdf, parseFloat(details_arr[2]), parseFloat(details_arr[3]), parseFloat(details_arr[0]), parseFloat(details_arr[1]), g_offset_z, parseFloat(details_arr[4]), parseFloat(details_arr[5]), true, 0);
                    console.log("combine g_renderer_pdf", g_renderer_pdf, g_scene_pdf, g_camera_pdf);
                    if (g_renderer_pdf !== null) {
                        g_renderer_pdf.render(g_scene_pdf, g_camera_pdf);
                    }
                    animate_pog_pdf();
                    console.log("inside", new_pogjson, mod_array, g_camera_pdf, g_scene_pdf.children.length, g_scene_pdf);
                    mod_array = [];
                    var dataURL = g_new_canvas.toDataURL("image/jpeg", p_enhance);
                    console.log(" after  base64 ", getDateTime());
                    var img_details = {};
                    img_details["Module"] = "COMBINE";
                    img_details["Bay"] = bay;
                    bay = "";
                    img_details["ImgData"] = dataURL.match(/,(.*)$/)[1];
                    img_arr.push(img_details);

                    if (p_pog_split_ind == "Y" && total_mod_cnt % 2 != 0 && total_mod_cnt <= q + p_BayCount + 2) {
                        //ASA-1730 was z + p_BayCount + 2
                        p_BayCount = p_BayCount + 1;
                    } //ASA-1640
                }
                q++; //ASA-1730
            }
            z++;
        }
        /*if (typeof g_renderer_pdf !== "undefined" && g_renderer_pdf !== null && g_renderer_pdf !== "") {
        g_renderer_pdf.forceContextLoss();
        g_renderer_pdf.context = null;
        g_renderer_pdf.domElement = null;
        g_renderer_pdf = null;
        }*/
        g_temp_desc = "N";
        g_show_live_image = old_live_image;
        g_show_item_desc = old_item_desc;
        g_pog_json = updatePogjson; //ASA-1235
        render(p_pog_index);
        return img_arr;
    } catch (err) {
        console.log("error", err);
        error_handling(err);
        throw err;
    }
}

async function clone_combine_pog(p_module_index, p_run_cnt, p_new_item_label, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pog_index, p_prev_mod_end, p_base_width) {
    try {
        logDebug("function : create_scene; p_module_index : " + p_module_index + "; new_item_label : " + p_new_item_label, "S");
        if (typeof g_pog_json[p_pog_index].ModuleInfo[p_module_index].ParentModule == "undefined" || g_pog_json[p_pog_index].ModuleInfo[p_module_index].ParentModule == null) {
            var mod_start = 0;
            if (g_pog_json[p_pog_index].BaseH > 0) {
                var colorValue = parseInt(g_pog_json[p_pog_index].ModuleInfo[p_module_index].Color.replace("#", "0x"), 16);
                var hex_decimal = new THREE.Color(colorValue);
                var POGBase = new THREE.Mesh(
                    new THREE.BoxGeometry(p_base_width, g_pog_json[p_pog_index].BaseH, 0.001),
                    new THREE.MeshStandardMaterial({
                        color: hex_decimal,
                    })
                );
                var l_wireframe_id = add_wireframe(POGBase, 2);
                POGBase.position.x = p_base_width / 2;
                POGBase.position.y = g_pog_json[p_pog_index].BaseH / 2;
                POGBase.position.z = 0;
                g_scene_pdf.add(POGBase);
                var moduleY = g_pog_json[p_pog_index].ModuleInfo[p_module_index].H / 2 + g_pog_json[p_pog_index].BaseH;
            } else {
                var moduleY = g_pog_json[p_pog_index].ModuleInfo[p_module_index].H / 2;
            }
            if (p_run_cnt == 0) {
                var moduleX = g_pog_json[p_pog_index].ModuleInfo[p_module_index].W / 2;
            } else {
                var moduleX = p_prev_mod_end + g_pog_json[p_pog_index].ModuleInfo[p_module_index].W / 2;
            }
            mod_start = moduleX - g_pog_json[p_pog_index].ModuleInfo[p_module_index].W / 2;
            var module = g_world.getObjectById(g_pog_json[p_pog_index].ModuleInfo[p_module_index].MObjID);

            var new_module = module.clone(true);
            new_module.material = module.material.clone(true);
            g_scene_pdf.add(new_module);
            new_module.position.set(moduleX, moduleY, 0);
            console.log("module ", new_module, new_module.children);
            for (objects of new_module.children) {
                console.log("objects", objects.uuid, objects.position);
            }
            if (g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo.length > 0) {
                j = 0;
                for (const shelfs of g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo) {
                    if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER") {
                        var shelf = g_world.getObjectById(shelfs.SObjID);
                        var shelfX = -1;
                        var created_ind = "N";
                        if (shelfs.ObjType == "TEXTBOX") {
                            var new_shelf = new THREE.Mesh(shelf.geometry, shelf.material);
                            new_shelf.material.transparent = false;
                            var l_wireframe_id = add_wireframe(new_shelf, 12);
                            if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                if (shelfs.Slope > 0) {
                                    slope = 0 - shelfs.Slope;
                                } else {
                                    slope = -shelfs.Slope;
                                }

                                new_shelf.rotateY((shelfs.Rotation * Math.PI) / 180);
                                if (shelfs.Rotation == 0) {
                                    new_shelf.rotateX(((slope / 2) * Math.PI) / 180);
                                } else {
                                    new_shelf.rotateX((slope * Math.PI) / 180);
                                }
                            }
                            created_ind = "Y";
                            if (p_module_index > 0) {
                                shelfX = mod_start + (shelfs.X - (g_pog_json[p_pog_index].ModuleInfo[p_module_index].X - g_pog_json[p_pog_index].ModuleInfo[p_module_index].W / 2));
                            } else {
                                shelfX = shelfs.X;
                            }
                        } else if (shelfs.ObjType == "CHEST" && g_pogcr_pdf_chest_split == "Y") {
                            var new_shelf = new THREE.Mesh(
                                new THREE.BoxGeometry(shelfs.W, shelfs.H, 0.0001), //shelfs.D),
                                new THREE.MeshStandardMaterial({
                                    color: shelfs.Color,
                                })
                            );
                            var l_wireframe_id = add_wireframe(new_shelf, 2);
                            new_shelf.material = shelf.material.clone(true);

                            // var new_shelf = shelf.clone(true);
                            if (p_module_index > 0) {
                                shelfX = mod_start + (shelfs.X - (g_pog_json[p_pog_index].ModuleInfo[p_module_index].X - g_pog_json[p_pog_index].ModuleInfo[p_module_index].W / 2));
                            } else {
                                shelfX = shelfs.X;
                            }
                            created_ind = "Y";
                        } else {
                            var new_shelf = shelf.clone(true);
                            if (p_module_index > 0) {
                                shelfX = mod_start + (shelfs.X - (g_pog_json[p_pog_index].ModuleInfo[p_module_index].X - g_pog_json[p_pog_index].ModuleInfo[p_module_index].W / 2));
                            } else {
                                shelfX = shelfs.X;
                            }
                            new_shelf.material = shelf.material.clone(true);
                            var l_wireframe_id = add_wireframe(new_shelf, 4);
                            created_ind = "Y";
                        }
                        if (created_ind == "Y") {
                            g_scene_pdf.add(new_shelf);
                            var shelf_start = shelfX - shelfs.W / 2;
                            g_scene_pdf.updateMatrixWorld();

                            var shelfZ = 0;

                            if (shelfs.ObjType == "TEXTBOX") {
                                //shelfZ = g_world.getObjectById(shelfs.SObjID).position.z; //shelfs.Z > 0.0021 ? 0.0021 : shelfs.Z == 0 ? 0.0006 : shelfs.Z;   //ASA-1652 #10 
                                shelfZ = g_world.getObjectById(shelfs.SObjID).position.z + 0.004;; // ASA-1976 Issue 4
                                // shelfZ = 0.006; // ASA-1976 Issue 4
                            } else if (shelfs.ObjType == "PEGBOARD") {
                                shelfZ = 0.003;
                            } else {
                                if (isShelfOnPegboard(shelfs.X, shelfs.Y, p_module_index, p_pog_index, shelfs, g_pog_json)) {
                                    shelfZ = 0.005;
                                } else {
                                    shelfZ = 0.0005;
                                } //ASA - 1544 Issue 2
                            }
                            new_shelf.position.set(shelfX, shelfs.Y, shelfZ);
                            console.log("new_shelf ", shelfs.ObjType, shelfs.Shelf, new_shelf, shelfX, shelfs.Y, shelfZ);
                        }
                        k = 0;
                        update_item_distance(p_module_index, j, p_pog_index, "N"); //Bug-26122 - splitting the chest

                        for (const items of shelfs.ItemInfo) {
                            var item = g_world.getObjectById(items.ObjID);
                            if (typeof item !== "undefined") {
                                var new_item = new THREE.Mesh(item.geometry, item.material);
                                // if (shelfs.SpreadItem == "F" || items.CapStyle !== "0" || show_item_desc == "Y") {
                                for (const objects of item.children) {
                                    if (objects.uuid !== "wireframe") {
                                        var child_item = objects.clone(true);
                                        child_item.uuid = objects.uuid;
                                        var new_z;
                                        if (child_item.uuid == "facings") {
                                            new_z = 0.001;
                                        } else if (child_item.uuid == "cap") {
                                            new_z = new_z - 0.0001;
                                        } else if (child_item.uuid == "ITEM_DESC") {
                                            // new_z = 0.005; //ASA-1729 Issue 7
                                            //new_z = shelfZ +  0.003; //0.0006; //ASA-1729 Issue 7
                                            new_z = shelfZ   // ASA-1976 Issue 4
                                        } else {
                                            new_z = objects.position.z; //ASA-1538    //ASA-1729  //0.009
                                        }
                                        child_item.position.z = new_z;
                                        new_item.add(child_item);
                                    }
                                }
                                // }
                                g_scene_pdf.updateMatrixWorld();
                                new_item.updateMatrixWorld();
                                if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                    var x = items.RotationX;
                                    var y = items.RotationY;
                                    var z = items.RotationZ;
                                    var relativeMeshOffset = new THREE.Vector3(x, y, z);

                                    var offsetPosition = relativeMeshOffset.applyMatrix4(new_shelf.matrixWorld);

                                    new_item.position.x = offsetPosition.x;
                                    new_item.position.y = offsetPosition.y;
                                    new_item.position.z = offsetPosition.z;
                                    new_item.quaternion.copy(new_shelf.quaternion);
                                    new_item.updateMatrix();
                                } else {
                                    if (shelfs.ObjType == "PEGBOARD") {
                                        var new_z = 0.016;
                                    } else {
                                        var new_z = 0.005 + shelfs.D / 1000; //20241014 Reg 9     //0.001
                                    }
                                    var new_x = -1;
                                    if (shelfs.ObjType == "BASKET" && shelfs.BsktSpreadProduct == "BT") {
                                        new_x = shelf_start + items.W / 2;
                                    } else {
                                        new_x = shelf_start + items.Distance + items.W / 2;
                                    }
                                    new_item.position.set(new_x, items.Y, new_z);
                                }
                                g_scene_pdf.add(new_item);
                                var l_wireframe_id = add_wireframe(new_item, 4);
                                add_item_borders(p_module_index, j, k, new_item, items.W, items.H, items.BHoriz, p_pog_index, "N"); //Bug-26122 - splitting the chest
                                if (p_new_item_label == "Y") {
                                    var return_val = update_item_label(p_module_index, j, k, new_item, "Y", p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pog_index, "N"); //Bug-26122 - splitting the chest
                                }
                            }
                            k = k + 1;
                        }
                    }
                    j = j + 1;
                }
            }
            if (g_renderer_pdf !== null) {
                animate_pog_pdf();
            }
        }
        logDebug("function : create_scene", "E");
        return "success";
    } catch (err) {
        error_handling(err);
        throw err;
    }
}

function show_labels(p_show_label_ind, p_notch_label, p_notchHead, p_pog_index) {
    try {
        var module_details = g_pog_json[p_pog_index].ModuleInfo;
        var div_mod_index = -1,
            div_shelf_index = -1,
            div_item_index = -1;
        var details = {};
        var is_driver = "N";
        var i = 0;
        try {
            if (p_show_label_ind == "Y" || p_notch_label == "Y") {
                for (const modules of module_details) {
                    if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                        var l_shelf_details = modules.ShelfInfo;
                        var j = 0;
                        for (const shelfs of l_shelf_details) {
                            if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "TEXTBOX" && ((p_notch_label == "Y" && shelfs.ObjType !== "DIVIDER") || p_show_label_ind == "Y")) {
                                if (shelfs.ObjType == "DIVIDER") {
                                    var new_shelf_detail = g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo;
                                    $.each(new_shelf_detail, function (k, shelfs_detail) {
                                        if (shelfs_detail.ObjType !== "BASE" && shelfs_detail.ObjType !== "NOTCH" && shelfs_detail.ObjType !== "DIVIDER") {
                                            $.each(shelfs_detail.ItemInfo, function (l, items) {
                                                if (items.Item == "DIVIDER") {
                                                    if (shelfs.ShelfDivObjID == items.ObjID) {
                                                        div_mod_index = i;
                                                        div_shelf_index = k;
                                                        div_item_index = l;
                                                    }
                                                }
                                            });
                                        }
                                    });
                                    var shelf_obj = g_world.getObjectById(shelfs.ShelfDivObjID);
                                } else {
                                    var shelf_obj = g_world.getObjectById(shelfs.SObjID);
                                }
                                var notch_no = 0;
                                if (typeof shelf_obj !== "undefined") {
                                    if (typeof shelfs.LObjID !== "undefined" && shelfs.LObjID !== -1 && p_show_label_ind == "Y") {
                                        var label_obj = shelf_obj.getObjectById(shelfs.LObjID);
                                        shelf_obj.remove(label_obj);
                                    } else if (p_notch_label == "Y" && typeof shelfs.NotchLabelObjID !== "undefined" && shelfs.NotchLabelObjID !== -1) {
                                        var label_obj = shelf_obj.getObjectById(shelfs.NotchLabelObjID);
                                        shelf_obj.remove(label_obj);
                                        var cap_count = 100;

                                        for (k = 0; k < cap_count; k++) {
                                            if (shelfs.Y + shelfs.H / 2 <= g_pog_json[p_pog_index].BaseH + modules.NotchStart) {
                                                notch_no = 0;
                                                break;
                                            } else if (shelfs.Y + shelfs.H / 2 <= g_pog_json[p_pog_index].BaseH + modules.NotchStart + modules.NotchSpacing * k) {
                                                //ASA-1254- modules.NotchSpacing / 2
                                                notch_no = k;
                                                break;
                                            }
                                        }
                                    }
                                    var hex_color = shelfs.Color;
                                    if (hexToRgb(hex_color) == null) {
                                        var red = parseInt("FF", 16);
                                        var green = parseInt("FF", 16);
                                        var blue = parseInt("FF", 16);
                                    } else {
                                        var red = hexToRgb(hex_color).r;
                                        var green = hexToRgb(hex_color).r;
                                        var blue = hexToRgb(hex_color).g;
                                    }

                                    var text_color = getTextColor(red, green, blue); //ASA-1095
                                    if (p_notch_label == "Y" && shelfs.ObjType !== "DIVIDER") {
                                        var return_obj = addlabelText(p_notchHead + " " + notch_no, g_labelFont, g_labelActualSize, text_color, "center", "");
                                    } else {
                                        var return_obj = addlabelText(shelfs.Shelf, g_labelFont, g_labelActualSize, text_color, "center", "");
                                    }
                                    if (typeof return_obj !== "undefined") {
                                        shelf_obj.add(return_obj);

                                        return_obj.position.y = -0.005;
                                        if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                            return_obj.position.z = shelfs.D / 2 + 0.005;
                                        } else {
                                            return_obj.position.z = 0.005;
                                        }
                                        if (shelfs.ObjType == "DIVIDER") {
                                            return_obj.position.x = 0;
                                            g_pog_json[p_pog_index].ModuleInfo[div_mod_index].ShelfInfo[div_shelf_index].ItemInfo[div_item_index].LObjID = return_obj.id;
                                            g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].LObjID = return_obj.id;
                                        } else {
                                            if (p_notch_label == "Y") {
                                                return_obj.position.x = 0 - (shelfs.W / 4 + 0.01);
                                                g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].NotchLabelObjID = return_obj.id;
                                            } else {
                                                return_obj.position.x = 0 - (shelfs.W / 2.4 + 0.01);
                                                g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].LObjID = return_obj.id;
                                            }
                                        }
                                    }
                                }
                            }
                            j = j + 1;
                        }
                    }
                    i = i + 1;
                }
            } else {
                for (const modules of module_details) {
                    if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                        var l_shelf_details = modules.ShelfInfo;
                        var j = 0;
                        for (const shelfs of l_shelf_details) {
                            if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && ((p_notch_label == "Y" && shelfs.ObjType !== "DIVIDER") || p_show_label_ind == "Y")) {
                                if (shelfs.ObjType == "DIVIDER") {
                                    var shelf_obj = g_world.getObjectById(shelfs.ShelfDivObjID);
                                } else {
                                    var shelf_obj = g_world.getObjectById(shelfs.SObjID);
                                }
                                if (typeof shelfs.LObjID !== "undefined" && shelfs.LObjID !== -1 && p_show_label_ind == "Y") {
                                    var label_obj = shelf_obj.getObjectById(shelfs.LObjID);
                                    shelf_obj.remove(label_obj);
                                } else if (p_notch_label == "Y" && typeof shelfs.NotchLabelObjID !== "undefined" && shelfs.NotchLabelObjID !== -1) {
                                    var label_obj = shelf_obj.getObjectById(shelfs.NotchLabelObjID);
                                    shelf_obj.remove(label_obj);
                                }
                                g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].LObjID = -1;
                            }
                            j = j + 1;
                        }
                    }
                    i = i + 1;
                }
            }
        } catch (err) {
            error_handling(err);
        }
    } catch (err) {
        error_handling(err);
    }
}

// ASA-1472
/*function toFixed(p_num, p_fixed) {
    try {
        logDebug("function : toFixed; num : " + p_num, "S");
        if (typeof p_num !== "undefined" && p_num !== null && p_num !== "") {
            var re = new RegExp("^-?\\d+(?:.\\d{0," + (p_fixed || -1) + "})?");
            logDebug("function : toFixed", "E");
            return p_num.toString().match(re)[0];
        } else {
            logDebug("function : toFixed", "E");
            return "";
        }
    } catch (err) {
        logDebug("function : toFixed", "E");
        error_handling(err);
    }
}*/

function get_canvas_json(p_loc) {
    try {
        logDebug("function : get_canvas_json; loc : " + p_loc, "S");
        return g_pog_json;
    } catch (err) {
        error_handling(err);
    }
}

function get_canvas_world(p_loc) {
    try {
        logDebug("function : get_canvas_world; loc : " + p_loc, "S");
        return g_world;
    } catch (err) {
        error_handling(err);
    }
}

function get_curr_canvas() {
    try {
        logDebug("function : get_curr_canvas", "S");
        if (g_curr_canvas == 1) {
            logDebug("function : get_curr_canvas", "E");
            return document.getElementById("maincanvas");
        } else {
            logDebug("function : get_curr_canvas", "E");
            return document.getElementById("maincanvas1");
        }
    } catch (err) {
        error_handling(err);
    }
}

function get_curr_renderer() {
    try {
        logDebug("function : get_curr_renderer", "S");
        return g_renderer;
    } catch (err) {
        error_handling(err);
    }
}

function get_canvas_camera(p_loc) {
    try {
        logDebug("function : get_canvas_camera; loc : " + p_loc, "S");
        return g_camera;
    } catch (err) {
        error_handling(err);
    }
}

function check_cookie_name(p_name, p_bu_id) {
    try {
        logDebug("function : check_cookie_name; name : " + p_name + "; bu_id : " + p_bu_id, "S");
        var match = document.cookie.match(new RegExp("(^| )" + p_name + "=([^;]+)"));
        if (match) {
            if (p_bu_id == match[2].split("$$$")[0]) {
                logDebug("function : check_cookie_name", "E");
                return match[2].split("$$$")[1];
            } else {
                document.cookie = p_name + "=;  max-age=31536000;";
                logDebug("function : check_cookie_name", "E");
                return "";
            }
        } else {
            logDebug("function : check_cookie_name", "E");
            return "";
        }
    } catch (err) {
        error_handling(err);
    }
}

function chunkString(p_string, p_length) {
    logDebug("function : chunkString; len : " + p_length, "S");
    const size = Math.ceil(p_string.length / p_length);
    const r = Array(size);
    let offset = 0;

    for (let i = 0; i < size; i++) {
        r[i] = p_string.substr(offset, p_length);
        offset += p_length;
    }
    logDebug("function : chunkString", "E");
    return r;
}

function base64ToBuffer(p_string) {
    p_string = window.atob(p_string); // creates a ASCII string
    var buffer = new ArrayBuffer(p_string.length),
        view = new Uint8Array(buffer);
    for (var i = 0; i < p_string.length; i++) {
        view[i] = p_string.charCodeAt(i);
    }
    return buffer;
}

function clob2Array(p_clob, p_size, p_array) {
    try {
        logDebug("function : clob2Array; size : " + p_size, "S");
        loopCount = Math.floor(p_clob.length / p_size) + 1;
        for (var i = 0; i < loopCount; i++) {
            p_array.push(p_clob.slice(p_size * i, p_size * (i + 1)));
        }
        logDebug("function : clob2Array", "E");
        return p_array;
    } catch (err) {
        error_handling(err);
    }
}

function validate_file_type(p_fileName) {
    try {
        logDebug("function : validate_file_type", "S");
        var fname = p_fileName;
        var re = /(\.pdf|\.xlsx|\.zip)$/i;
        if (!re.exec(fname)) {
            alert(get_message("INVALID_FILE_TYPE", p_fileName));
            return false;
        } else {
            logDebug("function : validate_file_type", "E");
            return true;
        }
    } catch (err) {
        error_handling(err);
    }
}

function addItemDescription(p_text, p_textHeight, p_actualFontSize, p_font_color, p_txt_align, p_back_color, p_obj_width, p_obj_height, p_wrap_text, p_VertText, p_item, p_item_vertical_text_display, p_item_text_center_align, p_items_BHoriz) {
    try {
        logDebug(
            "function : addItemDescription; text : " + p_text + "; textHeight : " + p_textHeight +
            "; actualFontSize : " + p_actualFontSize + "; font_color : " + p_font_color +
            "; txt_align : " + p_txt_align + "; back_color : " + p_back_color +
            "; obj_width : " + p_obj_width + "; obj_height : " + p_obj_height +
            "; wrap_text : " + p_wrap_text + "; item_vertical_text_display : " + p_item_vertical_text_display +
            "; item_text_center_align : " + p_item_text_center_align, "S"
        );
        p_text = p_text.replace(/\ - $/, "");
        // Common CSS metrics
        var ruler = document.createElement("DIV");
        ruler.style.fontFamily = "Arial";
        ruler.style.fontWeight = "normal";
        ruler.style.fontSize = p_textHeight + "pt";
        ruler.style.position = "absolute";
        ruler.style.top = "-500px";
        ruler.style.left = "0";
        ruler.innerHTML = p_text;
        document.body.appendChild(ruler);
        let cssSize = { width: ruler.offsetWidth, height: ruler.offsetHeight };
        let cssInfo = window.getComputedStyle(ruler, null);
        let fontSizePx = parseFloat(cssInfo["fontSize"]);
        document.body.removeChild(ruler);

        var metricsCanvas = document.createElement("canvas");
        var metricsContext = metricsCanvas.getContext("2d");
        var metrics = metricsContext.measureText(p_text);
        let lineGap = cssSize.height - (metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent || 0);
        let advMetrics = {
            width: metrics.width,
            cssHeight: cssSize.height,
            cssFontSizePx: fontSizePx,
            fontAscent: metrics.fontBoundingBoxAscent || 0,
            fontDescent: metrics.fontBoundingBoxDescent || 0,
            actualAscent: metrics.actualBoundingBoxAscent || 0,
            actualDescent: metrics.actualBoundingBoxDescent || 0,
            lineHeight: cssSize.height,
            lineGap: lineGap
        };

        //ASA-1847 4.1 Start Applied for Item text should be vertical Align
        if (p_item_vertical_text_display === "Y") {
            var org_width = p_obj_width;
            var org_height = p_obj_height;
            var [canvasWidth, canvasHeight] = get_visible_size(0.012, org_width * 10, org_height * 10, g_canvas, g_camera);
            var text_canvas = document.createElement('canvas');
            var context = text_canvas.getContext('2d');
            text_canvas.width = canvasWidth;
            text_canvas.height = canvasHeight;

            context.textAlign = "left";
            context.textBaseline = "top";
            if (p_back_color) {
                context.fillStyle = p_back_color;
                context.fillRect(0, 0, canvasWidth, canvasHeight);
            }
            context.fillStyle = p_font_color || "#000";
            // ASA-1847.4 Issue 1 Logic change  
            let fontPx = p_textHeight;
            const maxColumns = 2;
            const minFont = 12;
            const chars = p_text.split("");

            //Fit in one column first
            let fitsInOneColumn = false;
            while (fontPx > minFont) {
                context.font = `${fontPx}px Arial`;
                const charsPerCol = Math.floor(canvasHeight / (fontPx * 1.2));
                if (chars.length <= charsPerCol) {
                    fitsInOneColumn = true;
                    break;
                }
                fontPx--;
            }

            let columnsNeeded = 1;
            if (!fitsInOneColumn) {
                // Use two columns if needed 
                columnsNeeded = 2;
                while (fontPx > minFont) {
                    context.font = `${fontPx}px Arial`;
                    const charsPerCol = Math.floor(canvasHeight / (fontPx * 1.2));
                    const totalFit = charsPerCol * columnsNeeded;
                    if (chars.length <= totalFit) break;
                    fontPx--;
                }
            }
            p_textHeight = fontPx;
            let lineHeight = fontPx * 1;
            context.font = `${p_textHeight}px Arial`;

            const charsPerCol = Math.floor(canvasHeight / lineHeight);
            const charWidth = Math.max(...chars.map(c => context.measureText(c).width));
            const totalColumnsWidth = columnsNeeded * charWidth + (columnsNeeded - 1) * (fontPx * 0.4);
            let startX = (p_item_text_center_align === "Y") ? (canvasWidth - totalColumnsWidth) / 2 : 0;
            const totalTextHeight = Math.min(charsPerCol, chars.length) * lineHeight;
            const startY = (p_item_text_center_align === "Y") ? (canvasHeight - totalTextHeight) / 2 : 0;

            if (p_items_BHoriz % 2 === 0 && fitsInOneColumn) { startX += charWidth; } //ASA-1971.1

            let currentCol = 0;
            let currentRow = 0;
            for (let i = 0; i < chars.length; i++) {
                const char = chars[i];
                const charW = context.measureText(char).width;
                const colX = startX + currentCol * (charWidth + fontPx * 0.4) + (charWidth - charW) / 2;
                const y = startY + currentRow * lineHeight;
                context.fillText(char, colX, y);
                currentRow++;
                if (currentRow >= charsPerCol) {
                    currentRow = 0;
                    currentCol++;
                    if (currentCol >= columnsNeeded) break;
                }
            }
            var tex = new THREE.CanvasTexture(text_canvas);
            tex.minFilter = THREE.LinearFilter;
            tex.matrixAutoUpdate = true;
            tex.needsUpdate = true;
            tex.isCanvasTexture = true;
            var geometry = new THREE.PlaneGeometry(org_width, org_height);
            var material = new THREE.MeshBasicMaterial({
                side: THREE.DoubleSide,
                map: tex,
                transparent: true,
                opacity: 1.0,
            });
            var sprite = new THREE.Mesh(geometry, material);
            sprite.uuid = "ITEM_DESC";
            return sprite;
        }
        // VERTICAL TEXT LOGIC END
        else {
            // Existing horizontal text logic
            var height_check = p_VertText;
            var diff = ((p_obj_width - p_obj_height) / ((p_obj_width + p_obj_height) / 2)) * 100;
            if (diff < 0) diff = -diff;

            if (height_check > 0) {
                if (diff > height_check && p_obj_height > p_obj_width) {
                    var org_width = p_obj_height;
                    var org_height = p_obj_width;
                    var new_width = p_obj_height * 10;
                    var new_height = p_obj_width * 10;
                } else {
                    var org_width = p_obj_width;
                    var org_height = p_obj_height;
                    var new_width = p_obj_width * 10;
                    var new_height = p_obj_height * 10;
                }
            } else {
                var org_width = p_obj_width < p_obj_height ? p_obj_height : p_obj_width;
                var org_height = p_obj_width < p_obj_height ? p_obj_width : p_obj_height;
                var new_width = org_width * 10;
                var new_height = org_height * 10;
            }

            var text_width = cssSize.width + 5;
            var text_height = parseInt(p_textHeight);
            var [canvasWidth, canvasHeight] = get_visible_size(0.012, new_width, new_height, g_canvas, g_camera);
            var [width, height] = get_visible_text_dim(p_text, p_textHeight);
            var text_canvas = document.createElement("canvas");
            var context = text_canvas.getContext("2d");
            text_canvas.width = canvasWidth;
            text_canvas.height = canvasHeight;
            context.textAlign = p_txt_align;
            context.textBaseline = "top";
            if (p_back_color !== "") {
                context.fillStyle = p_back_color;
                context.fillRect(0, 0, text_canvas.width, text_canvas.height);
            }

            context.fillStyle = p_font_color;
            var lineHeight = advMetrics.lineHeight - advMetrics.lineGap;
            fitText(context, p_text, canvasWidth / 2, 0, canvasWidth, canvasHeight, p_textHeight, lineHeight);

            let tex = new THREE.CanvasTexture(text_canvas);
            tex.minFilter = THREE.LinearFilter;
            tex.matrixAutoUpdate = true;
            tex.needsUpdate = true;
            tex.isCanvasTexture = true;

            var geometry = new THREE.PlaneGeometry(org_width, org_height);
            var material = new THREE.MeshBasicMaterial({
                side: THREE.DoubleSide,
                map: tex,
                transparent: true,
                opacity: 1.0,
            });

            material.map.minFilter = THREE.LinearFilter;
            var sprite = new THREE.Mesh(geometry, material);
            if (diff > height_check && p_obj_height > p_obj_width) {
                sprite.rotateOnAxis(new THREE.Vector3(0, 0, 1), (90 * Math.PI) / 180);
            }
            sprite.uuid = "ITEM_DESC";
            logDebug("function : addItemDescription", "E");
            return sprite;
        }
    } catch (err) {
        error_handling(err);
    }
}

function fitText(p_context, p_text, p_x, p_y, p_width, p_height, p_fontSize, p_lineHeight) {
    try {
        logDebug("function : fitText; text : " + p_text + "; x : " + p_x + "; y : " + p_y + "; width : " + p_width + "; height : " + p_height + "; fontSize : " + p_fontSize + "; lineHeight : " + p_lineHeight, "S");
        if (typeof p_x !== "undefined" && typeof p_y !== "undefined" && typeof p_width !== "undefined" && typeof p_height !== "undefined" && !isNaN(p_width) && !isNaN(p_height)) {
            p_context.font = "normal " + p_fontSize + "px Arial";
            var metrics = p_context.measureText(p_text);

            if (metrics.width <= p_width && g_lines.length == 0) {
                var gap = p_width - metrics.width;
                var new_x = p_x - gap / 2 + 2;
                p_context.fillText(p_text, new_x, p_height / 2 - p_fontSize / 4); //y + fontSize / 4);
                return;
            }

            // Wrap text
            var words = p_text.split(" "),
                line = "";
            g_lines = [];

            for (var n = 0; n < words.length; n++) {
                var testLine = line + words[n] + " ";
                metrics = p_context.measureText(testLine);
                if (metrics.width > p_width && n > 0) {
                    g_lines.push(line);
                    line = words[n] + " "; // next line
                } else {
                    line = testLine;
                }
            }
            metrics = p_context.measureText(line);
            if (metrics.width <= p_width) {
                g_lines.push(line);
            } else {
                return fitText(p_context, p_text, p_x, p_y, p_width, p_height, p_fontSize - 1, p_lineHeight);
            }

            if (g_lines.length > 3) {
                return fitText(p_context, p_text, p_x, p_y, p_width, p_height, p_fontSize - 1, p_lineHeight);
            }

            var line_y = p_y + p_fontSize / 4;
            for (var i = 0; i < g_lines.length; i++) {
                var metrics = p_context.measureText(g_lines[i]);
                var gap = p_width - metrics.width;
                var new_x = p_x - gap / 2 + 2;
                p_context.fillText(g_lines[i], new_x, line_y);
                line_y += p_fontSize * 1.1;
            }
        }

        logDebug("function : fitText", "E");
    } catch (err) {
        error_handling(err);
    }
}

async function showHideItemDescription(p_show_item_desc, p_pogcrItemBackLabelColor, p_pogcrDescListArr, p_pog_index) {
    try {
        logDebug("function : showHideItemDescription; g_show_item_desc : " + p_show_item_desc, "S");

        var module_details = g_pog_json[p_pog_index].ModuleInfo;
        var camera_z_pos = g_camera.position.z;
        var back_color = p_pogcrItemBackLabelColor;
        var desc_list_arr = p_pogcrDescListArr.split(",");
        var colorValue = parseInt(back_color.replace("#", "0x"), 16);
        var hex_decimal = new THREE.Color(colorValue);
        if (p_show_item_desc == "N") {
            var i = 0;
            for (const modules of module_details) {
                if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                    var l_shelf_details = modules.ShelfInfo;
                    var carparkInfo = g_pog_json[p_pog_index].ModuleInfo[i].Carpark;
                    var j = 0;
                    for (const shelfs of l_shelf_details) {
                        if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX") {
                            if (shelfs.ItemInfo.length > 0) {
                                var item_Details = shelfs.ItemInfo;
                                var k = 0;
                                for (const items of item_Details) {
                                    if (items.Item !== "DIVIDER" && items.Desc !== "" && typeof items.Desc !== "undefined") {
                                        var item_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(items.ObjID);
                                        if (typeof items.DescID !== "undefined" && items.DescID !== -1 && typeof item_obj !== "undefined") {
                                            var label_obj = item_obj.getObjectById(items.DescID);
                                            item_obj.remove(label_obj);
                                        }
                                        g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].ItemInfo[k].DescID = -1;
                                    }
                                    k = k + 1;
                                }
                            }
                        }
                        j = j + 1;
                    }
                    var k = 0;
                    if (typeof carparkInfo !== "undefined" && carparkInfo.length > 0) {
                        for (const items of carparkInfo[0].ItemInfo) {
                            if (items.Item !== "DIVIDER" && items.Desc !== "" && typeof items.Desc !== "undefined") {
                                var item_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(items.ObjID);
                                if (typeof items.DescID !== "undefined" && items.DescID !== -1) {
                                    var label_obj = item_obj.getObjectById(items.DescID);
                                    item_obj.remove(label_obj);
                                }
                                g_pog_json[p_pog_index].ModuleInfo[i].Carpark[0].ItemInfo[k].DescID = -1;
                            }
                            k = k + 1;
                        }
                    }
                }
                i = i + 1;
            }
        } else {
            g_camera.position.z = 7;
            var i = 0;
            for (const modules of module_details) {
                if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                    var l_shelf_details = modules.ShelfInfo;
                    var carparkInfo = g_pog_json[p_pog_index].ModuleInfo[i].Carpark;
                    var j = 0;
                    for (const shelfs of l_shelf_details) {
                        if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX") {
                            if (shelfs.ItemInfo.length > 0) {
                                var item_Details = shelfs.ItemInfo;
                                var k = 0;
                                for (const items of item_Details) {
                                    if (items.Item !== "DIVIDER" && items.Desc !== "" && typeof items.Desc !== "undefined") {
                                        var item_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(items.ObjID);
                                        var hex_color = g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].Color;
                                        if (hexToRgb(hex_color) == null) {
                                            var red = parseInt("FF", 16);
                                            var green = parseInt("FF", 16);
                                            var blue = parseInt("FF", 16);
                                        } else {
                                            var red = hexToRgb(hex_color).r;
                                            var green = hexToRgb(hex_color).r;
                                            var blue = hexToRgb(hex_color).g;
                                        }

                                        var text_color;
                                        text_color = "#000000";

                                        var textToDisplay = "";
                                        if (g_temp_desc == "N") {
                                            for (q = 0; q < desc_list_arr.length; q++) {
                                                if (desc_list_arr[q] == "ITEM") {
                                                    textToDisplay = textToDisplay + items.ItemID + " - ";
                                                } else if (desc_list_arr[q] == "DESCRIPTION") {
                                                    textToDisplay = textToDisplay + items.Desc + " - ";
                                                }
                                            }
                                        } else {
                                            var desc_list = g_temp_desc.split("");
                                            var l = 0;
                                            var SalesInfo = get_sales_info(p_pog_index, items.ItemID);
                                            for (const lst of desc_list) {
                                                if (lst == "I") {
                                                    textToDisplay = textToDisplay + items.ItemID + " - ";
                                                }
                                                if (lst == "D") {
                                                    textToDisplay = textToDisplay + items.Desc + " " + items.DescSecond + " - ";
                                                }
                                                if (lst == "V") {
                                                    textToDisplay = textToDisplay + " SV: " + SalesInfo.SalesPerWeek + " ";
                                                }
                                                if (lst == "U") {
                                                    textToDisplay = textToDisplay + "SU " + SalesInfo.SalesUnitPerWeek + " ";
                                                }
                                                if (lst == "R") {
                                                    //ASA-1289
                                                    textToDisplay = textToDisplay + " VRM$: " + SalesInfo.VRM + " ";
                                                }

                                                if (lst == "C") {
                                                    var det_arr = items.SizeDesc.split("*");
                                                    details = (items.BHoriz * items.BVert * items.BaseD) / parseInt(det_arr[1]); //ASA-1247

                                                    if (isNaN(details) || !isFinite(details)) {
                                                        temp_text = "C: " + 0;
                                                    } else {
                                                        temp_text = "C: " + details.toFixed(1);
                                                    }
                                                    textToDisplay = textToDisplay + temp_text + " ";
                                                }
                                                if (lst == "O") {
                                                    details = (items.BHoriz * items.BVert * items.BaseD) / (SalesInfo.SalesUnitPerWeek / 7);
                                                    if (isNaN(details) || !isFinite(details)) {
                                                        temp_text = "D: " + 0;
                                                    } else {
                                                        temp_text = "D: " + details.toFixed(1);
                                                    }
                                                    textToDisplay = textToDisplay + temp_text + " ";
                                                }
                                                if (lst == "P") {
                                                    textToDisplay = textToDisplay + "VRM%: " + SalesInfo.VRMPer + " ";
                                                }
                                                if (lst == "F") {
                                                    textToDisplay = textToDisplay + " " + items.BHoriz + " - ";
                                                }
                                                if (lst == "E") {
                                                    textToDisplay = textToDisplay + items.Brand + " " + items.Desc + " " + items.SizeDesc + " - ";
                                                }
                                                if (l > 0) {
                                                    textToDisplay = textToDisplay + "\n";
                                                }
                                                l++;
                                            }
                                        }

                                        if (typeof items.DescID !== "undefined" && items.DescID !== -1) {
                                            var label_obj = item_obj.getObjectById(items.DescID);
                                            item_obj.remove(label_obj);
                                        }
                                        if (typeof item_obj !== "undefined") {
                                            var return_obj = addItemDescription(textToDisplay, 70, g_labelActualSize, text_color, "center", "", items.W, items.H, "Y", g_vert_text_dis, items.ItemID, g_item_vertical_text_display, g_item_text_center_align, items.BHoriz); //ASA-1847 4.1
                                            item_obj.add(return_obj);
                                            return_obj.position.x = 0;
                                            return_obj.position.y = 0;

                                            if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                                //ASA-1292 added beaccuse if the shelf has slope item look like 3d view in shelf so description z has been not more
                                                return_obj.position.z = items.D / 2 + 0.0005;
                                            } else {
                                                return_obj.position.z = 0.0006;
                                            }

                                            item_obj.WireframeObj.material.color.setHex(0x000000);
                                            g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].ItemInfo[k].DescID = return_obj.id;
                                        }
                                    }
                                    k = k + 1;
                                }
                            }
                        }
                        j = j + 1;
                    }
                    var k = 0;
                    if (typeof carparkInfo !== "undefined" && carparkInfo.length > 0) {
                        for (const items of carparkInfo[0].ItemInfo) {
                            if (items.Item !== "DIVIDER" && items.Desc !== "" && typeof items.Desc !== "undefined") {
                                var item_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(items.ObjID);
                                var hex_color = g_pog_json[p_pog_index].ModuleInfo[i].Carpark[0].Color;
                                if (hexToRgb(hex_color) == null) {
                                    var red = parseInt("FF", 16);
                                    var green = parseInt("FF", 16);
                                    var blue = parseInt("FF", 16);
                                } else {
                                    var red = hexToRgb(hex_color).r;
                                    var green = hexToRgb(hex_color).r;
                                    var blue = hexToRgb(hex_color).g;
                                }

                                var text_color;
                                text_color = "#000000";

                                var textToDisplay = "";

                                textToDisplay = items.ItemID + "- " + items.Desc;
                                var return_obj = addItemDescription(textToDisplay, 70, g_labelActualSize, text_color, "center", "", items.W, items.H, "Y", g_vert_text_dis, items.ItemID, g_item_vertical_text_display, g_item_text_center_align, items.BHoriz); //ASA-1847 4.1
                                item_obj.add(return_obj);
                                return_obj.position.x = 0;

                                return_obj.position.y = 0;
                                return_obj.position.z = 0.001;
                                g_pog_json[p_pog_index].ModuleInfo[i].Carpark[0].ItemInfo[k].DescID = return_obj.id;
                            }
                            k = k + 1;
                        }
                    }
                }
                i = i + 1;
            }
            g_camera.position.z = camera_z_pos;
        }
        render(p_pog_index);
        logDebug("function : showHideItemDescription", "E");
    } catch (err) {
        error_handling(err);
    }
}

function nvl(p_value) {
    try {
        // logDebug("function : nvl; value : " + value, "S");
        if (typeof p_value == "undefined" || p_value == "" || p_value == null || p_value == "null") {
            // logDebug("function : nvl", "N");
            return 0;
        } else {
            // logDebug("function : nvl", "N");
            return p_value;
        }
    } catch (err) {
        error_handling(err);
    }
}

async function get_all_images(p_pog_index, p_orientation_flag, p_ImageLoadInd = "N", p_MaxWidth, p_MaxHgt, p_CompRatio) {
    try {
        logDebug("function : get_all_images; ", "S");
        var pogIndex;
        if (typeof g_pog_json !== "undefined" && g_pog_json.length > 0) {
            if (p_ImageLoadInd == "Y") {
                pogIndex = 0;
            } else {
                pogIndex = p_pog_index;
            }
            var items_arr = [];
            for (pogs of g_pog_json) {
                var mod_arr = g_pog_json[pogIndex].ModuleInfo;
                var i = 0;
                if (mod_arr !== null) {
                    for (const modules of mod_arr) {
                        if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                            if (typeof modules.ShelfInfo !== "undefined" && modules.ShelfInfo !== null) {
                                if (modules.ShelfInfo.length > 0) {
                                    j = 0;
                                    for (const shelfs of modules.ShelfInfo) {
                                        if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX") {
                                            if (typeof shelfs.ItemInfo !== "undefined" && shelfs.ItemInfo !== null) {
                                                if (shelfs.ItemInfo.length > 0) {
                                                    var k = 0;
                                                    for (const items of shelfs.ItemInfo) {
                                                        var details = g_orientation_json[items.Orientation];
                                                        var details_arr = details.split("###");
                                                        var detaillist = get_orientation_list(details_arr[0]);
                                                        var l = 0;
                                                        var img_exists = "N";
                                                        for (const images_arr of g_ItemImages) {
                                                            if (items.Item == images_arr.Item && details_arr[0] == images_arr.Orientation && items.MerchStyle == images_arr.MerchStyle) {
                                                                img_exists = "Y";
                                                                break; //return false;
                                                            }
                                                            l++;
                                                        }
                                                        if (items.CapStyle == "1" || items.CapStyle == "2" || items.CapStyle == "3") {
                                                            var cap_exists = "N";
                                                            var cap_merch = typeof items.CapMerch !== "undefined" && items.CapMerch !== "" ? items.CapMerch : "0";
                                                            var cap_orient = typeof items.CapOrientaion !== "undefined" && items.CapOrientaion !== "" ? items.CapOrientaion : "0";
                                                            var cap_details = g_orientation_json[cap_orient];
                                                            var cap_arr = cap_details.split("###");
                                                            for (const images_arr of g_ItemImages) {
                                                                if (items.Item == images_arr.Item && cap_arr[0] == images_arr.Orientation && cap_merch == images_arr.MerchStyle) {
                                                                    cap_exists = "Y";
                                                                    break; //return false;
                                                                }

                                                                l++;
                                                            }
                                                            if (cap_exists == "N") {
                                                                var new_merch_style;
                                                                if (cap_merch == "0") {
                                                                    new_merch_style = "U";
                                                                } else if (cap_merch == "1") {
                                                                    new_merch_style = "T";
                                                                } else if (cap_merch == "2") {
                                                                    new_merch_style = "C";
                                                                } else if (cap_merch == "3") {
                                                                    new_merch_style = "D";
                                                                }
                                                                ItemImageInfo = {};
                                                                ItemImageInfo["Item"] = items.Item;
                                                                ItemImageInfo["Orientation"] = cap_arr[0];
                                                                ItemImageInfo["MerchStyle"] = new_merch_style;
                                                                items_arr.push(ItemImageInfo);
                                                            }
                                                        }
                                                        if (img_exists == "N") {
                                                            var new_merch_style;
                                                            if (items.MerchStyle == "0") {
                                                                new_merch_style = "U";
                                                            } else if (items.MerchStyle == "1") {
                                                                new_merch_style = "T";
                                                            } else if (items.MerchStyle == "2") {
                                                                new_merch_style = "C";
                                                            } else if (items.MerchStyle == "3") {
                                                                new_merch_style = "D";
                                                            }
                                                            ItemImageInfo = {};
                                                            ItemImageInfo["Item"] = items.Item;
                                                            ItemImageInfo["Orientation"] = details_arr[0];
                                                            ItemImageInfo["MerchStyle"] = new_merch_style;
                                                            items_arr.push(ItemImageInfo);
                                                            if (p_orientation_flag == "Y") {
                                                                if (details_arr[0] == 1) {
                                                                    ItemImageInfo = {};
                                                                    ItemImageInfo["Item"] = items.Item;
                                                                    ItemImageInfo["Orientation"] = detaillist[0];
                                                                    ItemImageInfo["MerchStyle"] = new_merch_style;
                                                                    items_arr.push(ItemImageInfo);
                                                                    ItemImageInfo = {};
                                                                    ItemImageInfo["Item"] = items.Item;
                                                                    ItemImageInfo["Orientation"] = detaillist[1];
                                                                    ItemImageInfo["MerchStyle"] = new_merch_style;
                                                                    items_arr.push(ItemImageInfo);
                                                                    ItemImageInfo = {};
                                                                    ItemImageInfo["Item"] = items.Item;
                                                                    ItemImageInfo["Orientation"] = detaillist[2];
                                                                    ItemImageInfo["MerchStyle"] = new_merch_style;
                                                                    items_arr.push(ItemImageInfo);
                                                                } else if (details_arr[0] == 2) {
                                                                    ItemImageInfo = {};
                                                                    ItemImageInfo["Item"] = items.Item;
                                                                    ItemImageInfo["Orientation"] = detaillist[0];
                                                                    ItemImageInfo["MerchStyle"] = new_merch_style;
                                                                    items_arr.push(ItemImageInfo);
                                                                    ItemImageInfo = {};
                                                                    ItemImageInfo["Item"] = items.Item;
                                                                    ItemImageInfo["Orientation"] = detaillist[1];
                                                                    ItemImageInfo["MerchStyle"] = new_merch_style;
                                                                    items_arr.push(ItemImageInfo);
                                                                    ItemImageInfo = {};
                                                                    ItemImageInfo["Item"] = items.Item;
                                                                    ItemImageInfo["Orientation"] = detaillist[2];
                                                                    ItemImageInfo["MerchStyle"] = new_merch_style;
                                                                    items_arr.push(ItemImageInfo);
                                                                } else if (details_arr[0] == 3) {
                                                                    ItemImageInfo = {};
                                                                    ItemImageInfo["Item"] = items.Item;
                                                                    ItemImageInfo["Orientation"] = detaillist[0];
                                                                    ItemImageInfo["MerchStyle"] = new_merch_style;
                                                                    items_arr.push(ItemImageInfo);
                                                                    ItemImageInfo = {};
                                                                    ItemImageInfo["Item"] = items.Item;
                                                                    ItemImageInfo["Orientation"] = detaillist[1];
                                                                    ItemImageInfo["MerchStyle"] = new_merch_style;
                                                                    items_arr.push(ItemImageInfo);
                                                                    ItemImageInfo = {};
                                                                    ItemImageInfo["Item"] = items.Item;
                                                                    ItemImageInfo["Orientation"] = detaillist[2];
                                                                    ItemImageInfo["MerchStyle"] = new_merch_style;
                                                                    items_arr.push(ItemImageInfo);
                                                                } else if (details_arr[0] == 8) {
                                                                    ItemImageInfo = {};
                                                                    ItemImageInfo["Item"] = items.Item;
                                                                    ItemImageInfo["Orientation"] = detaillist[0];
                                                                    ItemImageInfo["MerchStyle"] = new_merch_style;
                                                                    items_arr.push(ItemImageInfo);
                                                                    ItemImageInfo = {};
                                                                    ItemImageInfo["Item"] = items.Item;
                                                                    ItemImageInfo["Orientation"] = detaillist[1];
                                                                    ItemImageInfo["MerchStyle"] = new_merch_style;
                                                                    items_arr.push(ItemImageInfo);
                                                                    ItemImageInfo = {};
                                                                    ItemImageInfo["Item"] = items.Item;
                                                                    ItemImageInfo["Orientation"] = detaillist[2];
                                                                    ItemImageInfo["MerchStyle"] = new_merch_style;
                                                                    items_arr.push(ItemImageInfo);
                                                                }
                                                            }
                                                        }
                                                        k++;
                                                    }
                                                }
                                            }
                                        }
                                        j = j + 1;
                                    }
                                }
                            }
                            if (modules.Carpark !== null && typeof modules.Carpark !== "undefined") {
                                if (typeof modules.Carpark[0] !== "undefined") {
                                    if (modules.Carpark[0].ItemInfo !== null) {
                                        if (modules.Carpark[0].ItemInfo.length > 0) {
                                            var k = 0;
                                            for (const items of modules.Carpark[0].ItemInfo) {
                                                var details = g_orientation_json[items.Orientation];
                                                var details_arr = details.split("###");
                                                var l = 0;
                                                var img_exists = "N";
                                                for (const images_arr of g_ItemImages) {
                                                    if (items.Item == images_arr.Item && details_arr[0] == images_arr.Orientation && items.MerchStyle == images_arr.MerchStyle) {
                                                        img_exists = "Y";
                                                        break; //return false;
                                                    }
                                                    l++;
                                                }
                                                if (img_exists == "N") {
                                                    var new_merch_style;
                                                    if (items.MerchStyle == "0") {
                                                        new_merch_style = "U";
                                                    } else if (items.MerchStyle == "1") {
                                                        new_merch_style = "T";
                                                    } else if (items.MerchStyle == "2") {
                                                        new_merch_style = "C";
                                                    } else if (items.MerchStyle == "3") {
                                                        new_merch_style = "D";
                                                    }
                                                    ItemImageInfo = {};
                                                    ItemImageInfo["Item"] = items.Item;
                                                    ItemImageInfo["Orientation"] = details_arr[0];
                                                    ItemImageInfo["MerchStyle"] = new_merch_style;
                                                    items_arr.push(ItemImageInfo);
                                                }
                                                k++;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        i = i + 1;
                    }
                }
                if (p_ImageLoadInd == "Y") {
                    pogIndex++;
                } else {
                    break;
                }
            }
            var retval = await get_all_image_ajax(items_arr);
            var i = 0;
            for (var details of g_ItemImages) {
                var image = new Image();
                var returnval = "";
                image.src = "data:image/jpeg;base64," + details.ItemImage;
                image.onload = function () {
                    async function imageLoad(image) {
                        var comp_details = await resizeImage(image, parseFloat(p_MaxWidth), parseFloat(p_MaxHgt), parseFloat(p_CompRatio));
                        var compress_image = comp_details.split(",");

                        return compress_image[1]; //$.trim(data);
                    }
                    const printAddress = async () => {
                        returnval = await imageLoad(image);
                        if (i <= g_ItemImages.length - 1) {
                            g_ItemImages[i].ItemImage = returnval;
                        }
                    };

                    printAddress();
                };
                i++;
            }
        }
        logDebug("function : get_all_images; ", "E");
        return "SUCCESS";
    } catch (err) {
        error_handling(err);
    }
}

function get_all_image_ajax(p_items_arr) {
    return new Promise(function (resolve, reject) {
        try {
            var startDate = new Date();
            logDebug("function : get_all_image_ajax; ", "S");
            var p = apex.server.process(
                "GET_IMAGE_CLOB",
                {
                    p_clob_01: JSON.stringify(p_items_arr),
                },
                {
                    dataType: "html",
                }
            );
            // When the process is done, call functions
            p.done(function (data) {
                if ($.trim(data) !== "") {
                    g_ItemImages = g_ItemImages.concat(JSON.parse($.trim(data)));
                    logDebug("function : get_all_image_ajax; ", "E");
                    resolve("SUCESS");
                } else {
                    console.log("Image Not Found");
                    logDebug("function : get_all_image_ajax; ", "E");
                    resolve("SUCESS");
                }
                var endDate = new Date();
                var seconds = (endDate.getTime() - startDate.getTime()) / 1000;
                console.log("Seconds Difference", seconds);
            });
            logDebug("function : get_all_image_ajax ; ", "E");
        } catch (err) {
            error_handling(err);
        }
    });
}

function show_single_item_desc(p_module_index, p_shelf_index, p_item_index, p_items, p_item_obj, p_camera, p_backColor, p_pogcrDisplayItemInfo, p_pog_index) {

    if (p_items.Item !== "DIVIDER" && p_items.Desc !== "" && typeof p_items.Desc !== "undefined" && g_show_desc_no_image == "Y") {
        var camera_z_pos = p_camera.position.z;
        p_camera.position.z = 7;
        var hex_color = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].Color;
        if (hexToRgb(hex_color) == null) {
            var red = parseInt("FF", 16);
            var green = parseInt("FF", 16);
            var blue = parseInt("FF", 16);
        } else {
            var red = hexToRgb(hex_color).r;
            var green = hexToRgb(hex_color).r;
            var blue = hexToRgb(hex_color).g;
        }

        var text_color;
        text_color = "#000000";

        var back_color = p_backColor;
        var colorValue = parseInt(back_color.replace("#", "0x"), 16);
        var hex_decimal = new THREE.Color(colorValue);
        var desc_list_arr = p_pogcrDisplayItemInfo.split(",");
        var textToDisplay = "";
        if (g_temp_desc == "N") {
            for (q = 0; q < desc_list_arr.length; q++) {
                if (desc_list_arr[q] == "ITEM") {
                    textToDisplay = textToDisplay + p_items.ItemID + " - ";
                } else if (desc_list_arr[q] == "DESCRIPTION") {
                    textToDisplay = textToDisplay + p_items.Desc + " - ";
                }
            }
        } else {
            var desc_list = g_temp_desc.split("");
            var l = 0;
            var SalesInfo = get_sales_info(p_pog_index, p_items.ItemID);
            for (const lst of desc_list) {
                if (lst == "I") {
                    textToDisplay = textToDisplay + p_items.ItemID + " - ";
                }
                if (lst == "D") {
                    textToDisplay = textToDisplay + p_items.Desc + " " + p_items.DescSecond + " - ";
                }
                if (lst == "V") {
                    textToDisplay = textToDisplay + " SV: " + SalesInfo.SalesPerWeek + " ";
                }
                if (lst == "U") {
                    textToDisplay = textToDisplay + "SU " + SalesInfo.SalesUnitPerWeek + " ";
                }
                if (lst == "R") {
                    textToDisplay = textToDisplay + " VRM$: " + SalesInfo.VRM + " ";
                }

                if (lst == "C") {
                    var det_arr = p_items.SizeDesc.split("*");
                    details = (p_items.BHoriz * p_items.BVert * p_items.BaseD) / parseInt(det_arr[1]); //ASA-1247

                    if (isNaN(details) || !isFinite(details)) {
                        temp_text = "C: " + 0;
                    } else {
                        temp_text = "C: " + details.toFixed(1);
                    }
                    textToDisplay = textToDisplay + temp_text + " ";
                }
                if (lst == "O") {
                    details = (p_items.BHoriz * p_items.BVert * p_items.BaseD) / (SalesInfo.SalesUnitPerWeek / 7);
                    if (isNaN(details) || !isFinite(details)) {
                        temp_text = "D: " + 0;
                    } else {
                        temp_text = "D: " + details.toFixed(1);
                    }
                    textToDisplay = textToDisplay + temp_text + " ";
                }
                if (lst == "P") {
                    textToDisplay = textToDisplay + "VRM%: " + SalesInfo.VRMPer + " ";
                }
                if (lst == "F") {
                    textToDisplay = textToDisplay + " " + p_items.BHoriz + " - ";
                }
                if (lst == "E") {
                    textToDisplay = textToDisplay + p_items.Brand + " " + p_items.Desc + " " + p_items.SizeDesc + " - ";
                }
                if (l > 0) {
                    textToDisplay = textToDisplay + "\n";
                }
                l++;
            }
        }
        if (typeof p_items.DescID !== "undefined" && p_items.DescID !== -1) {
            var label_obj = p_item_obj.getObjectById(p_items.DescID);
            p_item_obj.remove(label_obj);
        }
        var return_obj = addItemDescription(textToDisplay, 70, g_labelActualSize, text_color, "center", "", p_items.W, p_items.H, "Y", g_vert_text_dis, p_items.ItemID, g_item_vertical_text_display, g_item_text_center_align, p_items.BHoriz); //ASA-1847 4.1
        p_item_obj.add(return_obj);
        return_obj.position.x = 0;
        return_obj.position.y = 0;
        // return_obj.position.z = 0.001; //ASA-1729 Issue 7
        return_obj.position.z = 0.0006; //ASA-1839 0.0008; //ASA-1729 Issue 7
        p_item_obj.WireframeObj.material.color.setHex(0x000000);
        g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].DescID = return_obj.id;
        p_camera.position.z = camera_z_pos;
    }
}

function setParams(p_LabelFont, p_StatusErrorColor, p_CameraZ, p_TextboxMergePdf, p_AutoHangbarFacing, p_AutoApplyDFacing, p_AutoApplyVFacing, p_ShowLiveImage, p_DimErrorColor, p_PogcrAutoHliteNonMvItem, p_ShowDescNoImage, p_NotchLblPos, p_fixel_label, p_vert_text_dis, p_dft_max_merch) {
    //ASA1310_20240307 crush item onload
    if (p_LabelFont) {
        g_labelFont = parseInt(p_LabelFont);
        g_labelActualSize = 0.0034375 * p_LabelFont;
    }
    if (p_StatusErrorColor) {
        g_status_error_color = parseInt(p_StatusErrorColor.replace("#", "0x"), 16);
    }
    if (p_CameraZ) {
        g_offset_z = parseFloat(p_CameraZ);
    }
    if (p_TextboxMergePdf) {
        g_textbox_merge_pdf = p_TextboxMergePdf;
    }
    if (p_AutoHangbarFacing) {
        g_auto_hangbar_facings = p_AutoHangbarFacing;
    }
    if (p_AutoApplyDFacing) {
        g_auto_apply_d_facings = p_AutoApplyDFacing;
    }
    if (p_AutoApplyVFacing) {
        g_auto_apply_v_facings = p_AutoApplyVFacing;
    }
    if (p_ShowLiveImage) {
        g_show_live_image = p_ShowLiveImage;
    }
    if (p_DimErrorColor) {
        g_dim_error_color = parseInt(p_DimErrorColor.replace("#", "0x"), 16);
    }
    if (p_PogcrAutoHliteNonMvItem) {
        g_pogcr_auto_hlite_non_mv_item = p_PogcrAutoHliteNonMvItem;
    }
    if (p_ShowDescNoImage) {
        g_show_desc_no_image = p_ShowDescNoImage;
    }
    if (p_NotchLblPos) {
        g_notch_label_position = p_NotchLblPos;
    }
    if (p_fixel_label) {
        g_fixel_label = p_fixel_label;
    }
    if (p_dft_max_merch) {
        //ASA1310_20240307 crush item onload
        g_dft_max_merch = p_dft_max_merch;
    }
}

async function showHideDaysOfSupplyLabel(p_show_label_ind, p_updatePogItemColl = "N", p_pog_index, p_updateItemScene = "Y", p_UpdateItemInfo = "N", p_DaysofsuppFontSize, p_ItemDtlList) {
    try {
        logDebug("function : showHideDaysOfSupplyLabel; show_label_ind : " + p_show_label_ind, "S");
        if (g_pog_json.length > 0) {
            var module_details = g_pog_json[p_pog_index].ModuleInfo;
            var old_camera_z = g_scene_objects[p_pog_index].scene.children[0].position.z;
            if (p_show_label_ind == "N") {
                var i = 0;
                for (const modules of module_details) {
                    if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                        var l_shelf_details = modules.ShelfInfo;
                        var carparkInfo = g_pog_json[p_pog_index].ModuleInfo[i].Carpark;
                        var j = 0;
                        for (const shelfs of l_shelf_details) {
                            if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX") {
                                if (shelfs.ItemInfo.length > 0) {
                                    var item_Details = shelfs.ItemInfo;
                                    var k = 0;
                                    for (const items_info of item_Details) {
                                        if (items_info.Item !== "DIVIDER" && items_info.DaysOfSupply !== "" && typeof items_info.DaysOfSupply !== "undefined") {
                                            console.log("beforeupdatedos func", g_show_days_of_supply);
                                            var item1 = await updateDaysOfSupply(items_info, k, j, i, "N", p_updatePogItemColl, p_pog_index, p_UpdateItemInfo);
                                            var item_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(items_info.ObjID);
                                            if (typeof items_info.daysOfSupplyID !== "undefined" && items_info.daysOfSupplyID !== -1) {
                                                var label_obj = item_obj.getObjectById(items_info.daysOfSupplyID);
                                                item_obj.remove(label_obj);
                                            }
                                            g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].ItemInfo[k].daysOfSupplyID = -1;
                                        }
                                        k = k + 1;
                                    }
                                }
                            }
                            j = j + 1;
                        }
                        var k = 0;
                        if (typeof carparkInfo !== "undefined" && carparkInfo.length > 0) {
                            for (const items_info of carparkInfo[0].ItemInfo) {
                                if (items_info.Item !== "DIVIDER" && items_info.DaysOfSupply !== "" && typeof items_info.DaysOfSupply !== "undefined") {
                                    var item1 = await updateDaysOfSupply(items_info, k, j, i, "Y", p_updatePogItemColl, p_pog_index);
                                    var item_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(items_info.ObjID);
                                    if (typeof items_info.daysOfSupplyID !== "undefined" && items_info.daysOfSupplyID !== -1) {
                                        var label_obj = item_obj.getObjectById(items_info.daysOfSupplyID);
                                        item_obj.remove(label_obj);
                                    }
                                    g_pog_json[p_pog_index].ModuleInfo[i].Carpark[0].ItemInfo[k].daysOfSupplyID = -1;
                                }
                                k = k + 1;
                            }
                        }
                    }
                    i = i + 1;
                }
            } else {
                var item_lbl_dtl = p_ItemDtlList.split(","); //ASA-1608 Issue 1
                var i = 0;
                g_scene_objects[p_pog_index].scene.children[0].position.z = 6;
                for (const modules of module_details) {
                    if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                        var l_shelf_details = modules.ShelfInfo;
                        var carparkInfo = g_pog_json[p_pog_index].ModuleInfo[i].Carpark;
                        var j = 0;
                        for (const shelfs of l_shelf_details) {
                            if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX") {
                                if (shelfs.ItemInfo.length > 0) {
                                    var item_Details = shelfs.ItemInfo;
                                    var k = 0;
                                    for (const items_info of item_Details) {
                                        var item1 = await updateDaysOfSupply(items_info, k, j, i, "N", p_updatePogItemColl, p_pog_index, p_UpdateItemInfo);
                                        if (typeof item1 !== "undefined" && p_updateItemScene == "Y") {
                                            if (item1.Item !== "DIVIDER" && item1.DaysOfSupply !== "" && typeof item1.DaysOfSupply !== "undefined") {
                                                var item_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(item1.ObjID);
                                                if (typeof item_obj !== "undefined") {
                                                    var text_color = "#000000";
                                                    var textToDisplay = "";
                                                    if (nvl(item_obj) !== 0) {
                                                        var l = 0;
                                                        for (const obj of item_lbl_dtl) {
                                                            var temp_text = "";
                                                            var l_dos = obj.split(":"); //ASA-1427 -S
                                                            var SalesInfo = get_sales_info(p_pog_index, items_info.ItemID);
                                                            if (l_dos[0] == "COS") {
                                                                var det_arr = items_info.SizeDesc.split("*");
                                                                var cap_capacity = items_info.CapFacing * items_info.CapDepth * items_info.CapHorz * parseInt(items_info.CapMerch == 1 ? items_info.UnitperTray : 1); //ASA-1605
                                                                //var cap_capacity = items_info.CapFacing * items_info.CapDepth * items_info.CapHorz; //ASA-1341 Issue-2 added Cap_capacity in COS Calculation. //ASA-1605
                                                                details = (items_info.BHoriz * items_info.BVert * items_info.BaseD * parseInt(items_info.MerchStyle == 1 ? items_info.UnitperTray : items_info.MerchStyle == 2 ? items_info.UnitperCase : 1) + cap_capacity) / parseInt(det_arr[1]); //ASA-1605 //ASA-1871 adding condition for case
                                                                //details = ((items_info.BHoriz * items_info.BVert * items_info.BaseD) + cap_capacity) / parseInt(det_arr[1]); //ASA-1247 //ASA-1605

                                                                if (isNaN(details) || !isFinite(details)) {
                                                                    temp_text = l_dos[1] + ": " + 0;
                                                                } else {
                                                                    temp_text = l_dos[1] + ": " + details.toFixed(1);
                                                                }
                                                            }
                                                            if (l_dos[0] == "DOS") {
                                                                //temp_text = (items_info.BHoriz * items_info.BVert * items_info.BaseD * parseInt(items_info.MerchStyle == 1 ? items_info.UnitperTray : 1)) / (SalesInfo.SalesUnitPerWeek / 7);//ASA-1605
                                                                temp_text = parseFloat(item_obj.DaysOfSupply).toFixed(1);
                                                            } else if (l_dos[0] == "SALES") {
                                                                temp_text = l_dos[1] + ": " + SalesInfo.SalesPerWeek;
                                                            } else if (l_dos[0] == "UNIT") {
                                                                temp_text = l_dos[1] + ": " + SalesInfo.SalesUnitPerWeek;
                                                            } else if (l_dos[0] == "VRMS") {
                                                                temp_text = l_dos[1] + ": " + SalesInfo.VRMPer;
                                                            } else if (l_dos[0] == "DOS_CAL") {
                                                                details = (items_info.BHoriz * items_info.BVert * items_info.BaseD * parseInt(items_info.MerchStyle == 1 ? items_info.UnitperTray : items_info.MerchStyle == 2 ? items_info.UnitperCase : 1)) / (SalesInfo.SalesUnitPerWeek / 7); //ASA-1605 //ASA-1871 adding condition for case
                                                                // details = (items_info.BHoriz * items_info.BVert * items_info.BaseD) / (SalesInfo.SalesUnitPerWeek / 7); //ASA-1605
                                                                if (isNaN(details) || !isFinite(details)) {
                                                                    temp_text = l_dos[1] + ": " + 0;
                                                                } else {
                                                                    temp_text = l_dos[1] + ": " + details.toFixed(1);
                                                                }
                                                            } else if (l_dos[0] == "AVG_SALES_WK") {
                                                                //ASA-1360 task 1 Start
                                                                temp_text = l_dos[1] + ": " + SalesInfo.AvgSalesPerWeek;
                                                            } else if (l_dos[0] == "AVG_QTY_WK") {
                                                                temp_text = l_dos[1] + ": " + SalesInfo.AvgQtyPerWeek;
                                                            } else if (l_dos[0] == "SALES_PER") {
                                                                temp_text = l_dos[1] + "%: " + SalesInfo.SalesPartPer;
                                                            } else if (l_dos[0] == "QTY_PER") {
                                                                temp_text = l_dos[1] + "%: " + SalesInfo.QtyPartPer;
                                                            } else if (l_dos[0] == "NO_OF_LIST") {
                                                                temp_text = l_dos[1] + ": " + SalesInfo.NoOfListing;
                                                            } else if (l_dos[0] == "GP") {
                                                                temp_text = l_dos[1] + ": " + SalesInfo.GP;
                                                            } else if (l_dos[0] == "ASP") {
                                                                temp_text = l_dos[1] + ": " + SalesInfo.ASP;
                                                            } //ASA-1360 task 1 End , //ASA-1427 -E
                                                            //ASA-1427 S
                                                            else if (l_dos[0] == "EDLP") {
                                                                var l_edlp = typeof items_info.EDLP !== "undefined" && items_info.EDLP !== null ? items_info.EDLP : 0;
                                                                temp_text = l_dos[1] + ": " + l_edlp;
                                                            }
                                                            //ASA-1427 E
                                                            if (l == 0) {
                                                                textToDisplay = temp_text;
                                                            } else {
                                                                textToDisplay = textToDisplay + "\n" + temp_text;
                                                            }

                                                            l++;
                                                        }
                                                    }
                                                    textToDisplay.substring(1);
                                                    if (nvl(item1.daysOfSupplyID) !== 0 && item1.daysOfSupplyID !== -1) {
                                                        var label_obj = item_obj.getObjectById(item1.daysOfSupplyID);
                                                        item_obj.remove(label_obj);
                                                    }
                                                    //ASA-1427 Issue 1
                                                    // if (item_lbl_dtl.length > 1) {
                                                    var return_obj = addDaysOfSupply(textToDisplay, 20, g_labelActualSize, text_color, "center", "#ffffff", p_DaysofsuppFontSize, item1.W, item1.H);
                                                    // } else {
                                                    // var return_obj = addDaysOfSupplySingle(textToDisplay, 12, g_labelActualSize, text_color, "center", "#ffffff", p_DaysofsuppFontSize);
                                                    // }
                                                    item_obj.add(return_obj);
                                                    return_obj.uuid = "days_of_supply";
                                                    //ASA-1427 Issue 1
                                                    //  if (item_lbl_dtl.length > 1) {
                                                    new_x = item1.W / 2;
                                                    new_y = item1.H / 2;
                                                    return_obj.position.x = 0;
                                                    return_obj.position.y = 0;
                                                    if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                                        //ASA-1289
                                                        return_obj.position.z = item1.D / 2 + 0.005;
                                                    } else {
                                                        // return_obj.position.z = 0.005; //ASA-1608 Issue 1
                                                        return_obj.position.z = 0.0006; //ASA-1839 0.0008; //ASA-1608 Issue 1
                                                    }
                                                    //ASA-1427 Issue 1 S
                                                    /*   } 
                                                    else {
                                                        return_obj.position.x = 0.0015625 * 12 - item1.W / 2;
                                                        return_obj.position.y = item1.H / 2 - 0.0015625 * 12;
                                                        if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) { //ASA-1289
                                                            return_obj.position.z = item1.D / 2 + 0.005;
                                                        } else {
                                                            return_obj.position.z = 0.005;
                                                        }
                                                    }*/ //ASA-1427 Issue 1 E

                                                    g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].ItemInfo[k].daysOfSupplyID = return_obj.id;
                                                }
                                            }
                                        }
                                        k = k + 1;
                                    }
                                }
                            }
                            j = j + 1;
                        }
                        var k = 0;
                        if (typeof carparkInfo !== "undefined" && carparkInfo.length > 0) {
                            for (const items_info of carparkInfo[0].ItemInfo) {
                                if (items_info.Item !== "DIVIDER" && items_info.DaysOfSupply !== "" && typeof items_info.DaysOfSupply !== "undefined") {
                                    var item_carpark = await updateDaysOfSupply(items_info, k, 0, i, "Y", p_updatePogItemColl, p_pog_index, p_UpdateItemInfo);
                                    if (p_updateItemScene == "Y") {
                                        var item_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(items_info.ObjID);
                                        var text_color = "#000000";
                                        var textToDisplay = "";
                                        var selectedObject = g_scene_objects[p_pog_index].scene.children[2].getObjectById(items_info.ObjID);
                                        if (nvl(selectedObject) !== 0) {
                                            textToDisplay = selectedObject.DaysOfSupply;
                                        }
                                        if (typeof items_info.daysOfSupplyID !== "undefined" && items_info.daysOfSupplyID !== -1) {
                                            var label_obj = item_obj.getObjectById(items_info.daysOfSupplyID);
                                            item_obj.remove(label_obj);
                                        }
                                        var return_obj = addDaysOfSupply(textToDisplay, 20, g_labelActualSize, text_color, "center", "#ffffff", p_DaysofsuppFontSize, items_info.W, items_info.H);
                                        item_obj.add(return_obj);
                                        return_obj.uuid = "days_of_supply";
                                        g_pog_json[p_pog_index].ModuleInfo[i].Carpark[0].ItemInfo[k].daysOfSupplyID = return_obj.id;
                                    }
                                }
                                k = k + 1;
                            }
                        }
                    }
                    i = i + 1;
                }
                g_scene_objects[p_pog_index].scene.children[0].position.z = old_camera_z;
            }
        }
        render(p_pog_index);
        logDebug("function : showHideDaysOfSupplyLabel", "E");
    } catch (err) {
        error_handling(err);
    }
}

function addDaysOfSupplySingle(p_text, p_textHeight, p_actualFontSize, p_font_color, p_txt_align, p_back_color, p_DaysofsuppFontSize) {
    try {
        logDebug("function : addlabelText; text : " + p_text + "; textHeight : " + p_textHeight + "; actualFontSize : " + p_actualFontSize + "; font_color : " + p_font_color + "; txt_align : " + p_txt_align + "; back_color : " + p_back_color, "S");
        // 2d duty
        var text_canvas = document.createElement("canvas");
        var context = text_canvas.getContext("2d");
        context.fillStyle = "#000000";
        var metrics = context.measureText(p_text);
        var textWidth = metrics.width;
        if (p_DaysofsuppFontSize.split(",")[0] == "N") {
            var p_actualFontSize = p_DaysofsuppFontSize.split(",")[1];
        } else {
            p_actualFontSize = p_DaysofsuppFontSize.split(",")[1];
        }
        var [width, height] = get_visible_text_dim(p_text, p_textHeight);

        text_canvas.width = width;
        text_canvas.height = height;

        context.font = "normal " + p_textHeight + "px Arial";
        context.textAlign = p_txt_align;
        context.textBaseline = "middle";
        if (p_back_color !== "") {
            context.fillStyle = p_back_color; //"#000000";
            context.fillRect(0, 0, text_canvas.width, text_canvas.height);
        }
        context.fillStyle = p_font_color;
        context.fillText(p_text, width / 2, height / 2);

        //var texture = new THREE.Texture(text_canvas);
        let tex = new THREE.CanvasTexture(text_canvas);
        tex.minFilter = THREE.LinearFilter;
        var material = new THREE.SpriteMaterial({
            map: tex,
        });
        material.map.minFilter = THREE.LinearFilter;
        var sprite = new THREE.Sprite(material);
        sprite.scale.set((width / height) * p_actualFontSize, p_actualFontSize, 1);
        sprite.uuid = "days_of_supply";
        logDebug("function : addlabelText", "E");
        return sprite;
    } catch (err) {
        error_handling(err);
    }
}

function addDaysOfSupply(p_text, p_textHeight, p_actualFontSize, p_font_color, p_txt_align, p_back_color, p_DaysofsuppFontSize, p_width, p_height) {
    try {
        logDebug("function : addlabelText; text : " + p_text + "; textHeight : " + p_textHeight + "; actualFontSize : " + p_actualFontSize + "; font_color : " + p_font_color + "; txt_align : " + p_txt_align + "; back_color : " + p_back_color, "S");
        // 2d duty
        var lines = p_text.split("\n");
        var new_width = p_width * 10;
        var new_height = p_height * 10;
        // 2d duty
        p_textHeight = 70;
        var text_canvas = document.createElement("canvas");
        var context = text_canvas.getContext("2d");
        //var textHeight = 12;
        context.fillStyle = "#000000";
        var metrics = context.measureText(p_text);
        var textWidth = metrics.width;
        if (p_DaysofsuppFontSize.split(",")[0] == "N") {
            var p_actualFontSize = p_DaysofsuppFontSize.split(",")[1];
        } else {
            p_actualFontSize = p_DaysofsuppFontSize.split(",")[1];
        }

        //ASA-1427 Issue 1
        /*var len_text = p_text;
        if (lines.length > 1) {
            var len = 0;
            for (obj of lines) {
                if (obj.length > len) {
                    len_text = obj;
                    len = obj.length;
                }
            }
        }*/
        // if (lines.length > 1) {
        p_actualFontSize = (p_actualFontSize / 1.5) * lines.length;
        // }

        var [canvasWidth, canvasHeight] = get_visible_size(0.012, new_width, new_height, g_canvas, g_camera);
        //var [width, height] = get_visible_text_dim(p_text, p_textHeight);

        text_canvas.width = canvasWidth;
        text_canvas.height = canvasHeight;

        context.font = "bold " + p_textHeight + "px Arial";
        context.textAlign = p_txt_align;
        context.textBaseline = "middle";
        if (p_back_color !== "") {
            context.fillStyle = p_back_color; //"#000000";
            context.fillRect(0, 0, text_canvas.width, text_canvas.height);
        }
        context.fillStyle = p_font_color;
        //ASA-1427 Issue 1
        //  if (lines.length > 1) {
        var x = 0,
            y = 0;
        var line_y = y + p_textHeight / 2;
        for (var i = 0; i < lines.length; i++) {
            var metrics = context.measureText(lines[i]);
            var gap = p_width - metrics.width;
            var new_x = x - gap / 2 + 2;
            context.fillText(lines[i], new_x, line_y);
            line_y += p_textHeight * 1.11;
        }
        //    } else {
        //         context.fillText(p_text, p_width / 2, p_height / 2);
        //      }

        let tex = new THREE.CanvasTexture(text_canvas);
        tex.minFilter = THREE.LinearFilter;
        tex.matrixAutoUpdate = true;
        tex.needsUpdate = true;
        tex.isCanvasTexture = true;
        var geometry = new THREE.PlaneGeometry(p_width, p_height);
        var material = new THREE.MeshBasicMaterial({
            side: THREE.DoubleSide,
            map: tex,
            transparent: true,
            opacity: 0.6,
        });

        material.map.minFilter = THREE.LinearFilter;
        var sprite = new THREE.Mesh(geometry, material);
        sprite.uuid = "days_of_supply";
        logDebug("function : addlabelText", "E");
        return sprite;
    } catch (err) {
        error_handling(err);
    }
}



async function showFixelAvailableSpace(p_resetYN, p_calcShelfSpace, p_pog_index) {
    try {
        logDebug("function : showFixelAvailableSpace; resetYN : " + p_resetYN + "; calcShelfSpace : " + p_calcShelfSpace, "S");
        p_calcShelfSpace = typeof p_calcShelfSpace == "undefined" ? "N" : p_calcShelfSpace;
        g_labelFont = 12; //ASA-1668
        var [currCombinationIndx, currShelfCombIndx] = [-1, -1]; //ASA-1668
        var originalCanvas = g_pog_index;
        if (p_calcShelfSpace == "N") {
            p_resetYN = typeof p_resetYN == "undefined" ? "Y" : p_resetYN;
            if (p_resetYN == "Y") {
                if (g_show_fixel_space == "N") {
                    g_show_fixel_space = "Y";
                    $(".fixel_space").addClass("item_label_active");
                } else {
                    g_show_fixel_space = "N";
                    $(".fixel_space").removeClass("item_label_active");
                }
            }
            var tempJson = [];
            if (typeof p_pog_index !== "undefined") {
                tempJson.push(g_pog_json[p_pog_index]);
            } else {
                tempJson = g_pog_json;
            }
            if (g_show_fixel_space == "Y") {
                if (g_all_pog_flag == "N") {
                    var i = p_pog_index;
                } else {
                    var i = 0;
                }
                for (const pogInfo of g_pog_json) {
                    if ((i !== g_ComViewIndex && g_ComViewIndex > -1) || g_ComViewIndex == -1 || (i == g_ComViewIndex && g_compare_view == "PREV_VERSION")) {
                        g_scene = g_scene_objects[i].scene;
                        g_camera = g_scene_objects[i].scene.children[0];
                        var m = 0;
                        for (const modules_info of g_pog_json[i].ModuleInfo) {
                            //ASA-2023 task-2
                            if (!modules_info || !Array.isArray(modules_info.ShelfInfo)) {
                                continue;
                            }
                            //ASA-2023 task-2
                            var j = 0;
                            for (const shelfs of modules_info.ShelfInfo) {
                                var shelf_obj = g_scene_objects[i].scene.children[2].getObjectById(shelfs.SObjID); //ASA-1668
                                if (typeof shelf_obj !== "undefined" && (shelfs.ObjType == "SHELF" || shelfs.ObjType == "HANGINGBAR")) {
                                    [currCombinationIndx, currShelfCombIndx] = getCombinationShelf(i, shelfs.Shelf);
                                }
                                if (currCombinationIndx !== -1 && currShelfCombIndx !== -1) {
                                    calcCombineShelfAvlSpace(i, currCombinationIndx); //ASA-1668
                                } else {
                                    // var shelf_obj = g_scene_objects[i].scene.children[2].getObjectById(shelfs.SObjID);//ASA-1668
                                    if (typeof shelf_obj !== "undefined" && (shelfs.ObjType == "SHELF" || shelfs.ObjType == "HANGINGBAR" || shelfs.ObjType == "ROD")) {
                                        var itemsSpace = 0;
                                        if (typeof shelfs.ROverhang == "undefined" || shelfs.ROverhang == "") {
                                            //ASA-1237
                                            shelfs.ROverhang = 0;
                                        }
                                        if (typeof shelfs.LOverhang == "undefined" || shelfs.LOverhang == "") {
                                            //ASA-1237
                                            shelfs.LOverhang = 0;
                                        }
                                        if (g_lr_overhung == "Y") {
                                            var shelfWidth = shelfs.W + shelfs.ROverhang + shelfs.LOverhang; //ASA-1237
                                        } else {
                                            var shelfWidth = shelfs.W;
                                        }
                                        var shelfDepth = shelfs.D;
                                        var availableSpace = 0;
                                        var k = 0;
                                        //ASA-2023 task-2
                                        var shelfItems = Array.isArray(shelfs.ItemInfo) ? shelfs.ItemInfo : [];
                                        // for (const items of shelfs.ItemInfo) {
                                        for (const items of shelfItems) {
                                            //ASA-2023 task-2
                                            if (typeof items.BottomObjID == "undefined" || items.BottomObjID == "") {
                                                if (shelfs.ObjType == "SHELF" || shelfs.ObjType == "HANGINGBAR") {
                                                    itemsSpace += items.W;

                                                } else {
                                                    itemsSpace += items.D;
                                                }
                                                k++;
                                            }
                                        }
                                        if (shelfs.ObjType == "SHELF" || shelfs.ObjType == "HANGINGBAR") {
                                            // 1902 Available space should be calculated
                                            if (shelfs.SpreadItem !== "E") {
                                                var horizGap = shelfs.HorizGap ? shelfs.HorizGap : 0;
                                                var horizGapSpace = (k > 1) ? horizGap * (k - 1) : 0;
                                                itemsSpace += horizGapSpace;
                                            }
                                            availableSpace = wpdSetFixed((shelfWidth - itemsSpace) * 100); //.toFixed(3));
                                        } else {
                                            availableSpace = wpdSetFixed((shelfDepth - itemsSpace) * 100); //.toFixed(3));
                                        }
                                        //ASA-1970 Start
                                        //ASA-1946
                                        // if (shelfs.SpreadItem == "F" && shelfs.ItemInfo?.length == 1 && (shelfs.ObjType == "SHELF" || shelfs.ObjType == "HANGINGBAR")) {
                                        //    	var itemWidth = shelfs.ItemInfo[0]?.CrushHoriz > 0 ? shelfs.ItemInfo[0]?.W : shelfs.ItemInfo[0]?.RW;  //ASA-1946 Issue1
                                        // 	availableSpace = wpdSetFixed((shelfWidth - itemWidth) * 100);
                                        // }
                                        if (shelfs.SpreadItem == "F" && (shelfs.ObjType == "SHELF" || shelfs.ObjType == "HANGINGBAR")) {
                                            var itemWidth = 0;
                                            for (const item of shelfs.ItemInfo) {
                                                // itemWidth += item?.RW;
                                                itemWidth += item?.CrushHoriz > 0 ? item?.W : item?.RW;
                                            }
                                            availableSpace = wpdSetFixed((shelfWidth - itemWidth) * 100);
                                        }
                                        //ASA-1970 End
                                        if (typeof shelfs.availableSpaceObjID !== "undefined" && shelfs.availableSpaceObjID !== -1) {
                                            //ASA-1073 obj is undefined in case of undo need to update
                                            var obj = shelf_obj.getObjectById(shelfs.availableSpaceObjID);
                                            shelf_obj.remove(obj);
                                        }
                                        var hex_color = shelfs.Color;
                                        if (hexToRgb(hex_color) == null) {
                                            var red = parseInt("FF", 16);
                                            var green = parseInt("FF", 16);
                                            var blue = parseInt("FF", 16);
                                        } else {
                                            var red = hexToRgb(hex_color).r;
                                            var green = hexToRgb(hex_color).r;
                                            var blue = hexToRgb(hex_color).g;
                                        }

                                        var text_color = getTextColor(red, green, blue); //ASA-1095

                                        // g_labelFont = 12;
                                        if (availableSpace < 0) {
                                            availableSpace = 0;
                                        }
                                        var return_obj = addlabelText("Space " + availableSpace, g_labelFont, g_labelActualSize, text_color, "center", "");
                                        shelf_obj.add(return_obj);
                                        var shelfObj = g_scene_objects[i].scene.children[2].getObjectById(shelfs.SObjID);
                                        shelfObj.AvlSpace = availableSpace; //ASA-1237
                                        if (shelfs.ObjType == "ROD") {
                                            return_obj.position.y = -0.009;
                                        } else {
                                            return_obj.position.y = -0.005;
                                        }
                                        return_obj.uuid = "fixel_space";
                                        if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                            return_obj.position.z = shelfs.D / 2 + 0.005;
                                        } else {
                                            return_obj.position.z = 0.005;
                                        }
                                        if (shelfs.ObjType !== "DIVIDER") {
                                            if (shelfs.ObjType == "ROD") {
                                                return_obj.position.x = 0 + (shelfs.W / 2.4 + 0.08);
                                            } else {
                                                return_obj.position.x = 0 + (shelfs.W / 2.4 - 0.08);
                                            }
                                            modules_info.ShelfInfo[j].availableSpaceObjID = return_obj.id;
                                        }
                                    }
                                }
                                j++;
                            }
                            m++;
                        }
                        render(i);
                        set_indicator_objects(i);
                    }
                    if (g_all_pog_flag == "Y") {
                        i++;
                    } else {
                        break;
                    }
                }
                g_scene = g_scene_objects[originalCanvas].scene;
                g_camera = g_scene_objects[originalCanvas].scene.children[0];
            }
            else {
                if (g_all_pog_flag == "N") {
                    var i = p_pog_index;
                } else {
                    var i = 0;
                }
                for (const pogInfo of g_pog_json) {
                    if ((i !== g_ComViewIndex && g_ComViewIndex > -1) || g_ComViewIndex == -1 || (i == g_ComViewIndex && g_compare_view == "PREV_VERSION")) {
                        g_renderer = g_scene_objects[i].renderer;
                        g_scene = g_scene_objects[i].scene;
                        g_camera = g_scene_objects[i].scene.children[0];
                        for (const modules_info of g_pog_json[i].ModuleInfo) {
                            var k = 0;
                            for (const shelfs of modules_info.ShelfInfo) {
                                if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX") {
                                    var shelf_obj = g_scene_objects[i].scene.children[2].getObjectById(shelfs.SObjID);
                                    if (typeof shelfs.availableSpaceObjID !== "undefined" && shelfs.availableSpaceObjID !== -1) {
                                        var availableSpaceObjID = shelf_obj.getObjectById(shelfs.availableSpaceObjID);
                                        shelf_obj.remove(availableSpaceObjID);
                                    }
                                    modules_info.ShelfInfo[k].availableSpaceObjID = -1;
                                }
                                k++;
                            }
                        }
                        render(i);
                    }
                    if (g_all_pog_flag == "N") {
                        break;
                    } else {
                        i++;
                    }
                }
                g_renderer = g_scene_objects[originalCanvas].renderer;
                g_scene = g_scene_objects[originalCanvas].scene;
                g_camera = g_scene_objects[originalCanvas].scene.children[0];
            }
        }
        else {
            if (g_all_pog_flag == "N") {
                var i = p_pog_index;
            } else {
                var i = 0;
            }
            for (const pogInfo of g_pog_json) {
                if ((i !== g_ComViewIndex && g_ComViewIndex > -1) || g_ComViewIndex == -1) {
                    g_renderer = g_scene_objects[i].renderer;
                    g_scene = g_scene_objects[i].scene;
                    g_camera = g_scene_objects[i].scene.children[0];
                    for (const modules_info of g_pog_json[i].ModuleInfo) {
                        var k = 0;
                        for (const shelfs of modules_info.ShelfInfo) {
                            var shelf_obj = g_scene_objects[i].scene.children[2].getObjectById(shelfs.SObjID);
                            if (typeof shelf_obj !== "undefined" && shelfs.ObjType == "SHELF") {
                                var itemsSpace = 0;
                                if (typeof shelfs.ROverhang == "undefined" || shelfs.ROverhang == "") {
                                    //ASA-1237
                                    shelfs.ROverhang = 0;
                                }
                                if (typeof shelfs.LOverhang == "undefined" || shelfs.LOverhang == "") {
                                    //ASA-1237
                                    shelfs.LOverhang = 0;
                                }
                                if (g_lr_overhung == "Y") {
                                    var shelfWidth = shelfs.W + shelfs.ROverhang + shelfs.LOverhang; //ASA-1237
                                } else {
                                    var shelfWidth = shelfs.W;
                                }
                                var availableSpace = 0;
                                var j = 0;
                                for (const items of modules_info.ShelfInfo[k].ItemInfo) {
                                    if (typeof items.BottomObjID == "undefined" || items.BottomObjID == "") {
                                        if (shelfs.ObjType == "SHELF" || shelfs.ObjType == "HANGINGBAR") {
                                            itemsSpace += items.W;
                                        } else {
                                            itemsSpace += items.D;
                                        }
                                        j++;
                                    }
                                }
                                if (shelfs.ObjType == "SHELF" || shelfs.ObjType == "HANGINGBAR") {
                                    // 1902 Available space should be calculated
                                    if (shelfs.SpreadItem !== "E") {
                                        var horizGap = shelfs.HorizGap ? shelfs.HorizGap : 0;
                                        var horizGapSpace = (j > 1) ? horizGap * (j - 1) : 0;
                                        itemsSpace += horizGapSpace;
                                    }
                                    availableSpace = wpdSetFixed((shelfWidth - itemsSpace) * 100); //.toFixed(3));
                                } else {
                                    availableSpace = wpdSetFixed((shelfDepth - itemsSpace) * 100); //.toFixed(3));
                                }
                                //ASA-1970 Start
                                //ASA-1946
                                // if (shelfs.SpreadItem == "F" && shelfs.ItemInfo?.length == 1 && (shelfs.ObjType == "SHELF" || shelfs.ObjType == "HANGINGBAR")) {
                                //    	var itemWidth = shelfs.ItemInfo[0]?.CrushHoriz > 0 ? shelfs.ItemInfo[0]?.W : shelfs.ItemInfo[0]?.RW;  //ASA-1946 Issue1
                                // 	availableSpace = wpdSetFixed((shelfWidth - itemWidth) * 100);
                                // }
                                if (shelfs.SpreadItem == "F" && (shelfs.ObjType == "SHELF" || shelfs.ObjType == "HANGINGBAR")) {
                                    var itemWidth = 0;
                                    for (const item of shelfs.ItemInfo) {
                                        // itemWidth += item?.RW;
                                        itemWidth += item?.CrushHoriz > 0 ? item?.W : item?.RW;
                                    }
                                    availableSpace = wpdSetFixed((shelfWidth - itemWidth) * 100);
                                }
                                //ASA-1970 End
                                var shelfObj = g_scene_objects[i].scene.children[2].getObjectById(shelfs.SObjID);
                                if (availableSpace < 0) {
                                    //ASA-1237
                                    availableSpace = 0;
                                }
                                shelfObj.AvlSpace = availableSpace;
                            }
                            k++;
                        }
                    }
                    render(i);
                }
                if (g_all_pog_flag == "N") {
                    break;
                } else {
                    i++;
                }
            }

            g_renderer = g_scene_objects[originalCanvas].renderer;
            g_scene = g_scene_objects[originalCanvas].scene;
            g_camera = g_scene_objects[originalCanvas].scene.children[0];
        }
        logDebug("function : showFixelAvailableSpace", "E");
    } catch (err) {
        error_handling(err);
    }
}



async function updateDaysOfSupply(p_item, p_iIndex, p_sIndex, p_mIndex, p_carpark_ind, p_updatePogItemColl = "N", p_pog_index, p_pUpdateItemInfo = "N") {
    try {
        var daysOfSupply = 0;
        var i = 0;
        var RegMovement = nvl(p_item.RegMovement) == 0 ? 1 : nvl(p_item.RegMovement);
        var item_list = get_similar_items(p_item.ItemID, "I", p_pog_index, "Y");
        var itemInfo = [],
            itemInfoDets = [];
        for (items of item_list) {
            daysOfSupply = daysOfSupply + items.VertFacing * items.HorizFacing * items.DFacing;
        }
        var selectedObject = g_scene_objects[p_pog_index].scene.children[2].getObjectById(p_item.ObjID);
        if (nvl(selectedObject) !== 0 && nvl(p_item.RegMovement) !== 0 && p_item.RegMovement !== "0") {
            selectedObject.DaysOfSupply = parseFloat(daysOfSupply / RegMovement).toFixed(2);
            if (p_carpark_ind == "N") {
                g_pog_json[p_pog_index].ModuleInfo[p_mIndex].ShelfInfo[p_sIndex].ItemInfo[p_iIndex].DaysOfSupply = parseFloat(selectedObject.DaysOfSupply).toFixed(2);
            } else {
                g_pog_json[p_pog_index].ModuleInfo[p_mIndex].Carpark[0].ItemInfo[p_iIndex].DaysOfSupply = parseFloat(selectedObject.DaysOfSupply).toFixed(2);
            }
        } else if (nvl(selectedObject) !== 0) {
            selectedObject.DaysOfSupply = "";
            if (p_carpark_ind == "N") {
                selectedObject.DaysOfSupply = "0.00";
                g_pog_json[p_pog_index].ModuleInfo[p_mIndex].ShelfInfo[p_sIndex].ItemInfo[p_iIndex].DaysOfSupply = "0.00";
            } else {
                g_pog_json[p_pog_index].ModuleInfo[p_mIndex].Carpark[0].ItemInfo[p_iIndex].DaysOfSupply = "";
            }
        }
        if (p_carpark_ind == "N") {
            var iteminfo = g_pog_json[p_pog_index].ModuleInfo[p_mIndex].ShelfInfo[p_sIndex].ItemInfo[p_iIndex];
            if (p_updatePogItemColl == "Y") {
                itemInfo.push(g_pog_json[p_pog_index].ModuleInfo[p_mIndex].ShelfInfo[p_sIndex].ItemInfo[p_iIndex].ItemID);
                itemInfoDets.push(g_pog_json[p_pog_index].ModuleInfo[p_mIndex].ShelfInfo[p_sIndex].ItemInfo[p_iIndex].DaysOfSupply);
                await updatePOGItemInfoColl(itemInfo, itemInfoDets, p_pog_index);
            }
        } else {
            var iteminfo = g_pog_json[p_pog_index].ModuleInfo[p_mIndex].Carpark[0].ItemInfo[p_iIndex];
        }
        return iteminfo;
    } catch (err) {
        error_handling(err);
    }
}

function get_similar_items(p_description, p_type, p_pog_index, p_UpdateItemInfo = "N") {
    try {
        logDebug("function : get_similar_items; desc : " + p_description + "; p_type : " + p_type, "S");
        var items_list = [];
        if (p_UpdateItemInfo == "N") {
            if (g_pog_json.length > 0) {
                var l = 0;
                for (const pogs of g_pog_json) {
                    var k = 0;
                    for (const Modules of g_pog_json[l].ModuleInfo) {
                        if (Modules.ParentModule == null) {
                            if (typeof Modules.Carpark !== "undefined" && typeof Modules.Carpark[0] !== "undefined") {
                                if (Modules.Carpark[0].ItemInfo.length > 0) {
                                    var j = 0;
                                    for (const items of Modules.Carpark[0].ItemInfo) {
                                        if ((p_type == "I" && items.Item == p_description) || (p_type == "D" && nvl(items.Desc) != 0 && items.Desc.search(p_description) !== -1)) {
                                            //ASA-1606
                                            var selectedObject = g_scene_objects[l].scene.children[2].getObjectById(items.ObjID);
                                            if (typeof selectedObject !== "undefined") {
                                                items_list.push(selectedObject);
                                            }
                                        }
                                        j++;
                                    }
                                }
                            }
                            var i = 0;
                            for (const Shelf of Modules.ShelfInfo) {
                                if (Shelf.ObjType !== "BASE" && Shelf.ObjType !== "NOTCH" && Shelf.ObjType !== "DIVIDER" && Shelf.ObjType !== "TEXTBOX") {
                                    var j = 0;
                                    for (const items of Shelf.ItemInfo) {
                                        if ((p_type == "I" && items.Item == p_description) || (p_type == "D" && nvl(items.Desc) != 0 && items.Desc.search(p_description) !== -1)) {
                                            //ASA-1606
                                            var selectedObject = g_scene_objects[l].scene.children[2].getObjectById(items.ObjID);
                                            if (typeof selectedObject !== "undefined") {
                                                items_list.push(selectedObject);
                                            }
                                        }
                                        j++;
                                    }
                                }
                                i++;
                            }
                        }
                        k++;
                    }
                    l++;
                }
            }
        } else {
            var k = 0; //asa-1258
            for (const Modules of g_pog_json[p_pog_index].ModuleInfo) {
                if (Modules.ParentModule == null) {
                    if (typeof Modules.Carpark !== "undefined" && typeof Modules.Carpark[0] !== "undefined") {
                        if (Modules.Carpark[0].ItemInfo.length > 0) {
                            var j = 0;
                            for (const items of Modules.Carpark[0].ItemInfo) {
                                if ((p_type == "I" && items.Item == p_description) || (p_type == "D" && nvl(items.Desc) != 0 && items.Desc.search(p_description) !== -1)) {
                                    //ASA-1606
                                    var selectedObject = g_scene_objects[p_pog_index].scene.children[2].getObjectById(items.ObjID);
                                    if (typeof selectedObject !== "undefined") {
                                        items_list.push(selectedObject);
                                    }
                                }
                                j++;
                            }
                        }
                    }
                    var i = 0;
                    for (const Shelf of Modules.ShelfInfo) {
                        if (Shelf.ObjType !== "BASE" && Shelf.ObjType !== "NOTCH" && Shelf.ObjType !== "DIVIDER" && Shelf.ObjType !== "TEXTBOX") {
                            var j = 0;
                            for (const items of Shelf.ItemInfo) {
                                if ((p_type == "I" && items.Item == p_description) || (p_type == "D" && nvl(items.Desc) != 0 && items.Desc.search(p_description) !== -1)) {
                                    //ASA-1606
                                    var selectedObject = g_scene_objects[p_pog_index].scene.children[2].getObjectById(items.ObjID);
                                    if (typeof selectedObject !== "undefined") {
                                        items_list.push(selectedObject);
                                    }
                                }
                                j++;
                            }
                        }
                        i++;
                    }
                }
                k++;
            }
        }
        logDebug("function : get_similar_items", "E");
        return items_list;
    } catch (err) {
        error_handling(err);
    }
}
function get_orientation_list(p_orien_check) {
    if (p_orien_check == 1) {
        return [2, 8, 3];
    } else if (p_orien_check == 2) {
        return [1, 8, 3];
    } else if (p_orien_check == 3) {
        return [1, 2, 8];
    } else if (p_orien_check == 8) {
        return [1, 2, 3];
    }
}

//START ASA-1095
function getLabelPosition(p_Object, p_ObjectType, p_Position) {
    //pObjectType can be Module, Shelf or Item
    //pPosition can be Center, Left, Right, Top, Bottom
    p_Position = p_Position.toUpperCase();
    try {
        var posX, posY;
        if (p_ObjectType == "M") {
            posX = -1;
            posY = -1;
        } else if (p_ObjectType == "S") {
            if (p_Position == "CENTER") {
                posX = 0 - (p_Object.W / 4 + 0.01);
                if (p_Object.ObjType == "ROD") {
                    posY = 0.05;
                } else {
                    posY = -0.005;
                }
            } else if (p_Position == "TOP") {
                if (p_Object.ObjType == "HANGINGBAR") {
                    posX = 0 - (p_Object.W / 2.4 + 0.01);
                    posY = 0 - (p_Object.H / 2 + 0.012);
                } else if (p_Object.ObjType == "ROD") {
                    posX = 0 - (p_Object.W / 4 + 0.01);
                    posY = 0.05;
                } else {
                    posX = 0 - (p_Object.W / 2.4 + 0.01);
                    posY = 0 + (p_Object.H / 2 + 0.012);
                }
            } else if (p_Position == "LEFT") {
                if (p_Object.ObjType == "HANGINGBAR") {
                    posX = 0 - (p_Object.W / 2 + 0.08); //ASA-1296  ASA-1316 Task 1
                    posY = -0.005;
                } else if (p_Object.ObjType == "ROD") {
                    posX = 0 - (p_Object.W / 4 + 0.08); //ASA-1296 ASA-1316 Task 1
                    posY = 0.005;
                } else {
                    posX = 0 - (p_Object.W / 2 + 0.08); //ASA-1296 ASA-1316 Task 1
                    posY = -0.005;
                }
            } else if (p_Position == "RIGHT") {
                if (p_Object.ObjType == "HANGINGBAR") {
                    posX = 0 - (p_Object.W / 2 + 0.1);
                    posY = -0.005;
                } else if (p_Object.ObjType == "ROD") {
                    posX = 0 - (p_Object.W / 4 + 0.01);
                    posY = 0.05;
                } else {
                    posX = 0 + (p_Object.W / 2 + 0.1);
                    posY = -0.005;
                }
            } else if (p_Position == "BOTTOM") {
                if (p_Object.ObjType == "HANGINGBAR") {
                    posX = 0 - (p_Object.W / 2.4 + 0.01);
                    posY = 0 + (p_Object.H / 2 + 0.012);
                } else if (p_Object.ObjType == "ROD") {
                    posX = 0 - (p_Object.W / 4 + 0.01);
                    posY = 0.05;
                } else {
                    posX = 0 - (p_Object.W / 2.4 + 0.01);
                    posY = 0 - (p_Object.H / 2 + 0.012);
                }
            }
        } else if (p_ObjectType == "I") {
            posX = -1;
            posY = -1;
        }
        return [posX, posY];
    } catch (err) {
        error_handling(err);
    }
}

//END ASA-1095
function highlightProduct(p_object, p_linewidth, p_width, p_height, p_depth, p_z) {
    try {
        console.log("highlighting product", p_object);
        logDebug("function : add_wireframe; linewidth : " + p_linewidth, "S");
        var geometry = new THREE.BoxGeometry(p_width + 0.03, p_height + 0.05, 0);
        var geo = new THREE.EdgesGeometry(geometry);
        var mat = new THREE.LineBasicMaterial({
            color: 0xff0000,
            linewidth: 3,
        });
        var wireframe = new THREE.LineSegments(geo, mat);
         p_object.geometry.computeBoundingBox(); //ASA-2017 Issue 11,15,16
        wireframe.position.copy(p_object.geometry.boundingBox.getCenter(new THREE.Vector3()));
        wireframe.position.z += 0.01;
        wireframe.BorderColour = 0xff0000;
        wireframe.uuid = "highlight_frame";
        p_object.WireframeObj = wireframe;
        p_object.add(wireframe);
        p_object.WireframeObj = wireframe;
        logDebug("function : add_wireframe", "E");
        return wireframe.id;
    } catch (err) {
        error_handling(err);
    }
}



function render_blink_effect() {
    clearInterval(g_myVar);
    g_myVar = setInterval(function () {
        blink_effect_3d();
    }, 500);
}
var blink_color = 0xff0000,
    g_intersected = [];

function blink_effect_3d() {
    if (blink_color == 0xff0000) {
        blink_color = 0x00ffff;
    } else {
        blink_color = 0xff0000;
    }

    if (g_show_live_image == "Y") {
        for (var i = 0; i < g_intersected.length; i++) {
            if (typeof g_intersected[i] !== "undefined") {
                if (blink_color == 0x00ffff) {
                    g_intersected[i].WireframeObj.material.color.setHex(0xff0000);
                } else {
                    g_intersected[i].WireframeObj.material.color.setHex(0x00ffff);
                }
            }
        }
    } else {
        for (var i = 0; i < g_intersected.length; i++) {
            if (typeof g_intersected[i] !== "undefined") {
               
                if (blink_color == 0x00ffff) {
                    g_intersected[i].material.color.setHex(0xff0000);
                } else {
                    g_intersected[i].material.color.setHex(0x00ffff);
                }

                // Loop through children but EXCLUDE the highlight_frame
                if (g_intersected[i].children && g_intersected[i].children.length > 0) { // ASA2017
                    for (var j = 0; j < g_intersected[i].children.length; j++) {
                        var child = g_intersected[i].children[j];
                        if (child.material && 
                            child.uuid !== "highlight_frame" && 
                            child.uuid !== "wireframe" && child.type !== "Sprite" && child.type !== "LineSegments") {
                            
                            if (blink_color == 0x00ffff) {
                                child.material.color.setHex(0xff0000);
                            } else {
                                child.material.color.setHex(0x00ffff);
                            }
                        }
                    }
                }
            }
        }
    }  

    l_highlightStatus = $v("P25_POGCR_HIGHLIGHT_SEARCHED_ITEM"); //Regression Issue 1-20260119 
   
    if (l_highlightStatus == "Y" && g_pog_json.length > 1) {
        render_all_pog();
    } else {
        render(0);
    }
}

function get_json_data_json(p_pog_code, p_pog_version, p_pog_ind, p_pog_seq) {
    try {
        return new Promise(function (resolve, reject) {
            var p = apex.server.process(
                "GET_JSON_FROM_COLL",
                {
                    x01: p_pog_code,
                    x02: p_pog_version,
                    x03: p_pog_ind,
                    x04: p_pog_seq,
                },
                {
                    dataType: "html",
                }
            );
            // When the process is done, set the value to the page item
            p.done(function (data) {
                if ($.trim(data).indexOf("ERROR") == -1) {
                    g_pog_json_data = JSON.parse($.trim(data));
                    console.log("json", g_pog_json_data);
                    resolve("SUCESS");
                } else {
                    resolve($.trim(data));
                }
            });
        });
    } catch (err) {
        console.log("error 3", return_val);
        //error_handling(err);
    }
}

//Render is called on every object creation.
function render(p_pog_index) {
    logDebug("function : render", "S");
    try {
        if (typeof p_pog_index !== "undefined" && typeof g_scene_objects[p_pog_index] !== "undefined" && typeof g_canvas_objects[p_pog_index] !== "undefined") {
            if (g_scene_objects.length > 0) {
                var context = g_canvas_objects[p_pog_index].getContext("2d");
                if (context == null) {
                    if (g_renderer != undefined) g_renderer.render(g_scene, g_camera);
                } else {
                    g_renderer.setPixelRatio(window.devicePixelRatio);
                    var canvas_width = g_canvas_objects[p_pog_index].width;
                    var canvas_height = g_canvas_objects[p_pog_index].height;

                    g_renderer.setSize(canvas_width, canvas_height);
                    g_scene_objects[p_pog_index].scene.children[0].aspect = canvas_width / canvas_height;
                    g_renderer.render(g_scene_objects[p_pog_index].scene, g_scene_objects[p_pog_index].scene.children[0]);
                    context.drawImage(g_renderer.domElement, 0, 0, canvas_width, canvas_height);
                }
            }
        } else {
            if (g_renderer != undefined) g_renderer.render(g_scene, g_camera);
        }

        logDebug("function : render", "E");
    } catch (err) {
        error_handling(err);
    }
}

// ASA-1986  start
// function render(p_pog_index) {
//     logDebug("function : render", "S");
//     try {
//         if (typeof g_render_count === 'undefined') g_render_count = 0;
//         g_render_count++;
//         try { console.log('render:start', {count: g_render_count, p_pog_index: p_pog_index, scene_objects_len: g_scene_objects && g_scene_objects.length, canvas_objects_len: g_canvas_objects && g_canvas_objects.length, rendererDomId: g_renderer && g_renderer.domElement && g_renderer.domElement.id}); } catch(e){}

//         if (typeof p_pog_index !== "undefined" && typeof g_scene_objects[p_pog_index] !== "undefined" && typeof g_canvas_objects[p_pog_index] !== "undefined") {
//             if (g_scene_objects.length > 0) {
//                 var context = g_canvas_objects[p_pog_index].getContext("2d");
//                 if (context == null) {
//                     try{ console.log('render: branch=context==null -> rendering to main scene canvas id=', g_renderer && g_renderer.domElement && g_renderer.domElement.id); }catch(e){}
//                     if (g_renderer != undefined) g_renderer.render(g_scene, g_camera);
//                 } else {
//                     try{ console.log('render: branch=draw to 2d canvas; pog_index=', p_pog_index, 'canvas.width/height=', g_canvas_objects[p_pog_index].width, g_canvas_objects[p_pog_index].height); }catch(e){}
//                     g_renderer.setPixelRatio(window.devicePixelRatio);
//                     var canvas_width = g_canvas_objects[p_pog_index].width;
//                     var canvas_height = g_canvas_objects[p_pog_index].height;
//                     try{
//                         var before = g_renderer && g_renderer.info && g_renderer.info.render && g_renderer.info.render.calls;
//                         console.log('render: renderer.info.render.calls before=', before);
//                     }catch(e){}

//                     g_renderer.setSize(canvas_width, canvas_height);
//                     g_scene_objects[p_pog_index].scene.children[0].aspect = canvas_width / canvas_height;
//                     g_renderer.render(g_scene_objects[p_pog_index].scene, g_scene_objects[p_pog_index].scene.children[0]);
//                     try{ context.drawImage(g_renderer.domElement, 0, 0, canvas_width, canvas_height); }catch(e){ console.error('render: drawImage failed', e); }

//                     try{
//                         var after = g_renderer && g_renderer.info && g_renderer.info.render && g_renderer.info.render.calls;
//                         console.log('render: renderer.info.render.calls after=', after);
//                     }catch(e){}
//                     try{ var gl = g_renderer && g_renderer.getContext && g_renderer.getContext(); console.log('render: gl context present=', !!gl, gl && typeof gl.getError==='function' ? gl.getError() : null); }catch(e){}
//                 }
//             }
//         } else {
//             try{ console.log('render: fallback branch - rendering g_scene'); }catch(e){}
//             if (g_renderer != undefined) g_renderer.render(g_scene, g_camera);
//         }

//         try { console.log('render:end', {count: g_render_count, p_pog_index: p_pog_index}); } catch(e){}
//         logDebug("function : render", "E");
//     } catch (err) {
//         error_handling(err);
//     }
// }


//ASA-1986 end

//ASA-1095
function getTextColor(p_red, p_green, p_blue) {
    var darkColor = "#000000",
        lightColor = "#FFFFFF";
    var uicolors = [p_red / 255, p_green / 255, p_blue / 255];
    var c = uicolors.map((col) => {
        if (col <= 0.03928) {
            return col / 12.92;
        }
        return Math.pow((col + 0.055) / 1.055, 2.4);
    });
    var L = 0.2126 * c[0] + 0.7152 * c[1] + 0.0722 * c[2];
    return L > 0.179 ? darkColor : lightColor;
}

function get_type(p_description) {
    //ASA-1113
    if (p_description == "OwnLabel-Local") {
        return "W";
    } else if (p_description == "OwnLabel-IB") {
        return "W";
    } else if (p_description == "OwnLabel-OtherCountry") {
        return "W";
    } else if (p_description == "Exclusive-SupplieE") {
        return "E";
    } else if (p_description == "Exclusive-DistributorE") {
        return "E";
    } else if (p_description == "PrivateLabel-Local") {
        return "P";
    } else if (p_description == "PrivateLabel-IB") {
        return "P";
    } else if (p_description == "FRESHKON") {
        return "F";
    } else if (p_description == "Normal") {
        return "N";
    } else if (p_description == "A Brand") {
        return "A";
    }
}

async function auto_position_all(p_camera, p_pog_index, p_orgPogIndex, p_AutoPostionText, p_considerSubshelf) {
    logDebug("function : auto_position_all", "");
    try {
        if (typeof g_pog_json !== "undefined" && g_pog_json.length > 0) {
            //identify if any change in POG
            g_pog_edited_ind = "Y";

            var old_pogIndex = p_pog_index;
            var old_world = g_world;
            var old_camera = p_camera;

            if (g_all_pog_flag == "Y") {
                var z = 0;
            } else {
                var z = p_pog_index;
            }

            for (const pogJson of g_pog_json) {
                if ((z !== g_ComViewIndex && g_ComViewIndex > -1) || g_ComViewIndex == -1) {
                    if (typeof p_orgPogIndex == "undefined" && g_all_pog_flag == "N") {
                        p_orgPogIndex = p_pog_index;
                    } else if (g_all_pog_flag == "Y") {
                        p_orgPogIndex = z;
                    }
                    g_world = g_scene_objects[z].scene.children[2];
                    p_camera = g_scene_objects[z].scene.children[0];

                    module_details = g_pog_json[z].ModuleInfo;
                    i = 0;
                    var mod_detail_arr = [];
                    var mod_index_arr = [];
                    for (const modules of module_details) {
                        if ((typeof modules.ParentModule == "undefined" || modules.ParentModule == null) && modules.H > 0.1) {
                            var mod_details = {};
                            mod_details["ModStart"] = wpdSetFixed(modules.X - modules.W / 2);
                            mod_details["ModEnd"] = wpdSetFixed(modules.X + modules.W / 2);
                            mod_details["ModBottom"] = wpdSetFixed(modules.Y - modules.H / 2);
                            mod_details["ModTop"] = wpdSetFixed(modules.Y + modules.H / 2);
                            mod_details["ModX"] = modules.X;
                            mod_details["ModIndex"] = i;
                            mod_details["Module"] = modules.Module;
                            mod_details["ModWidth"] = modules.W;
                            mod_details["MObjID"] = modules.MObjID; //ASA-1628 Issue 10
                            mod_index_arr.push(mod_details);
                        }
                        i = i + 1;
                    }

                    //Undo details of auto position
                    g_cut_copy_arr = [];
                    for (const modules of mod_index_arr) {
                        var l_shelf_details = g_pog_json[z].ModuleInfo[modules.ModIndex].ShelfInfo;
                        var i = 0;
                        for (shelfs of l_shelf_details) {
                            if (shelfs.ObjType !== "TEXTBOX" && shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "ROD") {
                                var undoObjectsInfo = [];
                                undoObjectsInfo.moduleIndex = modules.ModIndex;
                                undoObjectsInfo.shelfIndex = i;
                                undoObjectsInfo.actionType = "SHELF_DRAG";
                                undoObjectsInfo.objectID = shelfs.SObjID;
                                undoObjectsInfo.push(JSON.parse(JSON.stringify(shelfs)));
                                undoObjectsInfo.moduleObjectID = modules.MObjID;
                                undoObjectsInfo.startCanvas = g_present_canvas;
                                undoObjectsInfo.g_present_canvas = g_present_canvas;
                                g_allUndoObjectsInfo.push(undoObjectsInfo);
                            }
                        }
                        i++;
                    }
                    g_delete_details.multi_delete_shelf_ind = "N";
                    logFinalUndoObjectsInfo("SHELF_DRAG", "U", g_allUndoObjectsInfo, "", "Y", "N", "N", "N", "N", "Y");
                    g_allUndoObjectsInfo = [];

                    i = 0;
                    for (const modules of mod_index_arr) {
                        var l_shelf_details = g_pog_json[z].ModuleInfo[modules.ModIndex].ShelfInfo;
                        var j = 0;
                        for (const shelfs of l_shelf_details) {
                            if (shelfs.ItemInfo.length > 0) {
                                update_item_distance(modules.ModIndex, j, z, "N"); //Bug-26122 - splitting the chest
                            }
                            if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "ROD" && (p_AutoPostionText == "N" || p_AutoPostionText == "Y")) {
                                var shelf_start = wpdSetFixed(shelfs.X - shelfs.W / 2);
                                var shelf_end = wpdSetFixed(shelfs.X + shelfs.W / 2);
                                var valid = "N";
                                if (((shelfs.X > modules.ModStart && shelfs.X <= modules.ModEnd) || (shelf_start >= modules.ModStart && shelf_start < modules.ModEnd) || (shelf_end > modules.ModStart && shelf_end < modules.ModEnd)) && shelfs.Y > modules.ModBottom && shelfs.Y < modules.ModTop) {
                                    valid = "Y";
                                } else if (shelfs.X > modules.ModStart && shelfs.X < modules.ModEnd && (shelfs.Y > modules.ModTop || shelfs.Y < modules.ModBottom)) {
                                    valid = "Y";
                                } else {
                                    g_pog_json[z].ModuleInfo[modules.ModIndex].ShelfInfo[j].ShelfChangeReq = "Y";
                                }
                                if (valid == "Y") {
                                    await set_item_xy(shelfs, modules.ModIndex, j, p_pog_index); //ASA-1659
                                    var [validity, new_shelfX, new_shelfY] = update_position_loc(shelfs, modules, j, modules.ModIndex, modules.ModIndex, p_camera, z, g_scene_objects[p_orgPogIndex].scene.children[2], p_considerSubshelf);
                                    g_pog_json[z].ModuleInfo[modules.ModIndex].ShelfInfo[j].ShelfChangeReq = "N";
                                }
                                //ASA-1628 Issue 3
                                if (shelfs.ObjType !== "TEXTBOX") {
                                    var [mod_ind, shelf_ind] = await set_shelf_after_drag(validity, "Y", modules.ModIndex, modules.ModIndex, j, g_pog_json[z].ModuleInfo[modules.ModIndex].ShelfInfo[j].X, g_pog_json[z].ModuleInfo[modules.ModIndex].ShelfInfo[j].Y, "N", "N", "", "", z, z, -1, "Y"); //ASA-1628 Issue 18, sending -1 as combine ind and Y for auto_position call. As we do not need to change or recalculate combination
                                }
                            }

                            j = j + 1;
                        }

                        i = i + 1;
                    }

                    i = 0;
                    for (const modules of mod_index_arr) {
                        var l = 0;
                        for (const modules_next of module_details) {
                            if ((typeof modules_next.ParentModule == "undefined" || modules_next.ParentModule == null) && modules_next.H > 0.1) {
                                var l_shelf_details = modules_next.ShelfInfo;
                                var j = 0;
                                for (const shelfs of l_shelf_details) {
                                    if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "ROD" && shelfs.ShelfChangeReq == "Y" && shelfs.ObjType !== "TEXTBOX") {
                                        var shelf_start = wpdSetFixed(shelfs.X - shelfs.W / 2);
                                        var shelf_end = wpdSetFixed(shelfs.X + shelfs.W / 2);
                                        var valid = "N";
                                        var m_ind = "",
                                            c_ind = "",
                                            s_ind = "";
                                        var mod_width = 0,
                                            mod_x = 0;

                                        if ((i !== l && shelf_start > modules.ModStart && shelf_start < modules.ModEnd) || (shelf_end > modules.ModStart && shelf_end < modules.ModEnd)) {
                                            valid = "Y";
                                            m_ind = l;
                                            c_ind = modules.ModIndex;
                                            s_ind = j;
                                            mod_width = modules.ModWidth;
                                            mod_x = modules.ModX;

                                            var [validity, new_shelfX, new_shelfY] = update_position_loc(shelfs, modules, j, modules.ModIndex, l, p_camera, z, g_scene_objects[p_orgPogIndex].scene.children[2], p_considerSubshelf);
                                            if (validity == "Y" || validity == "R") {
                                                mod_detail = {};
                                                mod_detail["MIndex"] = m_ind;
                                                mod_detail["CurrIndex"] = c_ind;
                                                mod_detail["SIndex"] = s_ind;
                                                mod_detail["X"] = new_shelfX;
                                                mod_detail["Y"] = new_shelfY; //ASA-1628 shelfs.Y;
                                                mod_detail["Shelf"] = shelfs.Shelf;
                                                mod_detail["ObjType"] = shelfs.ObjType;

                                                mod_detail_arr.push(mod_detail);
                                            }
                                        }
                                    }
                                    j = j + 1;
                                }
                            }
                            l = l + 1;
                        }
                        i = i + 1;
                    }
                    if (typeof mod_detail_arr == "undefined" && mod_detail_arr != null) {
                        i = 0;
                        for (const shelfs of mod_detail_arr) {
                            j = 0;
                            var new_m_ind = -1,
                                new_s_ind = -1;
                            var module_details = g_pog_json[z].ModuleInfo;
                            for (const modules_next of module_details) {
                                if ((typeof modules_next.ParentModule == "undefined" || modules_next.ParentModule == null) && modules_next.H > 0.1) {
                                    var l_shelf_details = modules_next.ShelfInfo;
                                    var k = 0;
                                    for (const shelf_d of l_shelf_details) {
                                        if (shelf_d.ObjType !== "BASE" && shelf_d.ObjType !== "NOTCH" && shelf_d.ObjType !== "DIVIDER" && shelf_d.ObjType !== "ROD") {
                                            if (shelf_d.Shelf == shelfs.Shelf) {
                                                new_m_ind = j;
                                                new_s_ind = k;
                                                break;
                                            }
                                        }
                                        k = k + 1;
                                    }
                                }
                                j = j + 1;
                            }
                            if (shelfs.ObjType !== "TEXTBOX") {
                                var [mod_ind, shelf_ind] = await set_shelf_after_drag("Y", "Y", new_m_ind, shelfs.CurrIndex, new_s_ind, shelfs.X, shelfs.Y, "Y", "N", "", "", z, z, -1, "Y"); //ASA-1628 issue 18
                            }
                            i = i + 1;
                        }
                    }
                    var details = get_min_max_xy(z);
                    var details_arr = details.split("###");
                    set_camera_z(p_camera, parseFloat(details_arr[2]), parseFloat(details_arr[3]), parseFloat(details_arr[0]), parseFloat(details_arr[1]), g_offset_z, parseFloat(details_arr[4]), parseFloat(details_arr[5]), true, z);
                    render(z);
                }
                if (g_all_pog_flag == "Y") {
                    z++;
                } else {
                    break;
                }
            }
            g_world = old_world;
            p_camera = old_camera;
            //   recreate the orientation view if any present
            async function recreate_view() {
                var returnval = await recreate_compare_views(g_compare_view, "N");
            }
            recreate_view();
        }
        logDebug("function : auto_position_all", "E");
    } catch (err) {
        error_handling(err);
    }
}



function get_closest_peg(p_item_height, p_module_index, p_shelf_index, p_final_y, p_pog_index) {
    logDebug("function : get_closest_peg; item_height : " + p_item_height + "; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index + "; p_final_y : " + p_final_y);
    var peg_verti_arr = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].peg_vert_values;
    var shelfyaxis = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].Y;
    var peg_details = [];
    $.each(peg_verti_arr, function (i, details) {
        peg_details.push(shelfyaxis + peg_verti_arr[i]);
    });
    var item_start = p_final_y + p_item_height / 2;
    if (peg_details.length > 0) {
        var closest = peg_details.reduce((a, b) => {
            return Math.abs(b - item_start) < Math.abs(a - item_start) ? b : a;
        });
    }
    logDebug("function : get_closest_peg", "E");
    return closest;
}

// function reorder_items(p_module_index, p_shelf_index, p_pog_index) {
// 	logDebug("function : reorder_items; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index, "S");
// 	try {
// 		var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
// 		var shelf_obj_type = shelfdtl.ObjType;
// 		var [currCombinationIndex, currShelfCombIndx] = [-1, -1];

// 		items_arr = JSON.parse(JSON.stringify(shelfdtl.ItemInfo));
// 		temp_item_arr = [];
// 		var spread_product = shelfdtl.SpreadItem;
// 		var spread_gap = shelfdtl.HorizGap;
// 		var shelf_top = wpdSetFixed(shelfdtl.Y + shelfdtl.H / 2); //.toFixed(3));
// 		var fixed_item_found = "N",
// 			item_found = "N",
// 			total_width = 0,
// 			item_cnt = 0,
// 			previous_fixed_item = -1;
// 		var shelf_width = shelfdtl.W;
// 		shelf_start = wpdSetFixed(shelfdtl.X - shelf_width / 2 - shelfdtl.LOverhang);
// 		shelf_end = wpdSetFixed(shelfdtl.X + shelf_width / 2 + shelfdtl.ROverhang);
// 		shelf_width = wpdSetFixed(shelfdtl.W + shelfdtl.LOverhang + shelfdtl.ROverhang);
// 		var fixed_gap = 0;
// 		var fixed_detail_arr = [];
// 		var normal_arr = [],
// 			x_arr = [],
// 			index_arr = [],
// 			be_exists = "N",
// 			prev_fixed = "N";
// 		var item_hit = "N";
// 		var hit_location,
// 			hit_shelf_ind = -1;

// 		//ASA-1129, Start
// 		var shelfCount = 0;

// 		if ((shelf_obj_type == "SHELF" || shelf_obj_type == "HANGINGBAR") && shelfdtl.Combine !== "N") {
// 			[currCombinationIndex, currShelfCombIndx] = getCombinationShelf(p_pog_index, shelfdtl.Shelf);
// 		}
// 		spread_product = currCombinationIndex !== -1 && currShelfCombIndx !== -1 ? g_combinedShelfs[currCombinationIndex].SpreadItem : spread_product;
// 		if (currCombinationIndex !== -1 && currShelfCombIndx !== -1 && (spread_product == "E" || spread_product == "F")) {
// 			var shelfCount = g_combinedShelfs[currCombinationIndex].length;
// 			var shelfIndx, modIndex;
// 			spread_gap = 0;
// 			shelf_width = 0;
// 			for (var s = 0; s < shelfCount; s++) {
// 				modIndex = g_combinedShelfs[currCombinationIndex][s].MIndex;
// 				shelfIndx = g_combinedShelfs[currCombinationIndex][s].SIndex;
// 				shelfdtl = g_pog_json[p_pog_index].ModuleInfo[modIndex].ShelfInfo[shelfIndx];
// 				shelf_width = shelf_width + shelfdtl.W + shelfdtl.LOverhang + shelfdtl.ROverhang;
// 				items_arr = shelfdtl.ItemInfo;

// 				for (const items of items_arr) {
// 					if (typeof items.BottomObjID == "undefined" || items.BottomObjID == "") {
// 						total_width = total_width + items.W;
// 						if (spread_product == "E") {
// 							item_cnt = item_cnt + 1;
// 						} else {
// 							item_cnt = item_cnt + items.BHoriz;
// 						}
// 					}
// 				}
// 			}
// 			var spread = 0;
// 			if (item_cnt > 1) {
// 				spread = (shelf_width - total_width) / (item_cnt - 1) <= 0 ? 0 : (shelf_width - total_width) / (item_cnt - 1);
// 			} else if (item_cnt !== 1) {
// 				spread = shelf_width - total_width < 0 ? 0 : shelf_width - total_width;
// 			}
// 			for (var s = 0; s < shelfCount; s++) {
// 				modIndex = g_combinedShelfs[currCombinationIndex][s].MIndex;
// 				shelfIndx = g_combinedShelfs[currCombinationIndex][s].SIndex;
// 				shelfdtl = g_pog_json[p_pog_index].ModuleInfo[modIndex].ShelfInfo[shelfIndx];
// 				items_arr = shelfdtl.ItemInfo;
// 				for (const items of items_arr) {
// 					items.SpreadItem = spread;
// 				}
// 			}
// 			//ASA-1129, End
// 		} else {
// 			if (shelfdtl.ItemInfo.length > 0 && shelf_obj_type !== "ROD" && shelf_obj_type !== "PEGBOARD" && !(shelf_obj_type == "CHEST" && g_chest_as_pegboard == "Y")) {
// 				//ASA-1327
// 				var i = 0;
// 				if (shelf_obj_type == "HANGINGBAR") {
// 					var i = 0;
// 					for (const items of shelfdtl.ItemInfo) {
// 						if (item_hit == "Y") {
// 							break;
// 						}
// 						var item_top = wpdSetFixed(items.Y + items.H / 2);
// 						var item_bottom = wpdSetFixed(items.Y - items.H / 2);
// 						var j = 0;
// 						for (const shelfs of g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo) {
// 							if (shelfs.ItemInfo.length > 0) {
// 								if (shelfs.ObjType == "HANGINGBAR" && j !== p_shelf_index && shelfs.Y < item_top && shelfs.Y > item_bottom) {
// 									item_hit = "Y";
// 									hit_location = "B";
// 									hit_shelf_ind = j;
// 									break;
// 								}
// 							}
// 							j++;
// 						}
// 						i++;
// 					}
// 					if (item_hit == "N") {
// 						var shelf_info = shelfdtl;
// 						var i = 0;
// 						for (const shelfs of g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo) {
// 							if (item_hit == "Y") {
// 								break;
// 							}
// 							if (shelfs.ObjType == "HANGINGBAR" && i !== p_shelf_index) {
// 								var j = 0;
// 								for (const items of shelfs.ItemInfo) {
// 									var item_top = wpdSetFixed(items.Y + items.H / 2);
// 									var item_top = wpdSetFixed(items.Y + items.H / 2);
// 									var item_bottom = items.Y - items.H / 2;
// 									if (shelf_info.Y < item_top && shelf_info.Y > item_bottom) {
// 										item_hit = "Y";
// 										hit_location = "T";
// 										hit_shelf_ind = i;
// 										break;
// 									}
// 									j++;
// 								}
// 							}
// 							i++;
// 						}
// 					}
// 				}
// 				if (item_hit == "N" || (item_hit == "Y" && hit_location == "B")) {
// 					if (spread_product == "E" || spread_product == "F" || spread_product == "L") {
// 						var fixedItemPresent = items_arr.some((items) => items.Fixed === "Y");
// 						if (fixedItemPresent && (shelf_obj_type == "HANGINGBAR" || shelf_obj_type == "SHELF")) {
// 							reorderShelfWithFixedItem(shelfdtl, shelf_start, shelf_end, spread_product, spread_gap, items_arr);
// 							// var i = 0;
// 							// for (const items of items_arr) {
// 							// 	if (items.Fixed == "Y") {
// 							// 		if (items.X - items.W / 2 < shelf_start) {
// 							// 			items.X = shelf_start + items.W / 2;
// 							// 		} else if (items.X + items.W / 2 > shelf_end) {
// 							// 			items.X = shelf_end - items.W / 2;
// 							// 		}
// 							// 		var fixed_detail = items;
// 							// 		var min_dis = 0;
// 							// 		var index = -1;
// 							// 		var total_width = 0;
// 							// 		var item_cnt = 0;
// 							// 		(x_arr = []), (index_arr = []);
// 							// 		fixed_detail["IIndex"] = i;
// 							// 		if (prev_fixed == "Y") {
// 							// 			var j = 0;
// 							// 			for (const fitems of items_arr) {
// 							// 				if (fitems.X < items.X && fitems.Fixed == "Y") {
// 							// 					x_arr.push(items.X - items.W / 2 - (fitems.X + fitems.W / 2));
// 							// 					index_arr.push(j);
// 							// 				}
// 							// 				j++;
// 							// 			}
// 							// 			min_dis = Math.min.apply(Math, x_arr);

// 							// 			if (min_dis !== 0) {
// 							// 				var index = x_arr.findIndex(function (number) {
// 							// 					return number == min_dis;
// 							// 				});
// 							// 				index = index_arr[index];
// 							// 			}
// 							// 		} else {
// 							// 			min_dis = items.X - items.W / 2 - shelf_start;
// 							// 		}
// 							// 		fixed_detail["TotalGap"] = min_dis;
// 							// 		fixed_detail_arr.push(fixed_detail);
// 							// 		prev_fixed = "Y";
// 							// 	} else {
// 							// 		items.IIndex = i;
// 							// 		items.NotFixed = "N";
// 							// 		normal_arr.push(items);
// 							// 	}
// 							// 	i++;
// 							// }

// 							// var max_fixed = -1;
// 							// if (fixed_detail_arr.length > 0) {
// 							// 	shelfdtl.ItemInfo.splice(0);
// 							// 	var item_end = 0;
// 							// 	var i = 0;
// 							// 	for (const fixed of fixed_detail_arr) {
// 							// 		if (fixed.Fixed == "Y") {
// 							// 			var next_fixed = "Y";
// 							// 			var j = 0;
// 							// 			for (const items of normal_arr) {
// 							// 				if (fixed.TotalGap > 0 && fixed.TotalGap >= items.W && items.NotFixed == "N") {
// 							// 					shelfdtl.ItemInfo.splice(fixed.IIndex, 0, items);
// 							// 					if (typeof items.BottomObjID === "undefined" || items.BottomObjID === "") {
// 							// 						//parseFloat((items.Y - items.H / 2).toFixed(4)) == shelf_top ////ASA-1247
// 							// 						fixed.TotalGap = fixed.TotalGap - items.W;
// 							// 					} else if (shelf_obj_type == "HANGINGBAR") {
// 							// 						//ASA-1237
// 							// 						fixed.TotalGap = fixed.TotalGap - items.W;
// 							// 					}
// 							// 					items.FixedIndex = fixed.IIndex;
// 							// 					normal_arr[j].NotFixed = "Y";
// 							// 				}
// 							// 				j++;
// 							// 			}
// 							// 			max_fixed = fixed.IIndex;
// 							// 			shelfdtl.ItemInfo.push(fixed);
// 							// 		}

// 							// 		i++;
// 							// 	}

// 							// 	var i = 0;
// 							// 	for (const items of normal_arr) {
// 							// 		if (items.NotFixed == "N") {
// 							// 			shelfdtl.ItemInfo.push(items);
// 							// 		}
// 							// 		i++;
// 							// 	}

// 							//     var sorto = {
// 							//         IIndex: "asc",
// 							//     };
// 							//     shelfdtl.ItemInfo.keySort(sorto);   //ASA-1677 #3

// 							// 	if (spread_product == "E" || spread_product == "F") {
// 							// 		var item_cnt = 0;
// 							// 		var item_gap = 0;
// 							// 		items_arr = shelfdtl.ItemInfo;
// 							// 		if (spread_product == "E" && spread_gap > 0) {
// 							// 			spread_gap = spread_gap;
// 							// 		}
// 							// 		var i = 0;
// 							// 		for (const fixed of fixed_detail_arr) {
// 							// 			item_cnt = 0;
// 							// 			var j = 0;
// 							// 			for (const items of items_arr) {
// 							// 				if ((fixed.IIndex == items.FixedIndex && (typeof items.BottomObjID === "undefined" || items.BottomObjID === "")) || shelf_obj_type == "HANGINGBAR") {
// 							// 					//parseFloat((items.Y - items.H / 2).toFixed(4)) == shelf_top ////ASA-1247
// 							// 					if (spread_product == "E") {
// 							// 						item_cnt = item_cnt + 1;
// 							// 					} else {
// 							// 						item_cnt = item_cnt + items.BHoriz;
// 							// 					}
// 							// 				}
// 							// 				j++;
// 							// 			}
// 							// 			var spread = fixed.TotalGap / item_cnt; //(item_cnt - 1) < 0 ? 0 : fixed.TotalGap / (item_cnt - 1);
// 							// 			var k = 0;
// 							// 			for (const items of items_arr) {
// 							// 				if (fixed.IIndex == items.FixedIndex) {
// 							// 					items.SpreadItem = spread;
// 							// 				}
// 							// 				k++;
// 							// 			}
// 							// 			i++;
// 							// 		}
// 							// 		max_x = -1;
// 							// 		max_index = -1;
// 							// 		lastgap = -1;
// 							// 		var i = 0;
// 							// 		for (const items of items_arr) {
// 							// 			if (items.Fixed == "Y") {
// 							// 				if (max_x < items.X) {
// 							// 					lastgap = shelf_end - (items.X + items.W / 2);
// 							// 					max_x = items.X;
// 							// 					max_index = i;
// 							// 				}
// 							// 			}
// 							// 			i++;
// 							// 		}
// 							// 		item_cnt = 0;
// 							// 		total_width = 0;
// 							// 		var i = 0;
// 							// 		for (const items of items_arr) {
// 							// 			if (i > max_index && wpdSetFixed(items.Y - items.H / 2) == shelf_top) {
// 							// 				if (spread_product == "E") {
// 							// 					item_cnt = item_cnt + 1;
// 							// 				} else {
// 							// 					item_cnt = item_cnt + items.BHoriz;
// 							// 				}
// 							// 				total_width += items.W;
// 							// 			}
// 							// 			i++;
// 							// 		}
// 							// 		total_width = lastgap - total_width;

// 							// 		item_cnt = item_cnt == 1 ? 2 : item_cnt;
// 							// 		if (item_cnt > 0) {
// 							// 			var spread = total_width / item_cnt < 0 ? 0 : total_width / item_cnt;
// 							// 			var i = 0;
// 							// 			for (const items of items_arr) {
// 							// 				if (i > max_index) {
// 							// 					items.SpreadItem = spread;
// 							// 				}
// 							// 				i++;
// 							// 			}
// 							// 		}
// 							// 	}
// 						} else if (spread_product == "E" || spread_product == "F") {
// 							var item_cnt = 0;
// 							items_arr = shelfdtl.ItemInfo;
// 							if (spread_product == "E" && spread_gap > 0) {
// 								spread_gap = spread_gap;
// 							}
// 							var j = 0;
// 							for (const items of items_arr) {
// 								//  if (parseFloat((items.Y - items.H / 2).toFixed(4)) == shelf_top || shelf_obj_type == "HANGINGBAR") { commented beacuse due to parseFloat((items.Y - items.H / 2).toFixed(4)) =1.10165 but it chnages the value to 1.1017 so it not goes inside if block
// 								if (typeof items.BottomObjID === "undefined" || items.BottomObjID === "" || shelf_obj_type === "HANGINGBAR") {
// 									if (items.BHoriz > 1 && spread_product == "F") {
// 										total_width += items.W + spread_gap * (items.BHoriz - 1);
// 									} else {
// 										total_width += items.W;
// 									}
// 									if (spread_product == "E") {
// 										item_cnt = item_cnt + 1;
// 									} else {
// 										item_cnt = item_cnt + items.BHoriz;
// 									}
// 								}
// 								j++;
// 							}
// 							if (item_cnt > 0) {
// 								var spread = wpdSetFixed((shelf_width - total_width) / (item_cnt - 1)) < 0 ? 0 : wpdSetFixed((shelf_width - total_width) / (item_cnt - 1));
// 							} else {
// 								var spread = wpdSetFixed(shelf_width - total_width) < 0 ? 0 : wpdSetFixed(shelf_width - total_width);
// 							}
// 							$.each(items_arr, function (i, items) {
// 								items.SpreadItem = wpdSetFixed(spread);
// 							});
// 						}
// 					} else if (spread_product == "R") {
// 						var fixedItemPresent = items_arr.some((items) => items.Fixed === "Y");
// 						if (fixedItemPresent && (shelf_obj_type == "HANGINGBAR" || shelf_obj_type == "SHELF")) {
// 							reorderShelfWithFixedItem(shelfdtl, shelf_start, shelf_end, spread_product, spread_gap, items_arr);
// 						} else {
// 							for (var i = items_arr.length - 1; i >= 0; i--) {
// 								items_arr[i].IIndex = i;
// 								items_arr[i].NotFixed = "N";
// 								normal_arr.push(items_arr[i]);
// 							}
// 							shelfdtl.ItemInfo.splice(0);
// 							var i = 0;
// 							for (const items of normal_arr) {
// 								if (items.NotFixed == "N") {
// 									shelfdtl.ItemInfo.splice(0, 0, items);
// 								}
// 								i++;
// 							}
// 						}
// 						// else {
// 						// for (var i = items_arr.length - 1; i >= 0; i--) {
// 						// 	if (items_arr[i].Fixed == "Y") {
// 						// 		if (items_arr[i].X - items_arr[i].W / 2 < shelf_start) {
// 						// 			items_arr[i].X = wpdSetFixed(shelf_start + items_arr[i].W / 2);
// 						// 		} else if (items_arr[i].X + items_arr[i].W / 2 > shelf_end) {
// 						// 			items_arr[i].X = wpdSetFixed(shelf_end - items_arr[i].W / 2);
// 						// 		}
// 						// 		var fixed_detail = items_arr[i];
// 						// 		var min_dis = 0;
// 						// 		var index = -1;
// 						// 		var total_width = 0;
// 						// 		var item_cnt = 0;
// 						// 		(x_arr = []), (index_arr = []);
// 						// 		fixed_detail["IIndex"] = i;
// 						// 		if (prev_fixed == "Y") {
// 						// 			$.each(items_arr, function (j, fitems) {
// 						// 				if (fitems.X > items_arr[i].X && fitems.Fixed == "Y") {
// 						// 					x_arr.push(fitems.X - fitems.W / 2 - (items_arr[i].X + items_arr[i].W / 2));
// 						// 					index_arr.push(j);
// 						// 				}
// 						// 			});

// 						// 			min_dis = Math.min.apply(Math, x_arr);

// 						// 			if (min_dis !== 0) {
// 						// 				var index = x_arr.findIndex(function (number) {
// 						// 					return number == min_dis;
// 						// 				});
// 						// 				index = index_arr[index];
// 						// 			}
// 						// 		} else {
// 						// 			min_dis = shelf_end - (items_arr[i].X + items_arr[i].W / 2);
// 						// 		}
// 						// 		fixed_detail["TotalGap"] = min_dis;
// 						// 		fixed_detail_arr.push(fixed_detail);
// 						// 		prev_fixed = "Y";
// 						// 	} else {
// 						// 		items_arr[i].IIndex = i;
// 						// 		items_arr[i].NotFixed = "N";
// 						// 		normal_arr.push(items_arr[i]);
// 						// 	}
// 						// }
// 						// shelfdtl.ItemInfo.splice(0);
// 						// $.each(fixed_detail_arr, function (i, fixed) {
// 						// 	if (fixed.Fixed == "Y") {
// 						// 		var next_fixed = "Y";
// 						// 		shelfdtl.ItemInfo.splice(0, 0, fixed);
// 						// 		if (next_fixed == "B") {
// 						// 			var j = 0;
// 						// 			for (const items of normal_arr) {
// 						// 				if (fixed.TotalGap > 0 && fixed.TotalGap >= items.W && items.NotFixed == "N" && items.X > fixed_detail_arr[i + 1].X) {
// 						// 					shelfdtl.ItemInfo.splice(1, 0, items);
// 						// 					if (typeof items.BottomObjID === "undefined" || items.BottomObjID === "") {
// 						// 						//parseFloat((items.Y - items.H / 2).toFixed(4)) == shelf_top ////ASA-1247
// 						// 						fixed.TotalGap = fixed.TotalGap - items.W;
// 						// 					} else if (shelf_obj_type == "HANGINGBAR") {
// 						// 						//ASA-1237
// 						// 						fixed.TotalGap = fixed.TotalGap - items.W;
// 						// 					}
// 						// 					items.FixedIndex = fixed.IIndex;
// 						// 					items.NotFixed = "Y";
// 						// 				}
// 						// 				j++;
// 						// 			}
// 						// 		} else {
// 						// 			var j = 0;
// 						// 			for (const items of normal_arr) {
// 						// 				if (fixed.TotalGap > 0 && fixed.TotalGap >= items.W && items.NotFixed == "N") {
// 						// 					shelfdtl.ItemInfo.splice(1, 0, items);
// 						// 					if (typeof items.BottomObjID === "undefined" || items.BottomObjID === "") {
// 						// 						//parseFloat((items.Y - items.H / 2).toFixed(4)) == shelf_top ////ASA-1247
// 						// 						fixed.TotalGap = fixed.TotalGap - items.W;
// 						// 					}
// 						// 					items.FixedIndex = fixed.IIndex;
// 						// 					items.NotFixed = "Y";
// 						// 				}
// 						// 				j++;
// 						// 			}
// 						// 		}
// 						// 		max_fixed = fixed.IIndex;
// 						// 		//shelfdtl.ItemInfo.push(fixed);
// 						// 	}
// 						// });
// 						// var i = 0;
// 						// for (const items of normal_arr) {
// 						// 	if (items.NotFixed == "N") {
// 						// 		shelfdtl.ItemInfo.splice(0, 0, items);
// 						// 	}
// 						// 	i++;
// 						// }
// 					}
// 				} else {
// 					var shelfs = shelfdtl;
// 					var shelf_start = shelfs.X - shelfs.W / 2;
// 					var minx = 100;
// 					var i = 0;
// 					for (const items of g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[hit_shelf_ind].ItemInfo) {
// 						var item_top = wpdSetFixed(items.Y + items.H / 2);
// 						var item_bottom = wpdSetFixed(items.Y - items.H / 2);
// 						if (shelfs.Y < item_top && shelfs.Y > item_bottom) {
// 							minx = Math.min(minx, items.X - items.W / 2);
// 						}
// 						i++;
// 					}
// 					var shelf_width = minx - shelf_start;

// 					if (spread_product == "E" || spread_product == "F") {
// 						var item_cnt = 0;
// 						items_arr = shelfdtl.ItemInfo;
// 						if (spread_product == "E" && spread_gap > 0) {
// 							spread_gap = spread_gap;
// 						}
// 						var j = 0;
// 						for (const items of items_arr) {
// 							//  if (parseFloat((items.Y - items.H / 2).toFixed(4)) == shelf_top || shelf_obj_type == "HANGINGBAR") { commented beacuse due to parseFloat((items.Y - items.H / 2).toFixed(4)) =1.10165 but it chnages the value to 1.1017 so it not goes inside if block
// 							if (typeof items.BottomObjID === "undefined" || items.BottomObjID === "" || shelf_obj_type === "HANGINGBAR") {
// 								if (items.BHoriz > 1 && spread_product == "F") {
// 									total_width += items.W + spread_gap * (items.BHoriz - 1);
// 								} else {
// 									total_width += items.W;
// 								}
// 								if (spread_product == "E") {
// 									item_cnt = item_cnt + 1;
// 								} else {
// 									item_cnt = item_cnt + items.BHoriz;
// 								}
// 							}
// 							j++;
// 						}
// 						if (item_cnt > 0) {
// 							var spread = wpdSetFixed((shelf_width - total_width) / (item_cnt - 1)) < 0 ? 0 : wpdSetFixed((shelf_width - total_width) / (item_cnt - 1));
// 						} else {
// 							var spread = wpdSetFixed(shelf_width - total_width) < 0 ? 0 : wpdSetFixed(shelf_width - total_width);
// 						}
// 						$.each(items_arr, function (i, items) {
// 							items.SpreadItem = spread;
// 						});
// 					} else if (spread_product == "R") {
// 						items_arr = shelfdtl.ItemInfo;
// 						var i = 0;
// 						for (const iten_arr of items_arr) {
// 							items.ShelfEnd = minx;
// 							i++;
// 						}
// 					}
// 				}
// 			}
// 		}
// 		logDebug("function : reorder_items", "E");
// 		return true;
// 	} catch (err) {
// 		error_handling(err);
// 	}
// }


function reorder_items(p_module_index, p_shelf_index, p_pog_index) {
    logDebug("function : reorder_items; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index, "S");
    try {
        var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
        var shelf_obj_type = shelfdtl.ObjType;
        var [currCombinationIndex, currShelfCombIndx] = [-1, -1];

        items_arr = JSON.parse(JSON.stringify(shelfdtl.ItemInfo));
        items_arr.forEach(it => it.SpreadItem = 0);

        temp_item_arr = [];
        var spread_product = shelfdtl.SpreadItem;
        var spread_gap = shelfdtl.HorizGap;
        var shelf_top = wpdSetFixed(shelfdtl.Y + shelfdtl.H / 2); //.toFixed(3));
        var fixed_item_found = "N",
            item_found = "N",
            total_width = 0,
            item_cnt = 0,
            previous_fixed_item = -1;
        var shelf_width = shelfdtl.W;
        shelf_start = wpdSetFixed(shelfdtl.X - shelf_width / 2 - shelfdtl.LOverhang);
        shelf_end = wpdSetFixed(shelfdtl.X + shelf_width / 2 + shelfdtl.ROverhang);
        shelf_width = wpdSetFixed(shelfdtl.W + shelfdtl.LOverhang + shelfdtl.ROverhang);
        var fixed_gap = 0;
        var fixed_detail_arr = [];
        var normal_arr = [],
            x_arr = [],
            index_arr = [],
            be_exists = "N",
            prev_fixed = "N";
        var item_hit = "N";
        var hit_location,
            hit_shelf_ind = -1;

        //ASA-1129, Start
        var shelfCount = 0;

        if ((shelf_obj_type == "SHELF" || shelf_obj_type == "HANGINGBAR") && shelfdtl.Combine !== "N") {
            [currCombinationIndex, currShelfCombIndx] = getCombinationShelf(p_pog_index, shelfdtl.Shelf);
        }
        spread_product = currCombinationIndex !== -1 && currShelfCombIndx !== -1 ? g_combinedShelfs[currCombinationIndex].SpreadItem : spread_product;
        if (currCombinationIndex !== -1 && currShelfCombIndx !== -1 && (spread_product == "E" || spread_product == "F")) {
            var shelfCount = g_combinedShelfs[currCombinationIndex].length;
            var shelfIndx, modIndex;
            spread_gap = 0;
            shelf_width = 0;
            for (var s = 0; s < shelfCount; s++) {
                modIndex = g_combinedShelfs[currCombinationIndex][s].MIndex;
                shelfIndx = g_combinedShelfs[currCombinationIndex][s].SIndex;
                shelfdtl = g_pog_json[p_pog_index].ModuleInfo[modIndex].ShelfInfo[shelfIndx];
                shelf_width = shelf_width + shelfdtl.W + shelfdtl.LOverhang + shelfdtl.ROverhang;
                items_arr = shelfdtl.ItemInfo;

                for (const items of items_arr) {
                    if (typeof items.BottomObjID == "undefined" || items.BottomObjID == "") {
                        total_width = total_width + items.W;
                        if (spread_product == "E") {
                            item_cnt = item_cnt + 1;
                        } else {
                            item_cnt = item_cnt + items.BHoriz;
                        }
                    }
                }
            }
            var spread = 0;
            if (item_cnt > 1) {
                spread = (shelf_width - total_width) / (item_cnt - 1) <= 0 ? 0 : (shelf_width - total_width) / (item_cnt - 1);
            } else if (item_cnt !== 1) {
                spread = shelf_width - total_width < 0 ? 0 : shelf_width - total_width;
            }
            for (var s = 0; s < shelfCount; s++) {
                modIndex = g_combinedShelfs[currCombinationIndex][s].MIndex;
                shelfIndx = g_combinedShelfs[currCombinationIndex][s].SIndex;
                shelfdtl = g_pog_json[p_pog_index].ModuleInfo[modIndex].ShelfInfo[shelfIndx];
                items_arr = shelfdtl.ItemInfo;
                for (const items of items_arr) {
                    items.SpreadItem = spread;
                }
            }
            //ASA-1129, End
        } else {
            if (shelfdtl.ItemInfo.length > 0 && shelf_obj_type !== "ROD" && shelf_obj_type !== "PEGBOARD" && !(shelf_obj_type == "CHEST" && g_chest_as_pegboard == "Y")) {
                //ASA-1327
                var i = 0;
                if (shelf_obj_type == "HANGINGBAR") {
                    var i = 0;
                    for (const items of shelfdtl.ItemInfo) {
                        if (item_hit == "Y") {
                            break;
                        }
                        var item_top = wpdSetFixed(items.Y + items.H / 2);
                        var item_bottom = wpdSetFixed(items.Y - items.H / 2);
                        var j = 0;
                        for (const shelfs of g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo) {
                            if (shelfs.ItemInfo.length > 0) {
                                if (shelfs.ObjType == "HANGINGBAR" && j !== p_shelf_index && shelfs.Y < item_top && shelfs.Y > item_bottom) {
                                    item_hit = "Y";
                                    hit_location = "B";
                                    hit_shelf_ind = j;
                                    break;
                                }
                            }
                            j++;
                        }
                        i++;
                    }
                    if (item_hit == "N") {
                        var shelf_info = shelfdtl;
                        var i = 0;
                        for (const shelfs of g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo) {
                            if (item_hit == "Y") {
                                break;
                            }
                            if (shelfs.ObjType == "HANGINGBAR" && i !== p_shelf_index) {
                                var j = 0;
                                for (const items of shelfs.ItemInfo) {
                                    var item_top = wpdSetFixed(items.Y + items.H / 2);
                                    var item_top = wpdSetFixed(items.Y + items.H / 2);
                                    var item_bottom = items.Y - items.H / 2;
                                    if (shelf_info.Y < item_top && shelf_info.Y > item_bottom) {
                                        item_hit = "Y";
                                        hit_location = "T";
                                        hit_shelf_ind = i;
                                        break;
                                    }
                                    j++;
                                }
                            }
                            i++;
                        }
                    }
                }
                if (item_hit == "N" || (item_hit == "Y" && hit_location == "B")) {
                    if (spread_product == "E" || spread_product == "F" || spread_product == "L") {
                        var fixedItemPresent = items_arr.some((items) => items.Fixed === "Y");
                        if (fixedItemPresent && (shelf_obj_type == "HANGINGBAR" || shelf_obj_type == "SHELF")) {
                            reorderShelfWithFixedItem(shelfdtl, shelf_start, shelf_end, spread_product, spread_gap, items_arr);
                            // var i = 0;
                            // for (const items of items_arr) {
                            // 	if (items.Fixed == "Y") {
                            // 		if (items.X - items.W / 2 < shelf_start) {
                            // 			items.X = shelf_start + items.W / 2;
                            // 		} else if (items.X + items.W / 2 > shelf_end) {
                            // 			items.X = shelf_end - items.W / 2;
                            // 		}
                            // 		var fixed_detail = items;
                            // 		var min_dis = 0;
                            // 		var index = -1;
                            // 		var total_width = 0;
                            // 		var item_cnt = 0;
                            // 		(x_arr = []), (index_arr = []);
                            // 		fixed_detail["IIndex"] = i;
                            // 		if (prev_fixed == "Y") {
                            // 			var j = 0;
                            // 			for (const fitems of items_arr) {
                            // 				if (fitems.X < items.X && fitems.Fixed == "Y") {
                            // 					x_arr.push(items.X - items.W / 2 - (fitems.X + fitems.W / 2));
                            // 					index_arr.push(j);
                            // 				}
                            // 				j++;
                            // 			}
                            // 			min_dis = Math.min.apply(Math, x_arr);

                            // 			if (min_dis !== 0) {
                            // 				var index = x_arr.findIndex(function (number) {
                            // 					return number == min_dis;
                            // 				});
                            // 				index = index_arr[index];
                            // 			}
                            // 		} else {
                            // 			min_dis = items.X - items.W / 2 - shelf_start;
                            // 		}
                            // 		fixed_detail["TotalGap"] = min_dis;
                            // 		fixed_detail_arr.push(fixed_detail);
                            // 		prev_fixed = "Y";
                            // 	} else {
                            // 		items.IIndex = i;
                            // 		items.NotFixed = "N";
                            // 		normal_arr.push(items);
                            // 	}
                            // 	i++;
                            // }

                            // var max_fixed = -1;
                            // if (fixed_detail_arr.length > 0) {
                            // 	shelfdtl.ItemInfo.splice(0);
                            // 	var item_end = 0;
                            // 	var i = 0;
                            // 	for (const fixed of fixed_detail_arr) {
                            // 		if (fixed.Fixed == "Y") {
                            // 			var next_fixed = "Y";
                            // 			var j = 0;
                            // 			for (const items of normal_arr) {
                            // 				if (fixed.TotalGap > 0 && fixed.TotalGap >= items.W && items.NotFixed == "N") {
                            // 					shelfdtl.ItemInfo.splice(fixed.IIndex, 0, items);
                            // 					if (typeof items.BottomObjID === "undefined" || items.BottomObjID === "") {
                            // 						//parseFloat((items.Y - items.H / 2).toFixed(4)) == shelf_top ////ASA-1247
                            // 						fixed.TotalGap = fixed.TotalGap - items.W;
                            // 					} else if (shelf_obj_type == "HANGINGBAR") {
                            // 						//ASA-1237
                            // 						fixed.TotalGap = fixed.TotalGap - items.W;
                            // 					}
                            // 					items.FixedIndex = fixed.IIndex;
                            // 					normal_arr[j].NotFixed = "Y";
                            // 				}
                            // 				j++;
                            // 			}
                            // 			max_fixed = fixed.IIndex;
                            // 			shelfdtl.ItemInfo.push(fixed);
                            // 		}

                            // 		i++;
                            // 	}

                            // 	var i = 0;
                            // 	for (const items of normal_arr) {
                            // 		if (items.NotFixed == "N") {
                            // 			shelfdtl.ItemInfo.push(items);
                            // 		}
                            // 		i++;
                            // 	}

                            //     var sorto = {
                            //         IIndex: "asc",
                            //     };
                            //     shelfdtl.ItemInfo.keySort(sorto);   //ASA-1677 #3

                            // 	if (spread_product == "E" || spread_product == "F") {
                            // 		var item_cnt = 0;
                            // 		var item_gap = 0;
                            // 		items_arr = shelfdtl.ItemInfo;
                            // 		if (spread_product == "E" && spread_gap > 0) {
                            // 			spread_gap = spread_gap;
                            // 		}
                            // 		var i = 0;
                            // 		for (const fixed of fixed_detail_arr) {
                            // 			item_cnt = 0;
                            // 			var j = 0;
                            // 			for (const items of items_arr) {
                            // 				if ((fixed.IIndex == items.FixedIndex && (typeof items.BottomObjID === "undefined" || items.BottomObjID === "")) || shelf_obj_type == "HANGINGBAR") {
                            // 					//parseFloat((items.Y - items.H / 2).toFixed(4)) == shelf_top ////ASA-1247
                            // 					if (spread_product == "E") {
                            // 						item_cnt = item_cnt + 1;
                            // 					} else {
                            // 						item_cnt = item_cnt + items.BHoriz;
                            // 					}
                            // 				}
                            // 				j++;
                            // 			}
                            // 			var spread = fixed.TotalGap / item_cnt; //(item_cnt - 1) < 0 ? 0 : fixed.TotalGap / (item_cnt - 1);
                            // 			var k = 0;
                            // 			for (const items of items_arr) {
                            // 				if (fixed.IIndex == items.FixedIndex) {
                            // 					items.SpreadItem = spread;
                            // 				}
                            // 				k++;
                            // 			}
                            // 			i++;
                            // 		}
                            // 		max_x = -1;
                            // 		max_index = -1;
                            // 		lastgap = -1;
                            // 		var i = 0;
                            // 		for (const items of items_arr) {
                            // 			if (items.Fixed == "Y") {
                            // 				if (max_x < items.X) {
                            // 					lastgap = shelf_end - (items.X + items.W / 2);
                            // 					max_x = items.X;
                            // 					max_index = i;
                            // 				}
                            // 			}
                            // 			i++;
                            // 		}
                            // 		item_cnt = 0;
                            // 		total_width = 0;
                            // 		var i = 0;
                            // 		for (const items of items_arr) {
                            // 			if (i > max_index && wpdSetFixed(items.Y - items.H / 2) == shelf_top) {
                            // 				if (spread_product == "E") {
                            // 					item_cnt = item_cnt + 1;
                            // 				} else {
                            // 					item_cnt = item_cnt + items.BHoriz;
                            // 				}
                            // 				total_width += items.W;
                            // 			}
                            // 			i++;
                            // 		}
                            // 		total_width = lastgap - total_width;

                            // 		item_cnt = item_cnt == 1 ? 2 : item_cnt;
                            // 		if (item_cnt > 0) {
                            // 			var spread = total_width / item_cnt < 0 ? 0 : total_width / item_cnt;
                            // 			var i = 0;
                            // 			for (const items of items_arr) {
                            // 				if (i > max_index) {
                            // 					items.SpreadItem = spread;
                            // 				}
                            // 				i++;
                            // 			}
                            // 		}
                            // 	}
                        } else if (spread_product == "E" || spread_product == "F") {
                            var item_cnt = 0;
                            items_arr = shelfdtl.ItemInfo;
                            if (spread_product == "E" && spread_gap > 0) {
                                spread_gap = spread_gap;
                            }
                            var j = 0;
                            for (const items of items_arr) {
                                //  if (parseFloat((items.Y - items.H / 2).toFixed(4)) == shelf_top || shelf_obj_type == "HANGINGBAR") { commented beacuse due to parseFloat((items.Y - items.H / 2).toFixed(4)) =1.10165 but it chnages the value to 1.1017 so it not goes inside if block
                                if (typeof items.BottomObjID === "undefined" || items.BottomObjID === "" || shelf_obj_type === "HANGINGBAR") {
                                    if (items.BHoriz > 1 && spread_product == "F") {
                                        //ASA-1970 Start
                                        // total_width += items.W + spread_gap * (items.BHoriz - 1);
                                        total_width += items.CrushHoriz > 0 ? items.W : items.RW;
                                        // total_width += items.RW;
                                        //ASA-1970 End
                                    } else {
                                        total_width += items.W;
                                    }
                                    if (spread_product == "E") {
                                        item_cnt = item_cnt + 1;
                                    } else {
                                        item_cnt = item_cnt + items.BHoriz;
                                    }
                                }
                                j++;
                            }
                            if (item_cnt > 0) {
                                var spread = wpdSetFixed((shelf_width - total_width) / (item_cnt - 1)) < 0 ? 0 : wpdSetFixed((shelf_width - total_width) / (item_cnt - 1));
                            } else {
                                var spread = wpdSetFixed(shelf_width - total_width) < 0 ? 0 : wpdSetFixed(shelf_width - total_width);
                            }
                            $.each(items_arr, function (i, items) {
                                items.SpreadItem = wpdSetFixed(spread);
                            });
                        }
                    } else if (spread_product == "R") {
                        var fixedItemPresent = items_arr.some((items) => items.Fixed === "Y");
                        if (fixedItemPresent && (shelf_obj_type == "HANGINGBAR" || shelf_obj_type == "SHELF")) {
                            reorderShelfWithFixedItem(shelfdtl, shelf_start, shelf_end, spread_product, spread_gap, items_arr);
                        } else {
                            for (var i = items_arr.length - 1; i >= 0; i--) {
                                items_arr[i].IIndex = i;
                                items_arr[i].NotFixed = "N";
                                normal_arr.push(items_arr[i]);
                            }
                            shelfdtl.ItemInfo.splice(0);
                            var i = 0;
                            for (const items of normal_arr) {
                                if (items.NotFixed == "N") {
                                    shelfdtl.ItemInfo.splice(0, 0, items);
                                }
                                i++;
                            }
                        }
                        // else {
                        // for (var i = items_arr.length - 1; i >= 0; i--) {
                        // 	if (items_arr[i].Fixed == "Y") {
                        // 		if (items_arr[i].X - items_arr[i].W / 2 < shelf_start) {
                        // 			items_arr[i].X = wpdSetFixed(shelf_start + items_arr[i].W / 2);
                        // 		} else if (items_arr[i].X + items_arr[i].W / 2 > shelf_end) {
                        // 			items_arr[i].X = wpdSetFixed(shelf_end - items_arr[i].W / 2);
                        // 		}
                        // 		var fixed_detail = items_arr[i];
                        // 		var min_dis = 0;
                        // 		var index = -1;
                        // 		var total_width = 0;
                        // 		var item_cnt = 0;
                        // 		(x_arr = []), (index_arr = []);
                        // 		fixed_detail["IIndex"] = i;
                        // 		if (prev_fixed == "Y") {
                        // 			$.each(items_arr, function (j, fitems) {
                        // 				if (fitems.X > items_arr[i].X && fitems.Fixed == "Y") {
                        // 					x_arr.push(fitems.X - fitems.W / 2 - (items_arr[i].X + items_arr[i].W / 2));
                        // 					index_arr.push(j);
                        // 				}
                        // 			});

                        // 			min_dis = Math.min.apply(Math, x_arr);

                        // 			if (min_dis !== 0) {
                        // 				var index = x_arr.findIndex(function (number) {
                        // 					return number == min_dis;
                        // 				});
                        // 				index = index_arr[index];
                        // 			}
                        // 		} else {
                        // 			min_dis = shelf_end - (items_arr[i].X + items_arr[i].W / 2);
                        // 		}
                        // 		fixed_detail["TotalGap"] = min_dis;
                        // 		fixed_detail_arr.push(fixed_detail);
                        // 		prev_fixed = "Y";
                        // 	} else {
                        // 		items_arr[i].IIndex = i;
                        // 		items_arr[i].NotFixed = "N";
                        // 		normal_arr.push(items_arr[i]);
                        // 	}
                        // }
                        // shelfdtl.ItemInfo.splice(0);
                        // $.each(fixed_detail_arr, function (i, fixed) {
                        // 	if (fixed.Fixed == "Y") {
                        // 		var next_fixed = "Y";
                        // 		shelfdtl.ItemInfo.splice(0, 0, fixed);
                        // 		if (next_fixed == "B") {
                        // 			var j = 0;
                        // 			for (const items of normal_arr) {
                        // 				if (fixed.TotalGap > 0 && fixed.TotalGap >= items.W && items.NotFixed == "N" && items.X > fixed_detail_arr[i + 1].X) {
                        // 					shelfdtl.ItemInfo.splice(1, 0, items);
                        // 					if (typeof items.BottomObjID === "undefined" || items.BottomObjID === "") {
                        // 						//parseFloat((items.Y - items.H / 2).toFixed(4)) == shelf_top ////ASA-1247
                        // 						fixed.TotalGap = fixed.TotalGap - items.W;
                        // 					} else if (shelf_obj_type == "HANGINGBAR") {
                        // 						//ASA-1237
                        // 						fixed.TotalGap = fixed.TotalGap - items.W;
                        // 					}
                        // 					items.FixedIndex = fixed.IIndex;
                        // 					items.NotFixed = "Y";
                        // 				}
                        // 				j++;
                        // 			}
                        // 		} else {
                        // 			var j = 0;
                        // 			for (const items of normal_arr) {
                        // 				if (fixed.TotalGap > 0 && fixed.TotalGap >= items.W && items.NotFixed == "N") {
                        // 					shelfdtl.ItemInfo.splice(1, 0, items);
                        // 					if (typeof items.BottomObjID === "undefined" || items.BottomObjID === "") {
                        // 						//parseFloat((items.Y - items.H / 2).toFixed(4)) == shelf_top ////ASA-1247
                        // 						fixed.TotalGap = fixed.TotalGap - items.W;
                        // 					}
                        // 					items.FixedIndex = fixed.IIndex;
                        // 					items.NotFixed = "Y";
                        // 				}
                        // 				j++;
                        // 			}
                        // 		}
                        // 		max_fixed = fixed.IIndex;
                        // 		//shelfdtl.ItemInfo.push(fixed);
                        // 	}
                        // });
                        // var i = 0;
                        // for (const items of normal_arr) {
                        // 	if (items.NotFixed == "N") {
                        // 		shelfdtl.ItemInfo.splice(0, 0, items);
                        // 	}
                        // 	i++;
                        // }
                    }
                } else {
                    var shelfs = shelfdtl;
                    var shelf_start = shelfs.X - shelfs.W / 2;
                    var minx = 100;
                    var i = 0;
                    for (const items of g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[hit_shelf_ind].ItemInfo) {
                        var item_top = wpdSetFixed(items.Y + items.H / 2);
                        var item_bottom = wpdSetFixed(items.Y - items.H / 2);
                        if (shelfs.Y < item_top && shelfs.Y > item_bottom) {
                            minx = Math.min(minx, items.X - items.W / 2);
                        }
                        i++;
                    }
                    var shelf_width = minx - shelf_start;

                    if (spread_product == "E" || spread_product == "F") {
                        var item_cnt = 0;
                        items_arr = shelfdtl.ItemInfo;
                        if (spread_product == "E" && spread_gap > 0) {
                            spread_gap = spread_gap;
                        }
                        var j = 0;
                        for (const items of items_arr) {
                            //  if (parseFloat((items.Y - items.H / 2).toFixed(4)) == shelf_top || shelf_obj_type == "HANGINGBAR") { commented beacuse due to parseFloat((items.Y - items.H / 2).toFixed(4)) =1.10165 but it chnages the value to 1.1017 so it not goes inside if block
                            if (typeof items.BottomObjID === "undefined" || items.BottomObjID === "" || shelf_obj_type === "HANGINGBAR") {
                                if (items.BHoriz > 1 && spread_product == "F") {
                                    total_width += items.W + spread_gap * (items.BHoriz - 1);
                                } else {
                                    total_width += items.W;
                                }
                                if (spread_product == "E") {
                                    item_cnt = item_cnt + 1;
                                } else {
                                    item_cnt = item_cnt + items.BHoriz;
                                }
                            }
                            j++;
                        }
                        if (item_cnt > 0) {
                            var spread = wpdSetFixed((shelf_width - total_width) / (item_cnt - 1)) < 0 ? 0 : wpdSetFixed((shelf_width - total_width) / (item_cnt - 1));
                        } else {
                            var spread = wpdSetFixed(shelf_width - total_width) < 0 ? 0 : wpdSetFixed(shelf_width - total_width);
                        }
                        $.each(items_arr, function (i, items) {
                            items.SpreadItem = spread;
                        });
                    } else if (spread_product == "R") {
                        items_arr = shelfdtl.ItemInfo;
                        var i = 0;
                        for (const iten_arr of items_arr) {
                            items.ShelfEnd = minx;
                            i++;
                        }
                    }
                }
            }
        }
        logDebug("function : reorder_items", "E");
        return true;
    } catch (err) {
        error_handling(err);
    }
}

function get_item_xaxis(p_width, p_height, p_depth, p_shelf_obj_type, p_locationX, p_horiz_gap, p_spread_product, p_spread_gap, p_module_index, p_shelf_index, p_item_index, p_edit_ind, p_item_length, p_shelf_edit, p_pog_index, p_itemInsidePeg = "Y", p_item_paste = "N") { //ASA-1927 Issue1
    logDebug("function : get_item_xaxis; width : " + p_width + "; height : " + p_height + "; depth : " + p_depth + "; shelf_obj_type : " + p_shelf_obj_type + "; locationX : " + p_locationX + "; horiz_gap : " + p_horiz_gap + "; spread_product : " + p_spread_product + "; spread_gap : " + p_spread_gap + "; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index + "; i_item_index : " + p_item_index + "; p_edit_ind : " + p_edit_ind + "; item_length : " + p_item_length + "; shelf_edit : " + p_shelf_edit, "S");
    try {
        g_invalidPosition = "N";
        var finalX = 0;
        var spread_valid = ["SHELF", "HANGINGBAR"];
        var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
        var item_fixed = shelfdtl.ItemInfo[p_item_index].Fixed;
        var basket_spread = shelfdtl.BsktSpreadProduct;
        var basket_fill = shelfdtl.BsktFill;
        // var item_cnt = shelfdtl.ItemInfo.length;
        var shelf_width = shelfdtl.W;
        var shelf_height = shelfdtl.H;
        var shelf_depth = shelfdtl.D;
        var shelfY = shelfdtl.Y;
        // var item_bottom = parseFloat((shelfdtl.ItemInfo[p_item_index].Y - shelfdtl.ItemInfo[p_item_index].H / 2).toFixed(3));
        var bottom_objid = shelfdtl.ItemInfo[p_item_index].BottomObjID;
        // var shelf_top = parseFloat((shelfY + shelf_height / 2).toFixed(4));
        var items_arr = shelfdtl.ItemInfo;
        var shelf_start = shelfdtl.X - shelfdtl.W / 2;
        // var itemCnt = items_arr.length;
        var shelfCount = 1,
            [currCombinationIndex, currShelfCombIndx] = [-1, -1];
        var checkShelf = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
        var newObjID = shelfdtl.ItemInfo[p_item_index].BottomObjID; //ASA-1540 #2
        if ((checkShelf.ObjType == "SHELF" || checkShelf.ObjType == "HANGINGBAR") && checkShelf.Combine !== "N") {
            [currCombinationIndex, currShelfCombIndx] = getCombinationShelf(p_pog_index, checkShelf.Shelf);
            if (currCombinationIndex !== -1 && currShelfCombIndx !== -1) {
                shelfCount = g_combinedShelfs[currCombinationIndex].length;
            }
        }

        if (shelfCount > 1) {
            const combineStart = g_combinedShelfs[currCombinationIndex].Start;
            const combineEnd = g_combinedShelfs[currCombinationIndex].End;

            var prevItem,
                prevItemW = 0,
                prevItemX = 0,
                prevItemS = 0,
                prevItemE = 0;
            prevItem = getLastItemCombinedShelf(g_combinedShelfs[currCombinationIndex], p_spread_product, shelfdtl.ItemInfo[p_item_index].ObjID);
            if (!$.isEmptyObject(prevItem)) {
                prevItemX = prevItem.X;
                prevItemW = prevItem.W;
                prevItemS = prevItem.X - prevItem.W / 2;
                prevItemE = prevItem.X + prevItem.W / 2;
            }
            if (p_spread_product == "R") {
                if (prevItemS !== 0) {
                    finalX = prevItemS - shelfdtl.ItemInfo[p_item_index].W / 2;
                } else {
                    finalX = combineEnd - shelfdtl.ItemInfo[p_item_index].W / 2;
                }
            } else if (p_spread_product == "L") {
                if (prevItemE !== 0) {
                    finalX = prevItemE + shelfdtl.ItemInfo[p_item_index].W / 2;
                } else {
                    finalX = combineStart + shelfdtl.ItemInfo[p_item_index].W / 2;
                }
            } else if (p_spread_product == "E" || p_spread_product == "F") {
                if (p_spread_product == "F" && shelfdtl.ItemInfo[p_item_index].BHoriz > 1 && shelfdtl.ItemInfo[p_item_index].CrushHoriz == 0) {
                    shelfdtl.ItemInfo[p_item_index].W = shelfdtl.ItemInfo[p_item_index].RW /*(shelfdtl.ItemInfo[i_item_index].OW * shelfdtl.ItemInfo[i_item_index].BHoriz)*/ + shelfdtl.ItemInfo[p_item_index].SpreadItem * (shelfdtl.ItemInfo[p_item_index].BHoriz - 1);
                } else if (p_spread_product == "E" && shelfdtl.ItemInfo[p_item_index].BHoriz > 1 && p_horiz_gap > 0 && shelfdtl.ItemInfo[p_item_index].CrushHoriz == 0) {
                    shelfdtl.ItemInfo[p_item_index].W = shelfdtl.ItemInfo[p_item_index].RW /*(shelfdtl.ItemInfo[i_item_index].OW * shelfdtl.ItemInfo[i_item_index].BHoriz)*/ + p_horiz_gap * (shelfdtl.ItemInfo[p_item_index].BHoriz - 1);
                }
                if (prevItemE !== 0) {
                    finalX = prevItemE + shelfdtl.ItemInfo[p_item_index].W / 2 + shelfdtl.ItemInfo[p_item_index].SpreadItem;
                } else {
                    finalX = combineStart + shelfdtl.ItemInfo[p_item_index].W / 2;
                }
            } else if (p_spread_product == "M") {
                //ASA-1129
                finalX = shelfdtl.ItemInfo[p_item_index].X;
            }
        } else {
            if (p_shelf_edit == "Y") {
                finalX = shelfdtl.ItemInfo[p_item_index].X;
            } else {
                if (spread_valid.indexOf(p_shelf_obj_type) !== -1) {
                    if (p_spread_product == "R") {
                        var objID = shelfdtl.ItemInfo[p_item_index].ObjID;
                        var currX = shelfdtl.ItemInfo[p_item_index].X;
                        var itemFixed = shelfdtl.ItemInfo[p_item_index].Fixed;
                        if (p_item_index == shelfdtl.ItemInfo.length - 1) {
                            if (item_fixed == "N" || item_fixed == "B") {
                                var max_index = -1;
                                if (typeof bottom_objid !== "undefined" && bottom_objid !== "") {
                                    // var newObjID = shelfdtl.ItemInfo[p_item_index].ObjID; //ASA-1540 #2
                                    finalX = shelfdtl.ItemInfo[get_shelf_item_ind(p_module_index, p_shelf_index, bottom_objid, p_pog_index)].X;
                                } else {
                                    if (p_shelf_obj_type == "HANGINGBAR" && typeof shelfdtl.ItemInfo[p_item_index].ShelfEnd !== "undefined") {
                                        var shelf_end = shelfdtl.ItemInfo[p_item_index].ShelfEnd;
                                    } else {
                                        var shelf_end = shelfdtl.X + shelfdtl.W / 2;
                                    }
                                    finalX = shelf_end - p_width / 2 + shelfdtl.ROverhang;
                                }
                            } else {
                                finalX = shelfdtl.ItemInfo[p_item_index].X;
                            }
                        } else {
                            if (item_fixed == "N" || item_fixed == "B") {
                                var max_index = -1;
                                if (typeof bottom_objid !== "undefined" && bottom_objid !== "") {
                                    // var newObjID = shelfdtl.ItemInfo[p_item_index].ObjID; //ASA-1540 #2
                                    finalX = shelfdtl.ItemInfo[get_shelf_item_ind(p_module_index, p_shelf_index, bottom_objid, p_pog_index)].X;
                                } else {
                                    if (p_shelf_obj_type == "SHELF") {
                                        var i = 0;
                                        for (const items of items_arr) {
                                            if (i > p_item_index && (typeof items.BottomObjID == "undefined" || items.BottomObjID == "")) {
                                                //parseFloat((items.Y - items.H / 2).toFixed(4)) == shelf_top) {
                                                if (max_index !== -1) {
                                                    max_index = Math.min(max_index, i);
                                                } else {
                                                    max_index = i;
                                                }
                                            }
                                            i++;
                                        }
                                    } else {
                                        max_index = p_item_index + 1;
                                    }
                                    if (max_index == -1) {
                                        if (p_shelf_obj_type == "HANGINGBAR" && typeof shelfdtl.ItemInfo[p_item_index].ShelfEnd !== "undefined") {
                                            var shelf_end = shelfdtl.ItemInfo[p_item_index].ShelfEnd;
                                        } else {
                                            var shelf_end = shelfdtl.X + shelfdtl.W / 2;
                                        }
                                        finalX = shelf_end - p_width / 2 + shelfdtl.ROverhang;
                                    } else {
                                        finalX = shelfdtl.ItemInfo[max_index].X - shelfdtl.ItemInfo[max_index].W / 2 - parseFloat(p_width) / 2 - p_spread_gap;
                                    }
                                }
                            } else {
                                finalX = shelfdtl.ItemInfo[p_item_index].X;
                            }
                        }
                        if (g_isBookend == "B" && objID == g_movedObjID) {
                            finalX = shelfdtl.ItemInfo[p_item_index].X;
                            var itemEnd = shelfdtl.ItemInfo[p_item_index].X + shelfdtl.ItemInfo[p_item_index].W / 2;
                            if (p_item_index < shelfdtl.ItemInfo.length - 1) {
                                var prevItemStart = shelfdtl.ItemInfo[p_item_index + 1].X - shelfdtl.ItemInfo[p_item_index + 1].W / 2;
                                if (itemEnd > prevItemStart) {
                                    finalX = prevItemStart - p_width / 2;
                                }
                            }
                        }
                        if (finalX > currX && itemFixed == "B") {
                            finalX = shelfdtl.ItemInfo[p_item_index].X;
                        }
                        if (finalX + p_width / 2 > shelfEnd && g_validationFlag == "Y" && g_overhung_shelf_active == "N") {
                            //ASA-1300 Regression issue 12
                            g_invalidPosition = "Y";
                        } else {
                            g_validationFlag = "Y";
                        }
                    } else if (p_spread_product == "L") {
                        var max_index = -1;
                        var shelfEnd = shelfdtl.X + shelfdtl.W / 2;
                        var objID = shelfdtl.ItemInfo[p_item_index].ObjID;
                        var itemFixed = shelfdtl.ItemInfo[p_item_index].Fixed;
                        var currX = shelfdtl.ItemInfo[p_item_index].X;
                        if (p_item_index > 0) {
                            if (item_fixed == "N" || item_fixed == "B") {
                                var max_index = -1;
                                if (typeof bottom_objid !== "undefined" && bottom_objid !== "") {
                                    // var newObjID = shelfdtl.ItemInfo[p_item_index].ObjID; //ASA-1540 #2
                                    finalX = shelfdtl.ItemInfo[get_shelf_item_ind(p_module_index, p_shelf_index, newObjID, p_pog_index)].X;
                                }
                                if (typeof bottom_objid == "undefined" || bottom_objid == "") {
                                    if (p_shelf_obj_type == "SHELF") {
                                        $.each(items_arr, function (i, items) {
                                            if (i < p_item_index && (typeof items.BottomObjID == "undefined" || items.BottomObjID == "")) {
                                                //parseFloat((items.Y - items.H / 2).toFixed(4)) == shelf_top) {
                                                max_index = Math.max(max_index, i);
                                            }
                                        });
                                    } else {
                                        max_index = p_item_index - 1;
                                    }
                                    if (max_index == -1) {
                                        finalX = shelf_start + parseFloat(p_width) / 2 - shelfdtl.LOverhang;
                                    } else {
                                        finalX = shelfdtl.ItemInfo[max_index].X + shelfdtl.ItemInfo[max_index].W / 2 + parseFloat(p_width) / 2 + p_spread_gap;
                                    }
                                }
                            } else {
                                finalX = shelfdtl.ItemInfo[p_item_index].X;
                            }
                        } else {
                            if (item_fixed == "N" || item_fixed == "B") {
                                var max_index = -1;
                                if (typeof bottom_objid !== "undefined" && bottom_objid !== "") {
                                    // var newObjID = shelfdtl.ItemInfo[p_item_index].ObjID; //ASA-1540 #2
                                    finalX = shelfdtl.ItemInfo[get_shelf_item_ind(p_module_index, p_shelf_index, newObjID, p_pog_index)].X;
                                } else {
                                    finalX = shelf_start + parseFloat(p_width) / 2 - shelfdtl.LOverhang;
                                }
                            } else {
                                finalX = shelfdtl.ItemInfo[p_item_index].X;
                            }
                        }
                        if (g_isBookend == "B" && objID == g_movedObjID) {
                            finalX = shelfdtl.ItemInfo[p_item_index].X;
                            var itemStart = shelfdtl.ItemInfo[p_item_index].X - shelfdtl.ItemInfo[p_item_index].W / 2;
                            if (p_item_index > 0) {
                                var prevItemEnd = shelfdtl.ItemInfo[p_item_index - 1].X + shelfdtl.ItemInfo[p_item_index - 1].W / 2;
                                if (itemStart < prevItemEnd) {
                                    finalX = prevItemEnd + p_width / 2;
                                }
                            }
                        }
                        if (finalX < currX && itemFixed == "B") {
                            finalX = shelfdtl.ItemInfo[p_item_index].X;
                        }
                        if (finalX + p_width / 2 > shelfEnd && g_validationFlag == "Y" && g_overhung_shelf_active == "N") {
                            //ASA-1300 Regression issue 12
                            g_invalidPosition = "Y";
                        } else {
                            g_validationFlag = "Y";
                        }
                    } else if (p_spread_product == "E" || p_spread_product == "F") {
                        if (p_spread_product == "F" && shelfdtl.ItemInfo[p_item_index].BHoriz > 1 && shelfdtl.ItemInfo[p_item_index].CrushHoriz == 0) {
                            shelfdtl.ItemInfo[p_item_index].W = shelfdtl.ItemInfo[p_item_index].RW /*(shelfdtl.ItemInfo[i_item_index].OW * shelfdtl.ItemInfo[i_item_index].BHoriz)*/ + shelfdtl.ItemInfo[p_item_index].SpreadItem * (shelfdtl.ItemInfo[p_item_index].BHoriz - 1);
                        } else if (p_spread_product == "E" && shelfdtl.ItemInfo[p_item_index].BHoriz > 1 && p_horiz_gap > 0 && shelfdtl.ItemInfo[p_item_index].CrushHoriz == 0) {
                            shelfdtl.ItemInfo[p_item_index].W = shelfdtl.ItemInfo[p_item_index].RW /*(shelfdtl.ItemInfo[i_item_index].OW * shelfdtl.ItemInfo[i_item_index].BHoriz)*/ + p_horiz_gap * (shelfdtl.ItemInfo[p_item_index].BHoriz - 1);
                        }
                        if (p_item_index > 0) {
                            if (item_fixed == "N" || item_fixed == "B") {
                                var max_index = -1;
                                if (typeof bottom_objid !== "undefined" && bottom_objid !== "") {
                                    // var newObjID = shelfdtl.ItemInfo[p_item_index].ObjID; //ASA-1540 #2
                                    finalX = shelfdtl.ItemInfo[get_shelf_item_ind(p_module_index, p_shelf_index, newObjID, p_pog_index)].X;
                                } else {
                                    if (p_shelf_obj_type == "SHELF") {
                                        var i = 0;
                                        for (const items of items_arr) {
                                            if (i < p_item_index && (typeof items.BottomObjID == "undefined" || items.BottomObjID == "")) {
                                                //parseFloat((items.Y - items.H / 2).toFixed(4)) == shelf_top) {
                                                max_index = Math.max(max_index, i);
                                            }
                                            i++;
                                        }
                                    } else {
                                        max_index = p_item_index - 1;
                                    }
                                    if (max_index == -1) {
                                        finalX = shelf_start + shelfdtl.ItemInfo[p_item_index].W / 2 - shelfdtl.LOverhang;
                                    } else {
                                        //ASA-1970 Start
                                        var item = shelfdtl.ItemInfo[p_item_index];
                                        var max = shelfdtl.ItemInfo[max_index];
                                        var crushItem = item.CrushHoriz > 0 ? item.RW * (1 - item.CrushHoriz / 100) + item.SpreadItem * (item.BHoriz - 1) : item.W;
                                        var crushMax = max.CrushHoriz > 0 ? max.RW * (1 - max.CrushHoriz / 100) + max.SpreadItem * (max.BHoriz - 1) : max.W;
                                        
                                        if (p_spread_product == "F") {
                                            finalX = wpdSetFixed(max.X + crushMax / 2 + crushItem / 2 + item.SpreadItem);
                                        } else {
                                            finalX = wpdSetFixed(max.X + max.W / 2 + item.W / 2 + item.SpreadItem);
                                        }
                                        
                                        // ASA-1659
                                        if (p_item_index == shelfdtl.ItemInfo.length - 1 && g_overhung_shelf_active == "N") {
                                            const shelfEnd = wpdSetFixed(shelfdtl.X + shelfdtl.W / 2 + shelfdtl.ROverhang);
                                            if (wpdSetFixed(finalX + crushItem / 2) > shelfEnd) {
                                                finalX = shelfEnd - crushItem / 2;
                                                if (!(p_item_paste === "Y" && p_shelf_obj_type === "HANGINGBAR")) { //ASA-1927 Issue1
                                                    item.SpreadItem = wpdSetFixed(finalX - crushItem / 2 - (max.X + crushMax / 2));
                                                }
                                            }
                                        }
                                        // finalX = shelfdtl.ItemInfo[max_index].X + shelfdtl.ItemInfo[max_index].W / 2 + shelfdtl.ItemInfo[p_item_index].W / 2 + shelfdtl.ItemInfo[p_item_index].SpreadItem;
                                        // //ASA-1659
                                        // if (p_item_index == shelfdtl.ItemInfo.length - 1 && g_overhung_shelf_active == "N") {
                                        //     var shelfEnd = wpdSetFixed(shelfdtl.X + shelfdtl.W / 2 + shelfdtl.ROverhang);
                                        //     if (wpdSetFixed(finalX + shelfdtl.ItemInfo[p_item_index].W / 2) > shelfEnd) {
                                        //         finalX = shelfEnd - shelfdtl.ItemInfo[p_item_index].W / 2;
                                        //         if (!(p_item_paste === "Y" && p_shelf_obj_type === "HANGINGBAR")) { //ASA-1927 Issue1
                                        //             shelfdtl.ItemInfo[p_item_index].SpreadItem = wpdSetFixed(finalX - shelfdtl.ItemInfo[p_item_index].W / 2 - (shelfdtl.ItemInfo[max_index].X + shelfdtl.ItemInfo[max_index].W / 2));
                                        //         }
                                        //     }
                                        // }
                                        //ASA-1970 End
                                    }
                                }
                            } else {
                                finalX = shelfdtl.ItemInfo[p_item_index].X;
                            }
                        } else {
                            //ASA-1138
                            var overhungW = 0,
                                overhung = false;
                            //  if (typeof shelfdtl.Overhung !== "undefined" && shelfdtl.Overhung == "Y") {
                            for (const item of shelfdtl.ItemInfo) {
                                overhungW = wpdSetFixed(overhungW + item.W);
                            }
                            if (overhungW > wpdSetFixed(shelfdtl.W + shelfdtl.ROverhang + shelfdtl.LOverhang)) {
                                overhung = true;
                            }
                            //  }
                            if (p_item_index == 0 && overhung) {
                                finalX = wpdSetFixed(shelfdtl.ItemInfo[p_item_index].W / 2 + (shelfdtl.X - overhungW / 2) - shelfdtl.LOverhang);//ASA-1791 added overhung handling
                            } else if (item_fixed == "N" || item_fixed == "B") {
                                var max_index = -1;
                                if (typeof bottom_objid !== "undefined" && bottom_objid !== "") {
                                    // var newObjID = shelfdtl.ItemInfo[p_item_index].ObjID; //ASA-1540 #2
                                    finalX = shelfdtl.ItemInfo[get_shelf_item_ind(p_module_index, p_shelf_index, bottom_objid, p_pog_index)].X;
                                } else {
                                    //ASA-1970 Start
                                    if (shelfdtl.ItemInfo[p_item_index].CrushHoriz > 0 && shelfdtl.ItemInfo[p_item_index].BHoriz > 1 && p_spread_product == "F") {
                                        var fWidth = shelfdtl.ItemInfo[p_item_index].RW * (1 - shelfdtl.ItemInfo[p_item_index].CrushHoriz / 100) + shelfdtl.ItemInfo[p_item_index].SpreadItem * (shelfdtl.ItemInfo[p_item_index].BHoriz - 1);
                                    } else {
                                        var fWidth = shelfdtl.ItemInfo[p_item_index].W
                                    }
                                    //ASA-1970 End
                                    finalX = wpdSetFixed(shelf_start + fWidth / 2 - shelfdtl.LOverhang);//ASA-1791 added overhung handling
                                }
                            } else {
                                finalX = shelfdtl.ItemInfo[p_item_index].X;
                            }
                        }
                    } else if (p_spread_product == "M") {
                        //ASA-1129
                        finalX = shelfdtl.ItemInfo[p_item_index].X;
                    }
                } else {
                    if (p_shelf_obj_type == "BASKET") {
                        var max_merch = get_max_merch(p_module_index, p_shelf_index, p_item_index, "N", p_locationX, p_pog_index);
                        var item_qty = shelfdtl.ItemInfo[p_item_index].Quantity;
                        if (shelfdtl.ItemInfo[p_item_index].Item !== "DIVIDER") {
                            //ASA-1085
                            if (basket_spread == "LR") {
                                if (basket_fill == "T" || basket_fill == "M") {
                                    shelfdtl.ItemInfo[p_item_index].W = shelfdtl.ItemInfo[p_item_index].D * item_qty;
                                    shelfdtl.ItemInfo[p_item_index].H = max_merch;
                                } else if (basket_fill == "F") {
                                    var quantity = get_basket_fill_count(p_module_index, p_shelf_index, basket_spread, basket_fill, shelf_width, max_merch, shelf_depth, p_pog_index);
                                    shelfdtl.ItemInfo[p_item_index].W = shelfdtl.ItemInfo[p_item_index].D * quantity;
                                    shelfdtl.ItemInfo[p_item_index].H = max_merch;
                                    shelfdtl.ItemInfo[p_item_index].Quantity = quantity;
                                }
                                if (p_item_index == 0) {
                                    finalX = shelf_start + parseFloat(shelfdtl.ItemInfo[p_item_index].W) / 2;
                                    shelfdtl.ItemInfo[p_item_index].Y = shelfY + shelf_height / 2 + shelfdtl.ItemInfo[p_item_index].H / 2;
                                } else {
                                    var prevItem = shelfdtl.ItemInfo[p_item_index - 1].Item;
                                    var newIndex = p_item_index - 1;
                                    var itemStart = shelf_start;
                                    if (prevItem == "DIVIDER") {
                                        //ASA-1085
                                        if (typeof shelfdtl.ItemInfo[p_item_index - 2] !== "undefined") {
                                            newIndex = p_item_index - 2;
                                            itemStart = shelfdtl.ItemInfo[newIndex].X + shelfdtl.ItemInfo[newIndex].W / 2;
                                        }
                                    } else {
                                        itemStart = shelfdtl.ItemInfo[newIndex].X + shelfdtl.ItemInfo[newIndex].W / 2;
                                    }

                                    finalX = itemStart + parseFloat(shelfdtl.ItemInfo[p_item_index].W) / 2;
                                    shelfdtl.ItemInfo[p_item_index].Y = shelfY + shelf_height / 2 + shelfdtl.ItemInfo[p_item_index].H / 2;
                                }
                            } else if (basket_spread == "BT") {
                                if (basket_fill == "T") {
                                    shelfdtl.ItemInfo[p_item_index].W = shelf_width;
                                    shelfdtl.ItemInfo[p_item_index].H = 0.02;
                                    shelfdtl.ItemInfo[p_item_index].Quantity = 1;
                                } else if (basket_fill == "F") {
                                    var quantity = get_basket_fill_count(p_module_index, p_shelf_index, basket_spread, basket_fill, shelf_width, max_merch, shelf_depth, p_pog_index);
                                    shelfdtl.ItemInfo[p_item_index].W = shelf_width;
                                    shelfdtl.ItemInfo[p_item_index].H = shelfdtl.ItemInfo[p_item_index].OD * quantity;
                                    shelfdtl.ItemInfo[p_item_index].Quantity = quantity;
                                } else if (basket_fill == "M") {
                                    shelfdtl.ItemInfo[p_item_index].W = shelf_width;
                                    shelfdtl.ItemInfo[p_item_index].H = shelfdtl.ItemInfo[p_item_index].OD * item_qty;
                                    shelfdtl.ItemInfo[p_item_index].Quantity = item_qty;
                                }
                                finalX = shelf_start + parseFloat(shelfdtl.ItemInfo[p_item_index].W) / 2;
                                if (p_item_index == 0) {
                                    shelfdtl.ItemInfo[p_item_index].Y = shelfY + shelf_height / 2 + shelfdtl.ItemInfo[p_item_index].H / 2;
                                    finalX = shelf_start + parseFloat(shelfdtl.ItemInfo[p_item_index].W) / 2;
                                } else {
                                    finalX = shelf_start + parseFloat(shelfdtl.ItemInfo[p_item_index].W) / 2;
                                    var prevItem = shelfdtl.ItemInfo[p_item_index - 1].Item;
                                    if (prevItem == "DIVIDER") {
                                        //ASA-1085
                                        if (typeof shelfdtl.ItemInfo[p_item_index - 2] !== "undefined") {
                                            newIndex = p_item_index - 2;
                                            shelfdtl.ItemInfo[p_item_index].Y = shelfdtl.ItemInfo[newIndex].Y + shelfdtl.ItemInfo[newIndex].H / 2 + parseFloat(shelfdtl.ItemInfo[p_item_index].H) / 2;
                                        } else {
                                            shelfdtl.ItemInfo[p_item_index].Y = shelfY + shelf_height / 2 + shelfdtl.ItemInfo[p_item_index].H / 2;
                                        }
                                    } else {
                                        shelfdtl.ItemInfo[p_item_index].Y = shelfdtl.ItemInfo[p_item_index - 1].Y + shelfdtl.ItemInfo[p_item_index - 1].H / 2 + parseFloat(shelfdtl.ItemInfo[p_item_index].H) / 2;
                                    }
                                }
                            } else if (basket_spread == "FB") {
                                //if (i_item_index == 0) {
                                shelfdtl.ItemInfo[p_item_index].W = shelf_width;
                                shelfdtl.ItemInfo[p_item_index].H = max_merch;
                                finalX = shelf_start + parseFloat(shelfdtl.ItemInfo[p_item_index].W) / 2;
                                shelfdtl.ItemInfo[p_item_index].Y = shelfY + shelf_height / 2 + shelfdtl.ItemInfo[p_item_index].H / 2;

                                if (basket_fill == "F") {
                                    var quantity = get_basket_fill_count(p_module_index, p_shelf_index, "FB", "F", shelf_width, max_merch, shelf_depth, p_pog_index);
                                } else if ((basket_fill = "M")) {
                                    var quantity = item_qty;
                                } else {
                                    var quantity = 1;
                                }
                                shelfdtl.ItemInfo[p_item_index].Quantity = quantity;
                                //}
                            }
                        } else {
                            if (shelfdtl.ItemInfo[p_item_index].Item == "DIVIDER") {
                                //ASA-1085
                                finalX = shelfdtl.ItemInfo[p_item_index].X;
                                //shelfdtl.ItemInfo[i_item_index].Y = g_finalY;
                            } else {
                                finalX = shelfdtl.ItemInfo[p_item_index].X;
                            }
                        }
                    } else if ((p_shelf_obj_type == "CHEST" && g_chest_as_pegboard == "N") || p_shelf_obj_type == "PALLET") {
                        //ASA-1085
                        var sum_depth = 0;
                        var item_exists = shelfdtl.ItemInfo[p_item_index].Exists;
                        var chest_dragged = shelfdtl.ItemInfo[p_item_index].Dragged;
                        // ASA-2010.4.2 Start
                        // if (p_shelf_obj_type == "PALLET" && typeof bottom_objid !== "undefined" && bottom_objid !== "") {
                        //     finalX = shelfdtl.ItemInfo[get_shelf_item_ind(p_module_index, p_shelf_index, bottom_objid, p_pog_index);].X;
                        let l_item_ind;
                        if (p_shelf_obj_type == "PALLET" && typeof bottom_objid !== "undefined" && bottom_objid !== "") {
                            l_item_ind = get_shelf_item_ind(p_module_index, p_shelf_index, bottom_objid, p_pog_index);
                        }
                        if (p_shelf_obj_type == "PALLET" && typeof bottom_objid !== "undefined" && bottom_objid !== "" && l_item_ind >= 0) {
                            finalX = shelfdtl.ItemInfo[l_item_ind].X;
                        // ASA-2010.4.2 End
                        } else {
                            if (chest_dragged == "Y") {
                                if (p_item_length == 1 && p_edit_ind == "N") {
                                    finalX = shelf_start + parseFloat(p_width) / 2 - shelfdtl.LOverhang;
                                } else if (p_item_length > 1 && p_edit_ind == "N") {
                                    if (p_item_index > 0) {
                                        finalX = shelfdtl.ItemInfo[p_item_index - 1].X + shelfdtl.ItemInfo[p_item_index - 1].W / 2 + parseFloat(p_width) / 2 + p_spread_gap;
                                    } else {
                                        finalX = shelf_start + parseFloat(p_width) / 2 - shelfdtl.LOverhang;
                                    }
                                } else if (p_locationX + p_width / 2 > shelfdtl.X + shelfdtl.W / 2) {
                                    if (p_item_index !== g_edited_item_index) {
                                        finalX = shelfdtl.ItemInfo[p_item_index].X;
                                    } else if (p_item_index > 0) {
                                        finalX = shelfdtl.ItemInfo[p_item_index - 1].X + shelfdtl.ItemInfo[p_item_index - 1].W / 2 + parseFloat(p_width) / 2 + p_spread_gap;
                                    } else {
                                        finalX = shelf_start + parseFloat(p_width) / 2 - shelfdtl.LOverhang;
                                    }
                                } else {
                                    finalX = shelfdtl.ItemInfo[p_item_index].X;
                                }
                            } else {
                                shelfdtl.ItemInfo[p_item_index].Dragged = "Y";
                                if (item_exists == "E") {
                                    finalX = shelfdtl.ItemInfo[p_item_index].X;
                                } else if (p_item_index > 0 && g_edited_item_index !== p_item_index) {
                                    finalX = shelfdtl.ItemInfo[p_item_index - 1].X + shelfdtl.ItemInfo[p_item_index - 1].W / 2 + parseFloat(p_width) / 2 + p_spread_gap;
                                } else if (g_edited_item_index !== p_item_index && p_item_index == 0) {
                                    finalX = shelf_start + parseFloat(p_width) / 2 + shelfdtl.LOverhang;
                                } else if (g_edited_item_index == p_item_index && p_edit_ind == "Y") {
                                    finalX = shelfdtl.ItemInfo[p_item_index].X;
                                } else {
                                    finalX = p_locationX;
                                }
                            }
                        }
                    } else if (p_shelf_obj_type == "ROD") {
                        finalX = shelfdtl.X;
                    } else if (p_shelf_obj_type == "PEGBOARD" || (p_shelf_obj_type == "CHEST" && g_chest_as_pegboard == "Y")) {
                        finalX = find_pegboard_gap(p_width, p_height, shelfdtl.ItemInfo[p_item_index].X, shelfdtl.ItemInfo[p_item_index].Y, p_horiz_gap, p_module_index, p_shelf_index, p_item_index, g_edited_item_index, "N", p_pog_index, "Y", g_auto_x_space, g_auto_y_space, p_itemInsidePeg);
                    } else {
                        finalX = p_locationX;
                    }
                }
            }
        }
        logDebug("function : get_item_xaxis", "E");
        return wpdSetFixed(finalX);
    } catch (err) {
        error_handling(err);
    }
}

//ASA-1300
function get_top_y(p_item_top, p_items_list, p_top_threshold, p_item_index, p_height, p_item) {
    var l_minrange = p_item_top - p_top_threshold;
    var l_maxrange = p_item_top + p_top_threshold;
    var l_final_y = -1;
    var l_cnt = 0;
    var l_final_top = -1;
    var top_idx = -1;
    for (var item_info of p_items_list) {
        //ASA-1089
        if (l_cnt < p_item_index) {
            var new_top = item_info.Y + item_info.H / 2;
            if (new_top <= l_maxrange && new_top >= l_minrange && p_item.X + p_item.W / 2 > item_info.X + item_info.W / 2) {
                l_final_top = new_top;
                top_idx = l_cnt;
            }
        }
        l_cnt++;
    }
    if (l_final_top > -1) {
        l_final_top = l_final_top - p_height / 2;
    } else {
        l_final_top = p_item_top - p_height / 2;
    }
    return [l_final_top, top_idx];
} //ASA-1300

function find_pegboard_gap(p_width, p_height, p_locationX, p_locationY, p_horiz_gap, p_module_index, p_shelf_index, p_item_index, p_edited_item_index, p_validate, p_pog_index, p_calcY = "Y", p_dfl_x, p_dfl_y, p_itemInsidePeg) {
    logDebug("function : find_pegboard_gap; width : " + p_width + "; height : " + p_height + "; locationX : " + p_locationX + "; locationY : " + p_locationY + "; horiz_gap : " + p_horiz_gap + "; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index + "; i_item_index : " + p_item_index + "; i_edited_item_index : " + p_edited_item_index + "; validate : " + p_validate, "S");
    try {
        var finalX = -1;
        var itemdtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo;
        var shelfDtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
        var item_code = itemdtl[p_item_index].Item;
        var item_length = itemdtl.length;
        var item_exists = itemdtl[p_item_index].Exists;
        var currX = itemdtl[p_item_index].X;
        var from_productlist = itemdtl[p_item_index].FromProductList;
        var same_shelf = itemdtl[p_item_index].SameShelf;
        var edited_item = itemdtl[p_item_index].Edited;
        var allow_overlap = shelfDtl.AllowOverLap;
        var drop_y = itemdtl[p_item_index].DropY;
        var item_horiz_space = shelfDtl.HorizSpacing;
        var item_vert_space = shelfDtl.VertiSpacing;
        var shelf_horz_start = shelfDtl.HorizStart;
        var ItemAutoPlacing = shelfDtl.AutoPlacing;
        var shelf_top = shelfDtl.Y + shelfDtl.H / 2 + shelfDtl.UOverHang;
        var shelf_bottom = shelfDtl.Y - shelfDtl.H / 2 - shelfDtl.LoOverHang;
        var shelf_start = shelfDtl.X - shelfDtl.W / 2 - shelfDtl.LOverhang;
        var shelf_end = shelfDtl.X + shelfDtl.W / 2 + shelfDtl.ROverhang;
        var peg_verti_arr = shelfDtl.peg_vert_values;
        var peg_horiz_arr = shelfDtl.peg_horiz_values;
        var shelfyaxis = shelfDtl.Y;
        var item_drag_top = drop_y !== -1 ? drop_y + p_height / 2 + 0.003 : "";
        var peg_vert_details = [];
        var peg_horiz_details = [];
        var items_list = itemdtl;
        var overlap_valid = "Y";
        var j = 0;
        var k = 0;
        var yFound = "N";
        if (typeof ItemAutoPlacing == "undefined") {
            ItemAutoPlacing = "N";
        }
        if (peg_verti_arr.length > 0) {
            $.each(peg_verti_arr, function (j, details) {
                peg_vert_details.push(shelfyaxis + peg_verti_arr[j]);
            });
        }
        if (peg_horiz_arr.length > 0) {
            $.each(peg_horiz_arr, function (k, details) {
                peg_horiz_details.push(g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].X + peg_horiz_arr[k]);
            });
        }

        var item_start = p_locationY + itemdtl[p_item_index].H / 2;
        if (peg_vert_details.length > 0) {
            var closest = peg_vert_details.reduce((a, b) => {
                return Math.abs(b - item_start) < Math.abs(a - item_start) ? b : a;
            });
        }

        var obj_hit = "N";
        if (item_exists == "E") {
            finalX = itemdtl[p_item_index].X;
        } else if (ItemAutoPlacing == "Y" && g_chest_as_pegboard == "Y" && shelfDtl.ObjType == "CHEST") {
            var [finalX, finalY] = get_auto_placing_item_loc(p_module_index, p_shelf_index, p_pog_index, p_item_index, p_width, p_height, p_dfl_x, p_dfl_y);
            if (finalX !== -1) {
                itemdtl[p_item_index].X = finalX;
                itemdtl[p_item_index].Y = finalY;
                valid = "Y";
            }
        } else if ((typeof from_productlist !== "undefined" && from_productlist == "Y") || (g_pegbrd_auto_placing == "Y" && edited_item == "Y")) {
            //ASA-1085
            if (p_item_index == 0) {
                finalX = shelf_start + p_width / 2 + item_horiz_space; //ASA-1769, removed - shelfDtl.LOverhang

                if (g_pegbrd_auto_placing == "Y" && edited_item == "Y") {
                    finalX = p_locationX;
                    //ASA-1769
                    if (p_itemInsidePeg == "N") {
                        finalY = p_locationY;
                    } else {
                        finalY = closest - p_height / 2;
                    }
                } else {
                    /* ASA-1178
                    if (shelfDtl.ObjType !== "CHEST") {
                    finalX = finalX - 0.01;
                    }*/
                    finalX = finalX;
                    finalY = peg_vert_details[0] - p_height / 2;
                }
                itemdtl[p_item_index].Y = finalY;
                itemdtl[p_item_index].SecondTier = "N";
                itemdtl[p_item_index].X = finalX;
            } else if (item_length > 1 && p_item_index > 0) {
                var t = 0;
                var h = 0;
                for (l = h; l < peg_vert_details.length; l++) {
                    if (finalX > -1) {
                        break;
                    }
                    if (peg_vert_details[l] - p_height > shelf_bottom) {
                        console.log("peg_vert_details[l]", peg_vert_details[l], item_drag_top, edited_item);
                        if ((item_drag_top !== "" && peg_vert_details[l] <= item_drag_top && edited_item == "Y") || edited_item == "N" || item_drag_top == "") {
                            for (j = t; j < peg_horiz_details.length; j++) {
                                if (peg_horiz_details[j] + p_width < shelf_end) {
                                    if (g_pegbrd_auto_placing == "Y" && edited_item == "Y") {
                                        //ASA-1178
                                        if (shelfDtl.ObjType !== "CHEST") {
                                            item_start = wpdSetFixed(p_locationX - p_width / 2 + 0.01); //.toFixed(4));
                                            item_end = wpdSetFixed(p_locationX + p_width / 2 + 0.01); //.toFixed(4));
                                        } else {
                                            item_start = wpdSetFixed(p_locationX - p_width / 2); //.toFixed(4));
                                            item_end = wpdSetFixed(p_locationX + p_width / 2); //.toFixed(4));
                                        }
                                        item_top = wpdSetFixed(peg_vert_details[l]); //.toFixed(4));
                                        item_bottom = wpdSetFixed(peg_vert_details[l] - p_height); //.toFixed(4));
                                    } else {
                                        if (shelfDtl.ObjType !== "CHEST") {
                                            item_start = wpdSetFixed(peg_horiz_details[j] + 0.01); //.toFixed(4));
                                            item_end = wpdSetFixed(peg_horiz_details[j] + p_width + 0.01); //.toFixed(4));
                                        } else {
                                            item_start = wpdSetFixed(peg_horiz_details[j]); //.toFixed(4));
                                            item_end = wpdSetFixed(peg_horiz_details[j] + p_width); //.toFixed(4));
                                        }
                                        item_top = wpdSetFixed(peg_vert_details[l]); //.toFixed(4));
                                        item_bottom = wpdSetFixed(peg_vert_details[l] - p_height); //.toFixed(4));
                                    }

                                    var k = 0;
                                    var valid = "Y";
                                    var hit_index = -1;
                                    for (const items of items_list) {
                                        if (k < p_item_index) {
                                            div_start = wpdSetFixed(items.X - items.W / 2); //.toFixed(4));
                                            div_end = wpdSetFixed(items.X + items.W / 2); //.toFixed(4));
                                            div_top = wpdSetFixed(items.Y + items.H / 2); //.toFixed(4));
                                            div_bottom = wpdSetFixed(items.Y - items.H / 2); //.toFixed(4));

                                            if (((item_top > div_bottom && div_top > item_top) || item_end > shelf_end) && ItemAutoPlacing == "N") {
                                                valid = "N";
                                                g_prevX = j;
                                                g_prevY = l;
                                                hit_index = k;
                                                break; //return false;
                                            } else {
                                                if ((((div_start < item_end && div_start >= item_start) || (div_end > item_start && div_end <= item_end)) && ((div_bottom < item_top && div_bottom >= item_bottom) || (div_top <= item_top && div_top > item_bottom))) || (((item_start < div_start && item_end > div_start) || (item_start < div_end && item_end >= div_end)) && item_top <= div_top && item_bottom >= div_bottom) || (((div_start <= item_start && div_end >= item_end) || (div_start >= item_start && div_end <= item_end)) && ((div_top >= item_top && item_bottom >= div_bottom) || (div_top >= item_top && div_bottom <= item_bottom) || (div_top > item_top && div_bottom <= item_top))) || (item_start < div_start && item_end >= div_end && item_top <= div_top && item_top > div_bottom && item_bottom <= div_bottom) || (item_start > div_start && item_end <= div_end && item_top >= div_top && item_bottom < div_top && item_bottom <= div_bottom) || (item_start < div_start && item_end >= div_end && item_top <= div_top && item_bottom >= div_bottom) || (item_start < div_start && item_end >= div_end && item_top < div_top && item_top > div_bottom) || (item_start >= div_start && item_start < div_end && item_bottom >= div_bottom && item_bottom < div_top)) {
                                                    valid = "N";
                                                    g_prevX = j;
                                                    g_prevY = l;
                                                    hit_index = k;
                                                    break; //return false;
                                                }
                                            }
                                        }
                                        k++;
                                    }
                                    if (valid == "Y") {
                                        g_prevX++;
                                        g_prevY++;
                                        finalX = item_start + p_width / 2;

                                        if (g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ObjType !== "CHEST") {
                                            if (shelf_start == item_start - 0.02) {
                                                finalX = finalX - 0.01;
                                            }
                                        }
                                        itemdtl[p_item_index].X = finalX;
                                        //ASA-1300
                                        if (shelfDtl.ObjType == "CHEST" && ItemAutoPlacing == "Y") {
                                            var [finalY, top_idx] = get_top_y(item_top, items_list, 0.001, p_item_index, p_height, itemdtl[p_item_index]);
                                            itemdtl[p_item_index].Y = finalY - p_dfl_y;
                                        } else {
                                            if (p_itemInsidePeg == "N") {
                                                itemdtl[p_item_index].Y = p_locationY;
                                            } else {
                                                itemdtl[p_item_index].Y = item_top - p_height / 2;
                                            }
                                        }

                                        itemdtl[p_item_index].SecondTier = "Y";
                                        yFound = "Y";
                                        break;
                                    } else if (allow_overlap == "Y") {
                                        var div_top = itemdtl[hit_index].Y + itemdtl[hit_index].H / 2;
                                        var div_bottom = itemdtl[hit_index].Y - itemdtl[hit_index].H / 2;
                                        item_top = p_locationY + itemdtl[p_item_index].H / 2;
                                        item_bottom = p_locationY - itemdtl[p_item_index].H / 2;
                                        if ((item_bottom < itemdtl[hit_index].Y && div_top < item_bottom) || (item_top > itemdtl[hit_index].Y && item_top < div_top) || (div_top > p_locationY && div_top < item_top) || (div_bottom < p_locationY && div_top > item_top)) {
                                            var total_depth = itemdtl[hit_index].D * itemdtl[hit_index].BaseD + itemdtl[p_item_index].D * itemdtl[p_item_index].BaseD;
                                            if (g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].MaxMerch > 0) {
                                                if (total_depth > g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].MaxMerch) {
                                                    overlap_valid = "D";
                                                    break;
                                                } else {
                                                    overlap_valid = "Y";
                                                    itemdtl[p_item_index].X = p_locationX;
                                                    //ASA-1769
                                                    if (p_itemInsidePeg == "N") {
                                                        itemdtl[p_item_index].Y = p_locationY;
                                                    } else {
                                                        itemdtl[p_item_index].Y = closest - p_height / 2;
                                                    }
                                                    break;
                                                }
                                            } else {
                                                overlap_valid = "Y";
                                                itemdtl[p_item_index].X = p_locationX;
                                                //ASA-1769
                                                if (p_itemInsidePeg == "N") {
                                                    itemdtl[p_item_index].Y = p_locationY;
                                                } else {
                                                    itemdtl[p_item_index].Y = closest - p_height / 2;
                                                }
                                                break;
                                            }
                                        } else {
                                            overlap_valid = "Y";
                                            itemdtl[p_item_index].X = p_locationX;
                                            //ASA-1769
                                            if (p_itemInsidePeg == "N") {
                                                itemdtl[p_item_index].Y = p_locationY;
                                            } else {
                                                itemdtl[p_item_index].Y = closest - p_height / 2;
                                            }
                                            break;
                                        }
                                    }
                                } else {
                                    break;
                                }
                            }
                        } else {
                            continue;
                        }
                    } else {
                        break;
                    }
                    if (yFound == "Y") {
                        break;
                    }
                }
            }
        } else if (item_exists == "N" && (from_productlist == "N" || typeof from_productlist == "undefined")) {
            var item_top = wpdSetFixed(itemdtl[p_item_index].Y + p_height / 2); //.toFixed(4));
            var item_bottom = wpdSetFixed(itemdtl[p_item_index].Y - p_height / 2); //.toFixed(4));
            var x = itemdtl[p_item_index].X;
            if (isNaN(x)) {
                x = g_final_x;
            }
            var item_start = wpdSetFixed(x - p_width / 2); //.toFixed(4));
            var item_end = wpdSetFixed(x + p_width / 2); //.toFixed(4));
            var itemID = itemdtl[p_item_index].ItemID;
            var valid = "Y";
            var k = 0;
            for (const items of items_list) {
                if (k !== p_item_index) {
                    div_start = wpdSetFixed(items.X - items.W / 2); //.toFixed(4));
                    div_end = wpdSetFixed(items.X + items.W / 2); //.toFixed(4));
                    div_top = wpdSetFixed(items.Y + items.H / 2); //.toFixed(4));
                    div_bottom = wpdSetFixed(items.Y - items.H / 2); //.toFixed(4));
                    if ((((div_start < item_end && div_start >= item_start) || (div_end > item_start && div_end <= item_end)) && ((div_bottom < item_top && div_bottom >= item_bottom) || (div_top <= item_top && div_top > item_bottom))) || (((item_start < div_start && item_end > div_start) || (item_start < div_end && item_end >= div_end)) && item_top <= div_top && item_bottom >= div_bottom) || (((div_start <= item_start && div_end >= item_end) || (div_start >= item_start && div_end <= item_end)) && ((div_top >= item_top && item_bottom >= div_bottom) || (div_top >= item_top && div_bottom <= item_bottom) || (div_top > item_top && div_bottom <= item_top))) || (item_start < div_start && item_end >= div_end && item_top <= div_top && item_top > div_bottom && item_bottom <= div_bottom) || (item_start > div_start && item_end <= div_end && item_top >= div_top && item_bottom < div_top && item_bottom <= div_bottom) || (item_start < div_start && item_end >= div_end && item_top <= div_top && item_bottom >= div_bottom) || (item_start < div_start && item_end >= div_end && item_top < div_top && item_top > div_bottom) || (item_start >= div_start && item_start < div_end && item_bottom >= div_bottom && item_bottom < div_top)) {
                        valid = "N";
                        hit_index = k;
                        console.log("items", items.Item, items.X, items.W);
                        console.log("div_start ", div_start, " div end ", div_end, " div top ", div_top, "div bottom ", div_bottom);
                        console.log("item_start ", item_start, " item end ", item_end, " item top ", item_top, " item bottom ", item_bottom);
                        break; //return false;
                    }
                }

                // });
                k++;
            }
            if (valid == "Y") {
                //ASA-1178
                if (shelfDtl.ObjType !== "CHEST") {
                    finalX = item_start + itemdtl[p_item_index].W / 2 + 0.002;
                } else {
                    finalX = x; //item_start + itemdtl[p_item_index].W / 2;ASA-1343 Issue 1
                }
                prevX = finalX;
                if (g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ObjType !== "CHEST") {
                    if (g_mselect_drag == "N" && p_calcY == "Y") {
                        //ASA-1769
                        if (p_itemInsidePeg == "N") {
                            finalY = p_locationY;
                        } else {
                            for (l = 0; l < peg_vert_details.length; l++) {
                                if (peg_vert_details[l] < g_finalY + p_height / 2) {
                                    //ASA-1739 Issue 1
                                    var shelfTop = wpdSetFixed(g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].X + g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].H / 2); // Regression Issue 1 30042025
                                    if (g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].UOverHang > 0 && shelfTop < g_finalY + p_height / 2 && shelfTop > g_finalY - p_height / 2) {
                                        itemdtl[p_item_index].Y = wpdSetFixed(peg_vert_details[l]);
                                    } else {
                                        itemdtl[p_item_index].Y = wpdSetFixed(peg_vert_details[l]) - p_height / 2;
                                    }
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    if (shelfDtl.ObjType !== "CHEST") {
                        if (shelf_start == item_start - 0.02) {
                            finalX = finalX - 0.01;
                        }
                    } else {
                        /*if (shelf_start == item_start) {
                        finalX = finalX;
                        } else {
                        finalX = finalX + p_dfl_x;
                        }*/
                        finalX = finalX;
                    }
                    itemdtl[p_item_index].X = finalX;
                    /*if (shelfDtl.ObjType == "CHEST") {
                    var [finalY, top_idx] = get_top_y(item_top, items_list, 0.001, p_item_index, p_height, itemdtl[p_item_index]);
                    itemdtl[p_item_index].Y = finalY;
                    } else {*/
                    //ASA-1769
                    if (p_itemInsidePeg == "N" && shelfDtl.ObjType !== "CHEST") {
                        itemdtl[p_item_index].Y = p_locationY;
                    } else {
                        itemdtl[p_item_index].Y = item_top - p_height / 2;
                    }
                    //}
                }

                itemdtl[p_item_index].SecondTier = "Y";
            } else if (allow_overlap == "Y") {
                var div_top = itemdtl[hit_index].Y + itemdtl[hit_index].H / 2;
                var div_bottom = itemdtl[hit_index].Y - itemdtl[hit_index].H / 2;
                item_top = p_locationY + itemdtl[p_item_index].H / 2;
                item_bottom = p_locationY - itemdtl[p_item_index].H / 2;
                if ((item_bottom < itemdtl[hit_index].Y && div_top < item_bottom) || (item_top > itemdtl[hit_index].Y && item_top < div_top) || (div_top > p_locationY && div_top < item_top) || (div_bottom < p_locationY && div_top > item_top)) {
                    var total_depth = itemdtl[hit_index].D * itemdtl[hit_index].BaseD + itemdtl[p_item_index].D * itemdtl[p_item_index].BaseD;
                    if (g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].MaxMerch > 0) {
                        if (total_depth > g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].MaxMerch) {
                            overlap_valid = "D";
                        } else {
                            overlap_valid = "Y";
                            itemdtl[p_item_index].X = p_locationX;
                            //ASA-1769
                            if (p_itemInsidePeg == "N") {
                                itemdtl[p_item_index].Y = p_locationY;
                            } else {
                                itemdtl[p_item_index].Y = closest - p_height / 2;
                            }
                        }
                    } else {
                        overlap_valid = "Y";
                        itemdtl[p_item_index].X = p_locationX;
                        //ASA-1769
                        if (p_itemInsidePeg == "N") {
                            itemdtl[p_item_index].Y = p_locationY;
                        } else {
                            itemdtl[p_item_index].Y = closest - p_height / 2;
                        }
                    }
                } else {
                    overlap_valid = "Y";
                    itemdtl[p_item_index].X = p_locationX;
                    //ASA-1769
                    if (p_itemInsidePeg == "N") {
                        itemdtl[p_item_index].Y = p_locationY;
                    } else {
                        itemdtl[p_item_index].Y = closest - p_height / 2;
                    }
                }
            }
            //ASA-1178
            if (valid == "Y") {
                var item_top = wpdSetFixed(itemdtl[p_item_index].Y + p_height / 2); //.toFixed(4));
                var item_bottom = wpdSetFixed(itemdtl[p_item_index].Y - p_height / 2); //.toFixed(4));
                var x = itemdtl[p_item_index].X;
                if (isNaN(x)) {
                    x = g_final_x;
                }
                var item_start = wpdSetFixed(x - p_width / 2); //.toFixed(4));
                var item_end = wpdSetFixed(x + p_width / 2); //.toFixed(4));
                if (item_start < shelf_start || item_end < shelf_start || item_end > shelf_end || item_top > shelf_top || item_bottom < shelf_bottom) {
                    //ASA-1519
                    finalX = -1;
                    valid = "N";
                }
            }
        }
        logDebug("function : find_pegboard_gap", "E");
        if (p_validate == "Y" && overlap_valid == "D" && allow_overlap == "Y") {
            return "D";
        } else if (p_validate == "Y" && overlap_valid == "N" && allow_overlap == "Y") {
            return "N";
        } else if (p_validate == "Y" && overlap_valid == "Y" && allow_overlap == "Y") {
            return p_locationX;
        } else if (p_validate == "Y" && finalX == -1) {
            return "N";
        } else if (finalX == -1 && p_validate == "N") {
            return itemdtl[p_item_index].X;
        } else {
            return finalX;
        }
    } catch (err) {
        error_handling(err);
    }
}

async function recreate_compare_views(p_view_ind, p_reload) {
    logDebug("function : recreate_compare_views; view_ind : " + p_view_ind + "; reload : " + p_reload, "S");
    if (g_compare_pog_flag == "Y" && g_compare_view !== "PREV_VERSION" && g_compare_view !== "POG") {
        if (p_view_ind == "POG" && p_reload == "Y") {
            var TEMP_POG = JSON.parse(JSON.stringify(g_pog_json));
            let result1 = await create_module_from_json([g_pog_json[g_ComViewIndex]], "N", "F", "N", "E", "N", "N", "Y", "Y", "", "Y", g_scene_objects[g_ComViewIndex].scene.children[2], g_scene_objects[g_ComViewIndex].scene, g_ComViewIndex, g_ComViewIndex);
            var new_json = JSON.parse(JSON.stringify(g_multi_pog_json));

            g_multi_pog_json = JSON.parse(JSON.stringify(TEMP_POG));
            g_multi_pog_json.push(new_json[0]);
            g_pog_json = g_multi_pog_json;

            var details = get_min_max_xy(g_ComViewIndex);
            var details_arr = details.split("###");
            set_camera_z(g_scene_objects[g_ComViewIndex].scene.children[0], parseFloat(details_arr[2]), parseFloat(details_arr[3]), parseFloat(details_arr[0]), parseFloat(details_arr[1]), g_offset_z, parseFloat(details_arr[4]), parseFloat(details_arr[5]), g_ComViewIndex);
        } else if (p_view_ind == "CUTAWAY") {
            var new_world = g_scene_objects[g_pog_index].scene.children[2].clone(true);
            g_scene_objects[g_ComViewIndex].scene.children[2] = new_world;
            set_camera_z(g_scene_objects[g_ComViewIndex].scene.children[0], g_cutaway_cam_detail[0].x, g_cutaway_cam_detail[0].y, g_cutaway_cam_detail[0].width, g_cutaway_cam_detail[0].height, g_cutaway_cam_detail[0].offset, g_cutaway_cam_detail[0].x, g_cutaway_cam_detail[0].y, true, g_ComViewIndex);
        } else if (p_view_ind !== "POG" && p_reload == "N" && p_view_ind !== "EDIT_PALLET") {
            console.log("g_ComViewIndex", g_ComViewIndex, p_view_ind);
            g_scene_objects.splice(g_ComViewIndex, 1);
            g_canvas_objects.splice(g_ComViewIndex, 1);
            init(g_ComViewIndex);
            var objects = {};
            objects["scene"] = g_scene;
            objects["renderer"] = g_renderer;
            g_scene_objects.push(objects);

            if (g_pog_json[g_ComViewIndex].H < 0.2) {
                var returnval = await create_compare_pog(p_view_ind);
            } else {
                var returnval = await create_side(p_view_ind, g_ComBaseIndex, g_ComViewIndex);
                g_scene_objects[g_ComViewIndex].scene.children[0].updateProjectionMatrix();
            }
        } else if (p_view_ind == "EDIT_PALLET") {
            //ASA-1085
            old_pog_index = g_pog_index;
            console.log("g_ComBaseIndex", g_ComBaseIndex, g_ComViewIndex);
            var [mod_ind, shelf_ind] = get_shelf_index(g_edit_pallet_shelfid, g_ComBaseIndex);
            if (mod_ind !== -1 && shelf_ind !== -1) {
                update_item_distance(mod_ind, shelf_ind, g_ComBaseIndex, "N"); //Bug-26122 - splitting the chest
                g_pog_json[g_ComViewIndex].ModuleInfo[0].ShelfInfo[0] = JSON.parse(JSON.stringify(g_pog_json[g_ComBaseIndex].ModuleInfo[mod_ind].ShelfInfo[shelf_ind]));
                g_pog_json[g_ComViewIndex].ModuleInfo[0].ShelfInfo[0].PrimeShelfObjID = g_pog_json[g_ComBaseIndex].ModuleInfo[mod_ind].ShelfInfo[shelf_ind].SObjID;
            }
            g_pog_json.splice(g_ComViewIndex, 1);
            g_scene_objects.splice(g_ComViewIndex, 1);
            g_canvas_objects.splice(g_ComViewIndex, 1);
            await edit_pallet("N", mod_ind, shelf_ind, g_ComBaseIndex, "N");
        }
    }
    logDebug("function : recreate_compare_views", "E");
}

var new_count = 0;
function animate_all(p_timestamp) {
    logDebug("function : limited_animate", "S");
    setTimeout(function () {
        if (new_count < 5) {
            new_count = new_count + 1;
            async function animate_pogs() {
                await render_all_pog();
            }
            animate_pogs();
            requestAnimationFrame(animate_all);
        } else {
            new_count = 0;
        }
        logDebug("function : limited_animate", "E");
    }, 1000 / 20);
}

function animate_all_pog() {
    requestAnimationFrame(animate_all);
}

async function render_all_pog() {
    var i = 0;
    for (const obj of g_scene_objects) {
        var context = g_canvas_objects[i].getContext("2d");
        g_renderer.setPixelRatio(window.devicePixelRatio);
        var canvas_width = g_canvas_objects[i].width;
        var canvas_height = g_canvas_objects[i].height;

        g_renderer.setSize(canvas_width, canvas_height);
        g_scene_objects[i].scene.children[0].aspect = canvas_width / canvas_height;
        g_renderer.render(g_scene_objects[i].scene, g_scene_objects[i].scene.children[0]);
        if (context !== null) {
            context.drawImage(g_renderer.domElement, 0, 0, canvas_width, canvas_height);
        }

        i++;
    }
}

async function add_carpark_item(p_uuid, p_width, p_height, p_depth, p_color, p_x, p_y, p_z, p_module_index, p_shelf_index, p_item_index, p_recreate, p_fresh_item, p_with_image, p_angle, p_pog_index) {
    logDebug("function : add_carpark_item; uuid : " + p_uuid + "; width : " + p_width + "; height : " + p_height + "; depth : " + p_depth + "; color : " + p_color + "; x : " + p_x + "; y : " + p_y + "; z : " + p_z + "; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index + "; i_item_index : " + p_item_index + "; recreate : " + p_recreate + "; with_image : " + p_with_image + "; angle : " + p_angle, "S");
    try {
        console.log("add carpark ", p_with_image);
        var itemdtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].Carpark[p_shelf_index].ItemInfo[p_item_index];
        var nesting_val = itemdtl.NVal;
        var item_orientation = itemdtl.Orientation;
        var vert_facing = itemdtl.BVert;
        var horiz_facing = itemdtl.BHoriz;
        var details = g_orientation_json[item_orientation];
        var details_arr = details.split("###");
        return new Promise(function (resolve, reject) {
            var img_exists = "N";
            var img_index = -1;
            var item_code = itemdtl.Item;
            var j = 0;
            for (const images_arr of g_ItemImages) {
                if (item_code == images_arr.Item && details_arr[0] == images_arr.Orientation && images_arr.ItemImage !== null) {
                    img_exists = "Y";
                    img_index = j;
                    break; //return false;
                }
                j++;
            }
            if (img_exists == "Y" && p_with_image == "Y") {
                // Create an image
                var image = new Image(); // or document.createElement('img' );
                // Create texture
                var tex = new THREE.Texture(image);
                // On image load, update texture
                image.onload = () => {
                    tex.needsUpdate = true;
                };
                // Set image source
                image.src = "data:image/jpeg;base64," + g_ItemImages[img_index].ItemImage;
                var geometry = new THREE.BoxGeometry(p_width, p_height, 0.001);
                var material = new THREE.MeshStandardMaterial({
                    map: tex,
                });
                if (nesting_val == 0) {
                    tex.wrapS = THREE.RepeatWrapping;
                    tex.wrapT = THREE.RepeatWrapping;
                    if (p_angle == 90 || p_angle == 270) {
                        tex.repeat.set(vert_facing, horiz_facing);
                    } else {
                        tex.repeat.set(horiz_facing, vert_facing);
                    }
                    if (p_angle == 90) {
                        p_angle = 270;
                    } else if (p_angle == 270) {
                        p_angle = 90;
                    }
                    tex.rotation = (p_angle * Math.PI) / 180;
                }
                items = new THREE.Mesh(geometry, material);
                items.position.x = p_x;
                items.position.z = 0.001;
                items.position.y = p_y;
            } else {
                var colorValue = parseInt(p_color.replace("#", "0x"), 16);
                var hex_decimal = new THREE.Color(colorValue);
                items = new THREE.Mesh(
                    new THREE.BoxGeometry(p_width, p_height, 0.001),
                    new THREE.MeshStandardMaterial({
                        color: hex_decimal,
                    })
                );
                items.position.z = 0.001;

                items.position.x = p_x;
                items.position.y = p_y;
            }
            g_world.add(items);
            var item_info = itemdtl;
            items.uuid = p_uuid;
            items.ItemID = item_info.Item;
            items.Description = item_info.Desc;
            items.HorizFacing = item_info.BHoriz;
            items.VertFacing = item_info.BVert;
            items.DFacing = item_info.BaseD;
            items.DimUpdate = item_info.DimUpdate;
            items.SellingPrice = item_info.SellingPrice;
            items.SalesUnit = item_info.SalesUnit;
            items.NetSales = item_info.NetSales;
            items.CogsAdj = item_info.CogsAdj;
            items.RegMovement = item_info.RegMovement;
            items.AvgSales = item_info.AvgSales;
            items.ItemStatus = item_info.ItemStatus;
            items.CDTLvl1 = item_info.CDTLvl1; //ASA-1130
            items.CDTLvl2 = item_info.CDTLvl2; //ASA-1130
            items.CDTLvl3 = item_info.CDTLvl3; //ASA-1130
            items.ActualDPP = item_info.ActualDPP; //ASA-1182 ASA-1277-(3)
            items.DPPLoc = item_info.DPPLoc; //ASA-1308 Task-3
            items.StoreSOH = item_info.StoreSOH; //ASA-1182 ASA-1277-(3)
            items.StoreNo = item_info.StoreNo; //ASA-1277-(3)
            items.WeeksOfInventory = item_info.WeeksOfInventory; //ASA-1277-(3)
             //ASA-2013 Start
            items.ShelfPrice = item_info.ShelfPrice;
            items.PromoPrice = item_info.PromoPrice;
            items.DiscountRate = item_info.DiscountRate;
            items.PriceChangeDate = item_info.PriceChangeDate;
            items.WeeksOfInventory = item_info.WeeksOfInventory;
            items.Qty = item_info.Qty;
            items.WhStock = item_info.WhStock;
            items.StoreStock = item_info.StoreStock;
            items.StockIntransit = item_info.StockIntransit;
            //ASA-2013 End
            items.GrossProfit = item_info.GrossProfit;
            items.WeeksCount = item_info.WeeksCount;
            items.MovingItem = item_info.MovingItem;
            items.Profit = item_info.Profit;
            items.TotalMargin = item_info.TotalMargin;
            items.W = item_info.W;
            items.H = item_info.H;
            items.D = item_info.D;
            items.Color = item_info.Color;
            items.Barcode = item_info.Barcode;
            items.Desc = item_info.Desc;
            items.Brand = item_info.Brand;
            items.Group = item_info.Group;
            items.Dept = item_info.Dept;
            items.Class = item_info.Class;
            items.SubClass = item_info.SubClass;
            items.StdUOM = item_info.StdUOM;
            items.SizeDesc = item_info.SizeDesc;
            items.Supplier = item_info.Supplier;
            items.LocID = item_info.LocID;
            // items.Supplier = item_info.Supplier;
            items.SupplierName = item_info.SupplierName; //already supplier was added
            items.ItemDim = g_msg_h + ": " + (item_info.OH * 100).toFixed(2) + " (" + g_msg_Sq + " : " + item_info.CrushVert + ")" + " " + g_msg_w + ": " + (item_info.OW * 100).toFixed(2) + " (" + g_msg_Sq + " : " + item_info.CrushHoriz + ")" + " " + g_msg_d + ": " + (item_info.OD * 100).toFixed(2) + " (" + g_msg_Sq + " : " + item_info.CrushD + ")"; //ASA-1407 issue 9
            items.OrientationDesc = item_info.OrientationDesc;
            items.StoreCnt = item_info.StoreCnt;
            items.RotationDegree = 0;
            items.OW = item_info.OW * 100;
            items.OH = item_info.OH * 100;
            items.OD = item_info.OD * 100;
            items.CrushW = item_info.CrushHoriz; //ASA-1758
            items.CrushH = item_info.CrushVert; //ASA-1758
            items.CrushD = item_info.CrushD; //ASA-1758
            items.Shelf = g_pog_json[p_pog_index].ModuleInfo[p_module_index].Carpark[p_shelf_index].Shelf;
            items.Rotation = 0;
            items.ItemSlope = 0;
            items.Rotation = "N";
            items.ImageExists = "N";
            items.DescSecond = item_info.DescSecond;
            items.DfacingUpd = item_info.DfacingUpd;
            items.ItmDescChi = item_info.ItmDescChi; //ASA-1407 Task 1;,//ASA-1407 issue 5
            items.ItmDescEng = item_info.ItmDescEng; //ASA-1273 Prasanna
            //items.ItmDescEng = items.Brand + items.Desc + items.SizeDesc;
            items.TotalUnitsCalc = item_info.BHoriz * item_info.BVert * item_info.BaseD;
            items.PkSiz = item_info.PkSiz;
            var cap_capacity = item_info.CapFacing * item_info.CapDepth * item_info.CapHorz; //ASA-1273 Prasanna
            items.Cpct = item_info.BHoriz * item_info.BVert * item_info.BaseD + (!isNaN(cap_capacity) ? cap_capacity : 0);
            items.Brand_Category = item_info.Brand_Category; //ASA-1158-S
            items.ClassName = item_info.ClassName;
            items.Uda_item_status = item_info.Uda_item_status;
            items.Gobecobrand = item_info.Gobecobrand;
            items.Internet = item_info.Internet; //ASA-1158-E,//ASA-1407 issue 9 internet
            items.Categ = item_info.Categ;
            var det_arr = item_info.SizeDesc.split("*");
            items.ItemSize = item_info.ItemSize;
            items.SplrLbl = item_info.SplrLbl;
            items.COO = item_info.COO;
            items.EDLP = item_info.EDLP;
            items.LoGrp = item_info.LoGrp;
            items.SqzPer = (typeof item_info.CrushHoriz !== "undefined" ? item_info.CrushHoriz : 0) + ":" + (typeof item_info.CrushVert !== "undefined" ? item_info.CrushVert : 0) + ":" + (typeof item_info.CrushD !== "undefined" ? item_info.CrushD : 0); //added Anamika below tags are added to match with func add_items_prom
            items.InternationalRng = item_info.InternationalRng;
            items.NewItem = item_info.NewItem; //ASA-1182
            items.DaysOfSupply = item_info.DaysOfSupply;
            items.BrandType = item_info.BrandType; //added below tags to match with func add_items_prom ASA-1292
            items.LiveNewItem = item_info.LiveNewItem;
            items.GoGreen = item_info.GoGreen;
            items.UnitperCase = item_info.UnitperCase;
            items.Orientation = item_info.Orientation;
            items.UnitperTray = item_info.UnitperTray;
            if (typeof item_info.Dept !== "undefined" && item_info.Dept !== "" && item_info.Dept !== null) {
                //ASA-1407 issue 9 S
                var itemdept = item_info.Dept.split("-");
            } else {
                var itemdept = "";
            }
            if (typeof item_info.Class !== "undefined" && item_info.Class !== "" && item_info.Class !== null) {
                var itemclass = item_info.Class.split("-");
            } else {
                var itemclass = "";
            }
            if (typeof item_info.SubClass !== "undefined" && item_info.SubClass !== "" && item_info.SubClass !== null) {
                var itemsubclass = item_info.SubClass.split("-");
            } else {
                var itemsubclass = "";
            }
            items.ClassName = itemdept[0] + "/" + itemclass[0] + "/" + itemsubclass[0];
            items.UDA751 = item_info.UDA751;
            items.UDA755 = item_info.UDA755;
            items.Status = item_info.Status;
            items.StoreCnt = item_info.StoreCnt; //ASA-1407 issue 9 -E
            var l_wireframe_id = add_wireframe(items, 2);
            items.WFrameID = l_wireframe_id;
            //ASA-1640 Start
            items.ItemCondition = item_info.ItemCondition;
            items.AUR = item_info.AUR;
            items.ItemRanking = item_info.ItemRanking;
            items.WeeklySales = item_info.WeeklySales;
            items.WeeklyNetMargin = item_info.WeeklyNetMargin;
            items.WeeklyQty = item_info.WeeklyQty;
            items.NetMarginPercent = item_info.NetMarginPercent;
            items.CumulativeNM = item_info.CumulativeNM;
            items.TOP80B2 = item_info.TOP80B2;
            items.ItemBrandC = item_info.ItemBrandC;
            items.ItemPOGDept = item_info.ItemPOGDept;
            items.ItemRemark = item_info.ItemRemark;
            items.RTVStatus = item_info.RTVStatus;
            items.Pusher = item_info.Pusher;
            items.Divider = item_info.Divider;
            items.BackSupport = item_info.BackSupport;
            //ASA-1640 End
            items.CWPerc = item_info.CWPerc; //ASA-1640 #5
            items.CHPerc = item_info.CHPerc; //ASA-1640 #5
            items.CDPerc = item_info.CDPerc; //ASA-1640 #5

            items.OOSPerc = item_info.OOSPerc; //ASA-1688 Added for OOS%
            items.InitialItemDesc = item_info.InitialItemDesc; //ASA-1734 Issue 1
            items.InitialBrand = item_info.InitialBrand; //ASA-1787 Request #6
            items.InitialBarcode = item_info.InitialBarcode; //ASA-1787 Request #6

            resolve(items.id);
            var selectedObject = g_world.getObjectById(items.id);
            if (items.DimUpdate == "E") {
                selectedObject.BorderColour = g_dim_error_color;
                selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
            } else if (items.Status == "N") {
                selectedObject.BorderColour = g_status_error_color;
                selectedObject.Status = "N";
                selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
            } else if (nvl(items.MovingItem) == "No" && g_pogcr_auto_hlite_non_mv_item == "Y") {
                selectedObject.BorderColour = g_nonMovingItemColor;
                selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
            } else {
                if (items.OOSPerc > 80 && g_pogcr_enbl_oos_border == "Y") {
                    //ASA-1688
                    selectedObject.BorderColour = g_pogcr_oos_border_color; //ASA-1688 Added to give blue border to item
                    selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                } else {
                    selectedObject.BorderColour = 0x000000;
                }
            }
            logDebug("function : add_carpark_item", "E");
        });
    } catch (err) {
        error_handling(err);
    }
}

async function refresh_sales_data(p_weekselection, p_store, p_fontsize, p_detailitemlist, p_daysupplylabel, p_dialogclose, p_loadingind, p_showerror = "Y", p_pogCode, p_select_pog, p_SavetoColl = "N", p_pog_index = g_pog_index, p_bybass_alert = "N") { //ASA-1803 Added param p_bybass_alert
    //ASA-1360 issue 3
    logDebug("function : send_to_db; refresh_sales_data : ", "S");
    return new Promise(function (resolve, reject) {
        console.log("refresh sales ", p_weekselection, p_store, p_fontsize, p_detailitemlist, p_daysupplylabel, p_dialogclose, p_loadingind, p_showerror, "ACTUAL POG", p_pogCode, "SELECTED POG", p_select_pog, (p_SavetoColl = "N"), (p_pog_index = g_pog_index));
        var itemjson;
        if (p_loadingind == "Y") {
            addLoadingIndicator();
        }
        var p = apex.server.process(
            "SALES_REFRESH",
            {
                x01: p_pogCode, //Task-02_25977
                x02: p_store, //Task-02_25977
                x03: p_weekselection, //Task-02_25977
                x04: p_select_pog, //ASA-1360 issue 3
            },
            {
                dataType: "text",
            }
        );
        // When the process is done, call functions
        p.done(function (data) {
            //ASA - 1441 S
            if ($.trim(data) !== "") {
                console.log("refresh_sales_data", data);
                if ($v("P25_POGCR_SALES_INFO_REFRESH_DTL") == "Y") {
                    g_pog_json[p_pog_index].SalesRrshDtl = "Date: " + getDateTime();
                } else {
                    g_pog_json[p_pog_index].SalesRrshDtl = "Date: " + getDateTime() + " | Sales Week: " + p_weekselection + " | Store: " + p_store; //ASA - 1441
                } //ASA - 1441 E
                if (data.indexOf("Error:") >= 0 && p_bybass_alert == "N") { //ASA-1803
                    if (p_loadingind == "Y") {
                        removeLoadingIndicator(regionloadWait);
                    }
                    raise_error(data.substr(6));
                } else if (data.indexOf("Warn:") >= 0 && p_bybass_alert == "N") { //ASA-1803
                    if (p_loadingind == "Y") {
                        removeLoadingIndicator(regionloadWait);
                    }
                    alert(data.substr(5));
                    resolve("Warning" + data.substr(5));
                } else {
                    try {
                        var SalesJson = JSON.parse(data);
                        delete g_pog_json[p_pog_index]["SalesInfo"];
                        g_pog_json[p_pog_index].SalesInfo = SalesJson;
                    } catch {
                        if (p_loadingind == "Y") {
                            removeLoadingIndicator(regionloadWait);
                        }
                        if (p_showerror == "Y") {
                            raise_error(data);
                        } else {
                            resolve("success");
                        }
                    }

                    async function dosomething() {
                        if (p_daysupplylabel == "Y") {
                            await showHideDaysOfSupplyLabel(g_show_days_of_supply, "N", p_pog_index, "Y", "Y", p_fontsize, p_detailitemlist);
                        }
                        if (p_SavetoColl == "Y") {
                            var returnval = await save_pog_to_json([g_pog_json[p_pog_index]]);
                        }
                        if (p_loadingind == "Y") {
                            removeLoadingIndicator(regionloadWait);
                        }
                    }
                    dosomething();
                    if (p_dialogclose == "Y") {
                        apex.message.showPageSuccess(get_message("POGCR_SALES_REFRESH"));
                        closeInlineDialog("open_refresh_sales");
                    }
                    resolve("success");
                }
            }
        });
    });
}

function getCombinationShelf(p_pog_index, p_ShelfName) {
    try {
        logDebug("function : getCombinationShelf; p_pog_index : " + p_pog_index + "; pShelfName : " + p_ShelfName, "S");
        var currCombinationIndex = -1,
            currShelfCombIndx = -1;
        if (typeof g_combinedShelfs !== "undefined" && g_combinedShelfs.length > 0) {
            if (g_combinedShelfs.length > 0) {
                var i = 0;
                for (combination of g_combinedShelfs) {
                    var j = 0;
                    for (shelf_info of combination) {
                        if (shelf_info.Shelf == p_ShelfName && shelf_info.PIndex == p_pog_index) {
                            currCombinationIndex = i;
                            currShelfCombIndx = j;
                            break;
                        }
                        j++;
                    }
                    if (currCombinationIndex !== -1 && currShelfCombIndx !== -1) {
                        break;
                    }
                    i++;
                }
            }
        }
        return [currCombinationIndex, currShelfCombIndx];
    } catch (err) {
        logDebug("function : getCombinationShelf", "E");
        error_handling(err);
    }
}

function save_pog_to_json(p_pogjson) {
    logDebug("function : save_pog_to_json", "S");
    return new Promise(function (resolve, reject) {
        apex.server.process(
            "ADD_JSON_TO_COLL",
            {
                x01: "I",
                p_clob_01: JSON.stringify(p_pogjson),
            },
            {
                dataType: "text",
                success: function (pData) {
                    if ($.trim(pData) != "") {
                        raise_error(pData);
                    } else {
                        logDebug("function : save_pog_to_json", "E");
                        resolve("SUCESS");
                    }
                },
                loadingIndicatorPosition: "page",
            }
        );
    });
}

function delete_items_coll() {
    logDebug("function : delete_items_coll", "S");
    return new Promise(function (resolve, reject) {
        apex.server.process(
            "DELETE_ITEM_COLL",
            {
                x01: "I",
            },
            {
                dataType: "text",
                success: function (pData) {
                    if ($.trim(pData) != "") {
                        raise_error(pData);
                    } else {
                        logDebug("function : delete_items_coll", "E");
                        resolve("SUCESS");
                    }
                },
            }
        );
    });
}

/* Additional Common Functions SUNILB */

function blink_effect() {
    for (var i = 0; i < g_intersected.length; i++) {
        //ASA 1427 S
        if (g_intersected[i].blink_color == 0x000000 || g_intersected[i].blink_color == g_dim_error_color || g_intersected[i].blink_color == g_status_error_color || (g_intersected[i].blink_color == g_pogcr_oos_border_color && g_pogcr_enbl_oos_border == "Y")) {
            if (typeof g_intersected[i].ItemID != "undefined") {
                g_intersected[i].blink_color = g_select_item_color_change;
            } else {
                g_intersected[i].blink_color = 0xffffff;
            }
        } else {
            for (var i = 0; i < g_intersected.length; i++) {
                if (nvl(g_intersected[i].OOSPerc) > 80 && g_pogcr_enbl_oos_border == "Y" && (g_intersected[i].blink_color != g_dim_error_color || g_intersected[i].blink_color != g_status_error_color)) {
                    //ASA-1688 Added if to give blue border to item
                    g_intersected[i].blink_color = g_pogcr_oos_border_color;
                } else {
                    g_intersected[i].blink_color = 0x000000;
                }
            }
        }
    } //ASA 1427 E
    for (var i = 0; i < g_intersected.length; i++) {
        if (typeof g_intersected[i] !== "undefined") {
            if (g_intersected[i].ImageExists == "Y" && (g_show_live_image == "Y" || g_show_live_image_comp == "Y")) {
                g_intersected[i].WireframeObj.material.transparent = false;
                g_intersected[i].WireframeObj.material.opacity = 1;
            }
            if ((g_intersected[i].DimUpdate == "E" || g_intersected[i].Status == "N") && g_intersected[i].blink_color == 0x000000) {
                g_intersected[i].WireframeObj.material.color.setHex(g_intersected[i].BorderColour);
            } else {
                g_intersected[i].WireframeObj.material.color.setHex(g_intersected[i].blink_color); //ASA 1427 E
            }
        }
    }

    // render(g_pog_index);     //ASA-1548 Issue 1
    render_all_pog(); //ASA-1548 Issue 1
}

function reset_zoom() {
    logDebug("function : reset_zoom", "S");
    try {
        if (typeof g_pog_json !== "undefined" && g_pog_json.length > 0) {
            $(".top_icon").removeClass("active");
            $(".left_icon").removeClass("active");
            $("#maincanvas").css("cursor", "auto");
            $("#maincanvas1").css("cursor", "auto");
            g_manual_zoom_ind = "N";
            g_area_zoom_ind = "N";
            g_select_zoom_arr = [];
            if (g_all_pog_flag == "Y") {
                var z = 0;
            } else {
                var z = g_pog_index;
            }
            for (const pogJson of g_pog_json) {
                if (g_compare_pog_flag == "N" || (g_compare_pog_flag == "Y" && g_compare_view !== "CUTAWAY")) {
                    var details = get_min_max_xy(z);
                    var details_arr = details.split("###");
                    console.log("details_arr", details_arr, z);
                    set_camera_z(g_scene_objects[z].scene.children[0], parseFloat(details_arr[2]), parseFloat(details_arr[3]), parseFloat(details_arr[0]), parseFloat(details_arr[1]), g_offset_z, parseFloat(details_arr[4]), parseFloat(details_arr[5]), true, z);
                }

                render(z);
                if (g_all_pog_flag == "Y") {
                    z++;
                } else {
                    break;
                }
            }
            g_intersected = [];
            g_mselect_drag = "N"; //ASA-1692
            g_multiselect = "N"; //ASA-1692
        }
        logDebug("function : reset_zoom", "E");
    } catch (err) {
        error_handling(err);
    }
}

function reset_indicators() {
    if (g_show_fixel_label == "Y") {
        $(".fixel_label").addClass("fixel_label_active");
    } else {
        $(".fixel_label").removeClass("fixel_label_active");
    }
    if (g_show_item_color == "Y") {
        $(".item_color").addClass("item_label_active");
    } else {
        $(".item_color").removeClass("item_label_active");
    }
    if (g_show_item_label == "Y") {
        $(".item_label").addClass("item_label_active");
    } else {
        $(".item_label").removeClass("item_label_active");
    }
    //ASA-1182
    if (g_itemSubLabelInd == "N") {
        $(".item_sublabel").removeClass("item_sublabel_active");
        $("#item_sublbl_sub .items").removeClass("item_sublabel_active");
    } else {
        $(".item_sublabel").addClass("item_sublabel_active");
        $("#item_sublbl_sub ." + g_itemSubLabel).addClass("item_sublabel_active");
    }
    if (g_show_fixel_space == "Y") {
        $(".fixel_space").addClass("item_label_active");
    } else {
        $(".fixel_space").removeClass("item_label_active");
    }
    if (g_show_item_desc == "Y" && g_show_live_image == "N") {
        $(".item_desc").addClass("item_label_active");
    } else {
        $(".item_desc").removeClass("item_label_active");
    }
    if (g_show_notch_label == "Y") {
        $(".notch_label").addClass("notch_label_active");
    } else {
        $(".notch_label").removeClass("notch_label_active");
    }
    if (g_show_live_image == "Y") {
        $(".live_image").addClass("live_image_active");
    } else {
        $(".live_image").removeClass("live_image_active");
    }
    if (g_show_max_merch == "Y") {
        $(".fixel_merch").addClass("max_merch_active");
    } else {
        $(".fixel_merch").removeClass("max_merch_active");
    }
    if (g_max_facing_enabled == "Y") {
        $(".max_facing").addClass("enable_maximize_facings");
    } else {
        $(".max_facing").removeClass("enable_maximize_facings");
    }
    if (g_show_days_of_supply == "Y") {
        $(".supply_days").addClass("item_label_active");
    } else {
        $(".supply_days").removeClass("item_label_active");
    }
    if (g_show_item_color == "Y") {
        $(".item_color_legends").css("display", "block");
    } else {
        $(".item_color_legends").css("display", "none");
    }
    //ASA-1138
    if (g_overhung_shelf_active == "Y") {
        $(".overhung_shelf").addClass("overhung_shelf_active");
    } else {
        $(".overhung_shelf").removeClass("overhung_shelf_active");
    }
    logDebug("function : reset_indicators", "E");
}

function set_multi_blink(p_pog_json, p_pog_index) {
    logDebug("function : set_multi_blink", "S");
    if (typeof p_pog_json !== "undefined" && p_pog_json.length > 0 && g_delete_details.length > 0) {
        if (g_intersected) {
            for (var i = 0; i < g_intersected.length; i++) {
                g_select_color = g_intersected[i].BorderColour;
                g_intersected[i].WireframeObj.material.color.setHex(g_intersected[i].BorderColour);
                if (g_intersected[i].ImageExists == "Y" && (g_show_live_image == "Y" || g_show_live_image_comp == "Y")) {
                    g_intersected[i].WireframeObj.material.transparent = true;
                    g_intersected[i].WireframeObj.material.opacity = 0.0025;
                }
            }
        }
        g_intersected = [];
        if (typeof g_delete_details !== "undefined") {
            $.each(g_delete_details, function (j, details) {
                var selectedObject = g_scene_objects[p_pog_index].scene.children[2].getObjectById(details.ObjID);
                g_intersected.push(selectedObject);
            });
            render_animate_selected();
        }
    }
    logDebug("function : set_multi_blink", "E");
}

function render_animate_selected() {
    //ASA-1640 Start
    if (g_product_list_blink == "Y") {
        var productList = [];
        for (const item of g_intersected) {
            if (nvl(item.ItemID) != 0) {
                productList.push(item.ItemID);
            }
        }
        productList = [...new Set(productList)];
        $("#draggable_table .product_list_blink").removeClass("product_list_blink");

        //ASA-1766 Issue 1
        let productColIndex = -1;
        $("#draggable_table thead th").each(function (index) {
            if ($(this).text().trim().toLowerCase() === "product") {
                productColIndex = index;
                return false; // Break loop
            }
        });

        if (productColIndex !== -1) {
            for (const product of productList) {
                $('#draggable_table [data-id="' + product + '"] td')
                    .eq(productColIndex)
                    .addClass("product_list_blink");
            }
        }
        //ASA-1766 Issue 1 ends
    }
    //ASA-1640 End
    clearInterval(g_myVar);
    g_myVar = setInterval(function () {
        blink_effect();
    }, 500);
}

function download_pog_pdf(p_pog_code, p_pog_version) {
    logDebug("function : download_pog_pdf", "S");
    try {
        var l_url = "f?p=" + $v("pFlowId") + ":" + $v("pFlowStepId") + ":" + $v("pInstance") + ":APPLICATION_PROCESS=DOWNLOAD_POG_PDF:NO::AI_RANDOM_STRING,AI_POG_CODE,AI_POG_VERSION:" + new Date().getTime() + "," + p_pog_code + "," + p_pog_version;
        const a = document.createElement("a");
        a.href = l_url;
        a.download = "";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        logDebug("function : download_pog_pdf", "E");
    } catch (err) {
        error_handling(err);
        removeLoadingIndicator(regionloadWait);
    }
}

async function get_full_canvas(p_pog_index, p_scale) {
    try {
        var header = document.getElementById("t_Header");
        var top_bar = document.getElementById("top_bar");
        var side_nav = document.getElementById("t_Body_nav");
        var button_cont = document.getElementById("side_bar");
        var devicePixelRatio = window.devicePixelRatio;
        var header_height = header !== null ? header.offsetHeight * devicePixelRatio : 0;
        var top_bar_height = top_bar !== null ? top_bar.offsetHeight * devicePixelRatio : 0;
        var side_nav_width = side_nav !== null ? side_nav.offsetWidth * devicePixelRatio : 0;
        var btn_cont_width = button_cont !== null ? button_cont.offsetWidth * devicePixelRatio : 0;

        var main_canvas = document.createElement("canvas");

        g_windowHeight = window.innerHeight - (header_height + top_bar_height);
        windowWidth = window.innerWidth - (side_nav_width + btn_cont_width);
        main_canvas.width = windowWidth * p_scale;
        main_canvas.height = g_windowHeight * p_scale;

        g_camera = g_scene_objects[p_pog_index].scene.children[0];
        g_scene_objects[p_pog_index].scene.children[0].aspect = main_canvas.width / main_canvas.height;
        g_scene_objects[p_pog_index].scene.children[0].updateProjectionMatrix();
        var details = get_min_max_xy(p_pog_index);
        var details_arr = details.split("###");
        set_camera_z(g_camera, parseFloat(details_arr[2]), parseFloat(details_arr[3]), parseFloat(details_arr[0]), parseFloat(details_arr[1]), g_offset_z, parseFloat(details_arr[4]), parseFloat(details_arr[5]), true, p_pog_index);

        var context = main_canvas.getContext("2d");
        context.imageSmoothingEnabled = true; // Enable anti-aliasing
        g_renderer.setPixelRatio(window.devicePixelRatio);
        var canvas_width = main_canvas.width;
        var canvas_height = main_canvas.height;

        g_renderer.setSize(canvas_width, canvas_height);
        g_renderer.render(g_scene_objects[p_pog_index].scene, g_scene_objects[p_pog_index].scene.children[0]);
        context.drawImage(g_renderer.domElement, 0, 0, canvas_width, canvas_height);
        g_scene_objects[p_pog_index].scene.children[0].aspect = g_canvas_objects[p_pog_index].width / g_canvas_objects[p_pog_index].height;
        g_scene_objects[p_pog_index].scene.children[0].updateProjectionMatrix();
        return main_canvas;
    } catch (err) {
        //Start ASA1310_20240307 crush item onload
        error_handling(err);
        throw err;
    }
}

//Start Sprint 20240122 - Regression Issue 10
async function get_chest_split_details(p_pogcr_pdf_chest_split, p_pog_index) {
    try {
        var pogChests = [];
        var mIndex = 0;
        if (p_pogcr_pdf_chest_split == "Y") {
            for (const modules of g_pog_json[p_pog_index].ModuleInfo) {
                if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                    modules.ChestInfo = []; //Bug-26122 - splitting the chest
                    var sIndex = 0;
                    var moduleStart = wpdSetFixed(modules.X - modules.W / 2); //.toFixed(4));
                    var moduleEnd = wpdSetFixed(modules.X + modules.W / 2); //.toFixed(4));
                    for (const shelf of modules.ShelfInfo) {
                        g_pog_json[p_pog_index].ModuleInfo[mIndex].ShelfInfo[sIndex].SplitChest = "N"; //Bug-26122 - splitting the chest
                        if (shelf.ObjType == "CHEST") {
                            var shelfStart = wpdSetFixed(shelf.X - shelf.W / 2); //.toFixed(4));
                            var shelfEnd = wpdSetFixed(shelf.X + shelf.W / 2); //.toFixed(4));
                            if ((moduleStart >= shelfStart && moduleEnd < shelfEnd) || (moduleStart >= shelfStart && moduleEnd < shelfEnd) || (moduleStart <= shelfStart && moduleEnd < shelfEnd && moduleEnd > shelfStart) || (moduleStart >= shelfStart && moduleEnd > shelfEnd && moduleStart < shelfEnd)) {
                                //Regression-10 issue for chest pdf, added =
                                shelf.MIndex = mIndex;
                                shelf.SIndex = sIndex;
                                pogChests.push(shelf);
                                g_pog_json[p_pog_index].ModuleInfo[mIndex].ShelfInfo[sIndex].SplitChest = "Y";
                                //g_pog_json[p_pog_index].ModuleInfo[mIndex].ShelfInfo.splice(sIndex, 1);//Bug-26122 - splitting the chest
                            }
                        }
                        sIndex++;
                    }
                }
                mIndex++;
            }

            var ci = 0; //ASA-1314
            for (chest of pogChests) {
                // update g_pog_json modules with individual chest and updated item info
                var chestStart = wpdSetFixed(chest.X - chest.W / 2); //.toFixed(4));
                var chestEnd = wpdSetFixed(chest.X + chest.W / 2); //.toFixed(4));
                var chestItems = chest.ItemInfo;
                var mi = 0;
                var module_no = 0;
                for (const modules of g_pog_json[p_pog_index].ModuleInfo) {
                    if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                        var chest_insert = "N"; //ASA-1306
                        var mStart = wpdSetFixed(modules.X - modules.W / 2); //.toFixed(4));
                        var mEnd = wpdSetFixed(modules.X + modules.W / 2); //.toFixed(4));
                        var newChest = JSON.parse(JSON.stringify(chest));

                        if (mStart >= chestStart && mEnd <= chestEnd) {
                            //Regression-10 issue for chest pdf, added =//ASA-1351 issue 5
                            chest_insert = "Y"; //ASA-1306
                            newChest.W = modules.W;
                            newChest.X = modules.X;
                        } else if (mStart <= chestStart && mEnd <= chestEnd && mEnd > chestStart) {
                            //ASA-1351 issue 5
                            chest_insert = "Y";
                            newChest.W = wpdSetFixed(mEnd - chestStart); //.toFixed(4));
                            newChest.X = wpdSetFixed(chestStart + newChest.W / 2); //.toFixed(4));
                        } else if (mStart >= chestStart && mEnd >= chestEnd && mStart < chestEnd) {
                            //ASA-1351 issue 5
                            chest_insert = "Y"; //ASA-1306
                            newChest.W = wpdSetFixed(chestEnd - mStart); //.toFixed(4));
                            newChest.X = wpdSetFixed(mStart + newChest.W / 2); //.toFixed(4));
                        }
                        var newChestItems = [];
                        var newChestStart = wpdSetFixed(newChest.X - newChest.W / 2); //.toFixed(4));
                        var newChestEnd = wpdSetFixed(newChest.X + newChest.W / 2); //.toFixed(4));
                        module_no = chest.MIndex + 1; //ASA-1314 it was using mi before
                        for (items of chestItems) {
                            if (items.X >= newChestStart && items.X <= newChestEnd) {
                                items.ModuleNo = module_no; //ASA-1314
                                newChestItems.push(items);
                            }
                        }
                        if (chest_insert == "Y") {
                            //ASA-1306
                            newChestItems.sort(function (a, b) {
                                var aNum = parseInt(a.LocID);
                                var bNum = parseInt(b.LocID);
                                return aNum - bNum;
                            });
                            newChest.ItemInfo = newChestItems;
                            newChest.SplitChest = "Y";
                            g_pog_json[p_pog_index].ModuleInfo[mi].ChestInfo.push(newChest); //Bug-26122 - splitting the chest
                        }
                    }
                    mi++;
                }
                ci++;
            }
        }
        return "SUCCESS";
    } catch (err) {
        //Start ASA1310_20240307 crush item onload
        error_handling(err);
        throw err;
    }
}
//End Sprint 20240122 - Regression Issue 10

function get_sales_info(p_pog_index, p_item) {
	try {
		var SalesObj = {
			LeadTime: 0,
			SalesAmt: 0,
			VRM: 0,
			GP: 0,
			BEI: 0,
			MarkDown: 0,
			ShrinkageAmt: 0,
			SalesUnit: 0,
			SalesPerWeek: 0,
			SalesUnitPerWeek: 0,
			NonShrinkageAmt: 0,
			ASP: 0,
			VRMPer: "0%",
			GPPer: "0%",
			BEIPer: "0%",
			MarkDownPer: "0%",
			ShrinkageAmtPer: "0%",
			//ASA-1360 task 1 start
			AvgSalesPerWeek: 0,
			AvgQtyPerWeek: 0,
			SalesPartPer: "0%",
			QtyPartPer: "0%",
			NoOfListing: 0,
			//ASA-1360 task 1 end
			TotalShrinkageAmtPer: "0%", //ASA-1407 Task 1
            //ASA1923 Added tag
            AUR: 0, 
            WeeklySales: 0,
            WeeklyQty: 0,
            NetMarginPercent:"0%",
		};
		var SalesFound = false;
		if (typeof g_pog_json[p_pog_index].SalesInfo !== "undefined" && g_pog_json[p_pog_index].SalesInfo.length > 0) {
			for (ItemSales of g_pog_json[p_pog_index].SalesInfo) {
				if (ItemSales.Item == p_item) {
					SalesObj = {
						LeadTime: ItemSales.LeadTime,
						SalesAmt: parseFloat(nvl(ItemSales.SalesAmt).toFixed(1)), //ASA-1775  nvl handling because of toFixed getting error
						VRM: parseFloat(nvl(ItemSales.VRM).toFixed(1)),
						GP: parseFloat(nvl(ItemSales.GP).toFixed(2)), //ASA-1360 task 1
						BEI: ItemSales.BEI,
						MarkDown: ItemSales.MarkDown,
						ShrinkageAmt: parseFloat(nvl(ItemSales.ShrinkageAmt).toFixed(1)),
						SalesUnit: ItemSales.SalesUnit,
						SalesPerWeek: parseFloat(nvl(ItemSales.SalesPerWeek).toFixed(1)),
						SalesUnitPerWeek: parseFloat(nvl(ItemSales.SalesUnitPerWeek).toFixed(1)),
						NonShrinkageAmt: parseFloat(nvl(ItemSales.NonShrinkageAmt).toFixed(1)),
						//ASA-1360 task 1
						ASP: typeof ItemSales.ASP !== "undefined" && ItemSales.ASP !== "" && ItemSales.ASP !== null && ItemSales.ASP !== 0 ? parseFloat(nvl(ItemSales.ASP).toFixed(2)) : ItemSales.SalesUnit == 0 ? 0 : parseFloat((nvl(ItemSales.SalesAmt) / nvl(ItemSales.SalesUnit)).toFixed(1)), //ASA-1360 task 1 start,//ASA-1407 issue 5
						VRMPer: (nvl(ItemSales.SalesAmt) == 0 ? 0 : parseFloat(((nvl(ItemSales.VRM) / nvl(ItemSales.SalesAmt)) * 100).toFixed(1))) + "%",
						GPPer: (nvl(ItemSales.SalesAmt) == 0 ? 0 : parseFloat(((nvl(ItemSales.GP) / nvl(ItemSales.SalesAmt)) * 100).toFixed(1))) + "%",
						BEIPer: (nvl(ItemSales.SalesAmt) == 0 ? 0 : parseFloat(((nvl(ItemSales.BEI) / nvl(ItemSales.SalesAmt)) * 100).toFixed(1))) + "%",
						MarkDownPer: (nvl(ItemSales.SalesAmt) == 0 ? 0 : parseFloat(((nvl(ItemSales.MarkDown) / nvl(ItemSales.SalesAmt)) * 100).toFixed(1))) + "%",
						ShrinkageAmtPer: (nvl(ItemSales.SalesAmt) == 0 ? 0 : parseFloat(((nvl(ItemSales.ShrinkageAmt) / nvl(ItemSales.SalesAmt)) * 100).toFixed(1))) + "%",
						//ASA-1360 task 1 start
						// ASA-1452
						AvgSalesPerWeek: parseFloat(nvl(ItemSales.AvgSalesPerWeek).toFixed(1)),
						AvgQtyPerWeek: parseFloat(nvl(ItemSales.AvgQtyPerWeek).toFixed(1)),
						SalesPartPer: parseFloat(nvl(ItemSales.SalesPartPer).toFixed(1)) + "%",
						QtyPartPer: parseFloat(nvl(ItemSales.QtyPartPer).toFixed(1)) + "%",
						NoOfListing: parseFloat(nvl(ItemSales.NoOfListing).toFixed(1)),
						//ASA-1360 task 1 end
						TotalShrinkageAmtPer: (nvl(ItemSales.SalesAmt) == 0 ? 0 : parseFloat((((nvl(ItemSales.ShrinkageAmt) + nvl(ItemSales.NonShrinkageAmt)) / nvl(ItemSales.SalesAmt)) * 100).toFixed(1))) + "%", //ASA-1407 Task 1
                        //ASA1923 Added tag
                        AUR: parseFloat(nvl(ItemSales.AUR).toFixed(1)), 
                        WeeklySales: parseFloat(nvl(ItemSales.weeklysales).toFixed(1)),
                        WeeklyQty: parseFloat(nvl(ItemSales.weeklyqty).toFixed(1)),
                        NetMarginPercent: parseFloat(nvl(ItemSales.netmarginpercent).toFixed(1)) + "%",
					};
					SalesFound = true;
					break;
				}
			}
		}
		if (!SalesFound) {
			for (const modules of g_pog_json[p_pog_index].ModuleInfo) {
				if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
					for (const shelfs of modules.ShelfInfo) {
						if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX") {
							if (shelfs.ItemInfo.length > 0) {
								for (const items of shelfs.ItemInfo) {
									if (items.Item !== "DIVIDER" && items.Desc !== "" && typeof items.Desc !== "undefined") {
										if (items.Item == p_item) {
											SalesObj = {
												LeadTime: 0,
												SalesAmt: parseFloat(items.NetSales.toFixed(1)),
												VRM: 0,
												GP: items.GrossProfit,
												BEI: 0,
												MarkDown: 0,
												ShrinkageAmt: 0,
												SalesUnit: items.SalesUnit,
												SalesPerWeek: 0,
												SalesUnitPerWeek: 0,
												NonShrinkageAmt: 0,
												ASP: items.SalesUnit == 0 ? 0 : parseFloat((items.NetSales / items.SalesUnit).toFixed(1)), //ASA-1360 need to check on this.
												VRMPer: "0%",
												GPPer: (items.NetSales == 0 ? 0 : parseFloat(((items.GrossProfit / items.NetSales) * 100).toFixed(1))) + "%",
												BEIPer: "0%",
												MarkDownPer: "0%",
												ShrinkageAmtPer: "0%",
												//ASA-1360 task 1 start
												AvgSalesPerWeek: 0,
												AvgQtyPerWeek: 0,
												SalesPartPer: "0%",
												QtyPartPer: "0%",
												NoOfListing: 0,
												//ASA-1360 task 1 end
												TotalShrinkageAmtPer: "0%", //ASA-1407 Task 1
                                                //ASA1923 Added tag
                                                AUR: 0, 
                                                WeeklySales: 0,
                                                WeeklyQty: 0,
                                                NetMarginPercent: "0%",
											};
											SalesFound = true;
											break;
										}
									}
								}
							}
						}
					}
				}
			}
		}

		return SalesObj;
	} catch (err) {
		error_handling(err);
		throw err;
	}
}

//Start ASA-1351 -- calculate depth facings on load it is needed to do auto depth facing calc
function maximizeItemDepthFacings(p_facingType, p_moduleIndex, p_shelfIndex, p_itemIndex, p_pog_index) {
    try {
        var module = g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex]; //ASA-1273 PrasANNA
        var shelf_info = g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex];
        var item_info = g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex].ItemInfo[p_itemIndex];
        var max_depth = findNearByShelfMaxDepth(p_moduleIndex, p_shelfIndex, p_itemIndex, p_itemIndex, -1, p_pog_index);
        //var max_merch = get_max_merch(p_moduleIndex, p_shelfIndex, p_itemIndex, "Y", -1, p_pog_index); //ASA-1273
        var depth_facing = 1;

        var spread_product = shelf_info.SpreadItem;
        var ShelfhorizGap = shelf_info.HorizGap;
        var nesting_value = item_info.NVal;
        var nesting_type = typeof item_info.ItemNesting !== "undefined" && item_info.ItemNesting !== "" ? item_info.ItemNesting : "";
        var ItemHorizGap = item_info.HorizGap;
        if (shelf_info.ObjType == "SHELF" || (shelf_info.ObjType == "HANGINGBAR" && g_auto_hangbar_facings == "Y") || (shelf_info.ObjType == "PEGBOARD" && shelf_info.AutoFillPeg == "Y") || shelf_info.ObjType == "CHEST") {
            if (!(item_info.TopObjID !== "" && typeof item_info.TopObjID !== "undefined" && item_info.BottomObjID !== "" && typeof item_info.BottomObjID !== "undefined") && item_info.Item !== "DIVIDER") {
                // ASA-1265
                if (g_auto_cal_depth_fac == "Y") {
                    //ASA-1255
                    if (p_facingType == "D" || p_facingType == "B") {
                        var shelf_depth;
                        // var real_depth = item_info.RD.toFixed(4) / item_info.BaseD;
                        var real_depth = wpdSetFixed(item_info.RD / item_info.BaseD);
                        if (item_info.MDepthCrushed == "Y" && item_info.CrushD > 0) {
                            real_depth = real_depth - real_depth * (item_info.CrushD / 100);
                        }
                        if (shelf_info.ObjType == "HANGINGBAR") {
                            shelf_depth = shelf_info.MaxMerch == 0 || shelf_info.MaxMerch == "" ? g_hangbar_dft_maxmerch : shelf_info.MaxMerch;
                        } else if (shelf_info.ObjType == "PEGBOARD") {
                            shelf_depth = shelf_info.MaxMerch == 0 || shelf_info.MaxMerch == "" ? g_pegboard_dft_item_depth : shelf_info.MaxMerch;
                        } else if (shelf_info.ObjType == "CHEST") {
                            shelf_depth = shelf_info.BsktWallH; //ASA-1178
                        } else {
                            shelf_depth = shelf_info.D;
                        }
                        var maxDepthForNesting = shelf_depth - max_depth - real_depth;
                        var l_dfacing = nvl(item_info.MPogDepthFacings) > 0 ? item_info.MPogDepthFacings : item_info.MDepthFacings; //ASA-1408 Issue 11
                        if (spread_product !== "F" && ShelfhorizGap == 0 && ItemHorizGap == 0 && nesting_value !== 0 && nesting_type !== "" && item_info.ItemNesting == "D") {
                            depth_facing = Math.floor((maxDepthForNesting * 100) / (nesting_value * 100)) + 1; //ASA-1519 Issue 4, need to add 1 for default facing
                            // depth_facing = item_info.MDepthFacings < depth_facing && item_info.MDepthFacings > -1 ? item_info.MDepthFacings : depth_facing; //ASA-874 //ASA-1408 Issue 11
                            depth_facing = l_dfacing < depth_facing && l_dfacing > -1 ? l_dfacing : depth_facing; //ASA-1408 Issue 11
                            g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex].ItemInfo[p_itemIndex].D = real_depth + (depth_facing > 0 ? depth_facing : 1) * nesting_value;
                        } else {
                            depth_facing = Math.floor((wpdSetFixed(shelf_depth - max_depth) * 100) / (real_depth * 100)); //ASA-1301
                            // depth_facing = item_info.MDepthFacings < depth_facing && item_info.MDepthFacings > -1 ? item_info.MDepthFacings : depth_facing; //ASA-874 //ASA-1408 Issue 11
                            depth_facing = l_dfacing < depth_facing && l_dfacing > -1 ? l_dfacing : depth_facing; //ASA-1408 Issue 11
                            g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex].ItemInfo[p_itemIndex].D = real_depth * (depth_facing > 0 ? depth_facing : 1);
                        }
                        g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex].ItemInfo[p_itemIndex].RD = wpdSetFixed((item_info.RD / item_info.BaseD) * (depth_facing > 0 ? depth_facing : 1));
                        if (shelf_info.ObjType == "CHEST") {
                            var chestItemDFacing = l_dfacing < Math.trunc(shelf_info.BsktWallH / real_depth) && l_dfacing > -1 ? l_dfacing : Math.trunc(shelf_info.BsktWallH / real_depth); //ASA-1272 ISSUE-7 //ASA-1408 Issue 11
                            g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex].ItemInfo[p_itemIndex].BaseD = chestItemDFacing; //ASA-1272 ISSUE-7 //ASA-1408 Issue 11
                        } else {
                            g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex].ItemInfo[p_itemIndex].BaseD = depth_facing > 0 ? depth_facing : 1;
                        }

                        //ASA-1273 Prasanna start
                        var items = g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex].ItemInfo[p_itemIndex];
                        var cap_orientation = items.CapOrientaion == "" ? "4" : items.CapOrientaion;
                        var [cap_width, cap_height, cap_depth] = get_cap_dim(items);

                        var [cWidth, cHeight, cDepth, capActualHeight, capActualWidth, capActualDepth] = get_new_orientation_dim(cap_orientation, cap_width, cap_height, cap_depth);
                        if (items.CapDepthChanged == "N" || typeof items.CapDepthChanged == "undefined") {
                            //ASA-1273
                            g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex].ItemInfo[p_itemIndex].CapDepth = Math.trunc(item_info.RD / cDepth);
                        } //ASA-1273 End
                    }
                }
            }
        }
    } catch (err) {
        //Start ASA1310_20240307 crush item onload
        error_handling(err);
        throw err;
    }
}

function findNearByShelfMaxDepth(p_module_index, p_shelf_index, p_item_index, p_edit_ind, p_locationX, p_pog_index) {
    logDebug("function : findNearByShelfMaxDepth; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index + "; i_item_index : " + p_item_index + "; p_edit_ind : " + p_edit_ind + "; locationX : " + p_locationX, "S");
    try {
        var item_start = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].X - g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].W / 2;
        var item_end = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].X + g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].W / 2;
        // var item_top = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].Y + g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].H / 2;
        // var item_bottom = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].Y - g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].H / 2;

        var item_top; //ASA-1410 Issue 13
        var item_bottom;

        if ((g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapStyle == "1" || g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapStyle == "2" || g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapStyle == "3") && g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ObjType == "SHELF") {
            var item_top = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].Y + g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].RH / 2;
            var item_bottom = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].Y - g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].RH / 2;
        } else {
            var item_top = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].Y + g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].H / 2;
            var item_bottom = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].Y - g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].H / 2;
        }

        var currentShelf = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].Shelf;
        var l_object_type = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ObjType; //ASA-1262 3 PRASANNA
        var shelvesInRange = [];
        var l_max_depth = 0;
        //  if (g_overhung_shelf_active == "N") { //ASA-1262 3 Prasanna
        if (g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo.length > 1) {
            if (l_object_type == "SHELF") {
                $.each(g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo, function (i, Shelf) {
                    if (Shelf.ObjType !== "BASE" && Shelf.ObjType !== "NOTCH" && Shelf.ObjType !== "DIVIDER" && Shelf.ObjType !== "TEXTBOX") {
                        if (Shelf.Rotation !== 0 || Shelf.Slope !== 0) {
                            var div_shelf_end = parseFloat((Shelf.X + Shelf.ShelfRotateWidth / 2).toFixed(3));
                            var div_shelf_start = parseFloat((Shelf.X - Shelf.ShelfRotateWidth / 2).toFixed(3));
                        } else {
                            var div_shelf_end = parseFloat((Shelf.X + Shelf.W / 2).toFixed(3));
                            var div_shelf_start = parseFloat((Shelf.X - Shelf.W / 2).toFixed(3));
                        }
                        var shelfY = Shelf.Y;
                        var shelf_top = Shelf.Y + Shelf.H / 2;
                        if (((item_start >= div_shelf_start && item_start < div_shelf_end) || (item_end <= div_shelf_end && item_end > div_shelf_start)) && item_top >= shelfY && currentShelf != Shelf.Shelf && item_bottom < shelf_top) {
                            shelvesInRange.push(parseFloat(Shelf.D.toFixed(4)));
                        }
                    }
                });
            }
        }
        if (shelvesInRange.length > 0) {
            l_max_depth = Math.max.apply(Math, shelvesInRange);
        }
        //  } else { //ASA-1262 3 PRASANNA
        //     l_max_depth = 0;
        //  }
        logDebug("function : findNearByShelfMaxDepth", "E");
        return l_max_depth;
    } catch (err) {
        error_handling(err);
    }
}

//ASA-1442 issue 7 S
function onload_findNearByShelfMaxDepth(p_module_index, p_shelf_index, p_item_index, p_edit_ind, p_locationX, p_pog_index, p_pog_json) {
    logDebug("function : findNearByShelfMaxDepth; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index + "; i_item_index : " + p_item_index + "; p_edit_ind : " + p_edit_ind + "; locationX : " + p_locationX, "S");
    try {
        var item_start = p_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].X - p_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].W / 2;
        var item_end = p_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].X + p_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].W / 2;
        var item_top = p_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].Y + p_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].H / 2;
        var item_bottom = p_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].Y - p_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].H / 2;
        var currentShelf = p_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].Shelf;
        var l_object_type = p_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ObjType; //ASA-1262 3 PRASANNA
        var shelvesInRange = [];
        var l_max_depth = 0;
        //  if (g_overhung_shelf_active == "N") { //ASA-1262 3 Prasanna
        if (p_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo.length > 1) {
            if (l_object_type == "SHELF") {
                $.each(p_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo, function (i, Shelf) {
                    if (Shelf.ObjType !== "BASE" && Shelf.ObjType !== "NOTCH" && Shelf.ObjType !== "DIVIDER" && Shelf.ObjType !== "TEXTBOX") {
                        if (Shelf.Rotation !== 0 || Shelf.Slope !== 0) {
                            var div_shelf_end = wpdSetFixed(Shelf.X + Shelf.ShelfRotateWidth / 2); //.toFixed(3));
                            var div_shelf_start = wpdSetFixed(Shelf.X - Shelf.ShelfRotateWidth / 2); //.toFixed(3));
                        } else {
                            var div_shelf_end = wpdSetFixed(Shelf.X + Shelf.W / 2); //.toFixed(3));
                            var div_shelf_start = wpdSetFixed(Shelf.X - Shelf.W / 2); //.toFixed(3));
                        }
                        var shelfY = Shelf.Y;
                        var shelf_top = Shelf.Y + Shelf.H / 2;
                        if (((item_start >= div_shelf_start && item_start < div_shelf_end) || (item_end <= div_shelf_end && item_end > div_shelf_start)) && item_top >= shelfY && currentShelf != Shelf.Shelf && item_bottom < shelf_top) {
                            shelvesInRange.push(wpdSetFixed(Shelf.D)); //.toFixed(4)));
                        }
                    }
                });
            }
        }
        if (shelvesInRange.length > 0) {
            l_max_depth = Math.max.apply(Math, shelvesInRange);
        }
        //  } else { //ASA-1262 3 PRASANNA
        //     l_max_depth = 0;
        //  }
        logDebug("function : findNearByShelfMaxDepth", "E");
        return l_max_depth;
    } catch (err) {
        //Start ASA1310_20240307 crush item onload
        error_handling(err);
        throw err;
    }
}
//ASA-1442 issue 7 E
//ASA-1273 Start Prasanna
function get_cap_dim(p_items) {
    try {
        var cap_width = 0,
            cap_height = 0,
            cap_depth = 0;
        var cap_merch = p_items.CapMerch == "" ? "0" : p_items.CapMerch;
        if (cap_merch == "0") {
            if (wpdSetFixed(p_items.UW) !== wpdSetFixed(p_items.OrgUW) || wpdSetFixed(p_items.UH) !== wpdSetFixed(p_items.OrgUH) || wpdSetFixed(p_items.UD) !== wpdSetFixed(p_items.OrgUD)) {
                cap_width = p_items.OrgUW;
                cap_height = p_items.OrgUH;
                cap_depth = p_items.OrgUD;
            } else {
                cap_width = p_items.UW;
                cap_height = p_items.UH;
                cap_depth = p_items.UD;
            }
        } else if (cap_merch == "2") {
            if (wpdSetFixed(p_items.CW) !== wpdSetFixed(p_items.OrgCW) || wpdSetFixed(p_items.CH) !== wpdSetFixed(p_items.OrgCH) || wpdSetFixed(p_items.CD) !== wpdSetFixed(p_items.OrgCD)) {
                cap_width = p_items.OrgCW;
                cap_height = p_items.OrgCH;
                cap_depth = p_items.OrgCD;
            } else {
                cap_width = p_items.CW;
                cap_height = p_items.CH;
                cap_depth = p_items.CD;
            }
        } else if (cap_merch == "1") {
            if (wpdSetFixed(p_items.TW) !== wpdSetFixed(p_items.OrgTW) || wpdSetFixed(p_items.TH) !== wpdSetFixed(p_items.OrgTH) || wpdSetFixed(p_items.TD) !== wpdSetFixed(p_items.OrgTD)) {
                cap_width = p_items.OrgTW;
                cap_height = p_items.OrgTH;
                cap_depth = p_items.OrgTD;
            } else {
                cap_width = p_items.TW;
                cap_height = p_items.TH;
                cap_depth = p_items.TD;
            }
        } else if (cap_merch == "3") {
            if (wpdSetFixed(p_items.DW) !== wpdSetFixed(p_items.OrgDW) || wpdSetFixed(p_items.DH) !== wpdSetFixed(p_items.OrgDH) || wpdSetFixed(p_items.DD) !== wpdSetFixed(p_items.OrgDD)) {
                cap_width = wpdSetFixed(p_items.OrgDW);
                cap_height = wpdSetFixed(p_items.OrgDH);
                cap_depth = wpdSetFixed(p_items.OrgDD);
            } else {
                cap_width = wpdSetFixed(p_items.DW);
                cap_height = wpdSetFixed(p_items.DH);
                cap_depth = wpdSetFixed(p_items.DD);
            }
        }
        return [cap_width, cap_height, cap_depth];
    } catch (err) {
        //Start ASA1310_20240307 crush item onload
        error_handling(err);
        throw err;
    }
} //ASA-1273 End

//Start ASA1310_20240307 crush item onload
function get_shelf_max_merch(p_modules, p_shelf, p_module_index, p_shelf_index, p_pog_index, p_default_max_merch) {
    logDebug("function : get_shelf_max_merch; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index, "S");
    try {
        var max_merch = 0;
        if (p_shelf.X >= p_modules.X - p_modules.W / 2 && p_shelf.X < p_modules.X + p_modules.W / 2 && p_shelf.Y <= p_modules.H + g_pog_json[p_pog_index].BaseH && p_shelf.Y > 0) {
            var max_merch = get_module_max_merch(p_module_index, p_shelf_index, p_pog_index);
        } else if (p_shelf.Y < p_modules.H + g_pog_json[p_pog_index].BaseH && p_shelf.Y > 0) {
            var max_merch = p_modules.H + g_pog_json[p_pog_index].BaseH - p_shelf.Y;
        } else {
            var max_merch = p_default_max_merch;
        }
        if (max_merch > p_shelf.MaxMerch && p_shelf.MaxMerch > 0) {
            max_merch = p_shelf.MaxMerch;
        }
        logDebug("function : get_shelf_max_merch", "E");
        return max_merch;
    } catch (err) {
        error_handling(err);
        throw err;
    }
}

function get_module_max_merch(p_module_index, p_shelf_index, p_pog_index, p_byPassMedicineOverhung = "N", p_item_index = 0 /*ASA-1892 Issue2 added p_item_index*/) {
    // Regression 2 added p_byPassMedicineOverhung
    try {
        var l_max_merch = 0;
        var basket_height = 0;
        var l_first_max = 0;
        var l_min_merch = 0;
        var index_arr = [];
        var moduledtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index];
        var shelfdtl = moduledtl.ShelfInfo[p_shelf_index];
        var itemdtl = shelfdtl.ItemInfo[p_item_index]; //ASA-1892 Issue2
        var item_start = wpdSetFixed(itemdtl?.X - itemdtl?.W / 2); //ASA-1892 Issue2
        var item_end = wpdSetFixed(itemdtl?.X + itemdtl?.W / 2); //ASA-1892 Issue2

        var l_object_type = shelfdtl.ObjType;

        if (shelfdtl.MaxMerch !== 0) {
            l_first_max = shelfdtl.MaxMerch;
        }
        var shelf_y = shelfdtl.Y + shelfdtl.H / 2;
        var shelf_start = wpdSetFixed(shelfdtl.X - shelfdtl.W / 2); //.toFixed(3));
        var shelf_end = wpdSetFixed(shelfdtl.X + shelfdtl.W / 2); //.toFixed(3));
        var shelf_z = wpdSetFixed(shelfdtl.Z + shelfdtl.D / 2); //ASA-1776

        var min_distance_arr = [];
        var l_max_merch = 0;
        if (l_object_type == "CHEST" || l_object_type == "BASKET") {
            basket_height = shelfdtl.BsktWallH;
        }
        if (moduledtl.ShelfInfo.length > 1) {
            if (l_object_type == "PEGBOARD") {
                min_distance_arr.push(shelfdtl.H + shelfdtl.LoOverHang);
                index_arr.push(p_shelf_index);
            } else {
                if (l_object_type == "HANGINGBAR") {
                    shelf_y = shelfdtl.Y;
                    var i = 0;
                    for (const Shelf of moduledtl.ShelfInfo) {
                        if (Shelf.ObjType !== "BASE" && Shelf.ObjType !== "NOTCH" && Shelf.ObjType !== "DIVIDER" && Shelf.ObjType !== "TEXTBOX") {
                            var div_start = wpdSetFixed(Shelf.X - Shelf.W / 2); //.toFixed(3));
                            var div_end = wpdSetFixed(Shelf.X + Shelf.W / 2); //.toFixed(3));
                            if (p_shelf_index !== i && Shelf.Y + Shelf.H / 2 < shelf_y && ((shelf_start >= div_start && shelf_start <= div_end) || (shelf_end <= div_start && shelf_end >= div_end) || (shelf_start >= div_start && shelf_end <= div_end) || (div_start >= shelf_start && div_end <= shelf_end))) {
                                min_distance_arr.push(shelf_y - (Shelf.Y + Shelf.H / 2));
                                index_arr.push(i);
                            }
                        }
                        i++;
                    }
                } else {
                    //ASA-1892 Issue2 Start
                    for (var i = 0; i < moduledtl.ShelfInfo.length; i++) {
                        const Shelf = moduledtl.ShelfInfo[i];
                        //ASA-1892 Issue1 Start
                        if (Shelf.ObjType !== "BASE" && Shelf.ObjType !== "NOTCH" && Shelf.ObjType !== "DIVIDER" && Shelf.ObjType !== "TEXTBOX") {
                            var div_end = wpdSetFixed(Shelf.X + Shelf.W / 2); //.toFixed(3));
                            var div_start = wpdSetFixed(Shelf.X - Shelf.W / 2); //.toFixed(3));
                            if (Shelf.W < moduledtl.W && (item_start > div_end || item_end < div_start)) {
                                continue;
                            }
                            //ASA-1776 -- Add one condition shelf_z <= wpdSetFixed(Shelf.Z + Shelf.D / 2)  // Regression 2 added p_byPassMedicineOverhung Condition
                            if (((shelf_z <= wpdSetFixed(Shelf.Z + Shelf.D / 2) && p_byPassMedicineOverhung == "Y") || p_byPassMedicineOverhung == "N") && p_shelf_index !== i && Shelf.Y - Shelf.H / 2 > shelf_y && Shelf.Y <= moduledtl.H + g_pog_json[p_pog_index].BaseH) {
                                min_distance_arr.push(Shelf.Y - Shelf.H / 2 - shelf_y);
                                index_arr.push(i);
                            }
                        }
                        //ASA-1892 Issue1 End
                    }
                    //ASA-1892 Issue2 End
                }
            }
            if (min_distance_arr.length == 0) {
                shelfdtl.Topmerch = "Y";
                l_max_merch = moduledtl.H + g_pog_json[p_pog_index].BaseH - shelf_y;
            } else {
                shelfdtl.Topmerch = "N"; //ASA-1729
                l_max_merch = Math.min.apply(Math, min_distance_arr);
                var index = min_distance_arr.findIndex(function (number) {
                    return number == l_max_merch;
                });
                if (moduledtl.ShelfInfo[index_arr[index]].ObjType == "HANGINGBAR") {
                }
            }
        } else {
            shelfdtl.Topmerch = "Y"; //ASA-1729
            l_max_merch = moduledtl.H + g_pog_json[p_pog_index].BaseH - shelf_y;
        }
        if (l_object_type == "CHEST" || l_object_type == "BASKET") {
            if ((l_max_merch < basket_height && basket_height > 0) || basket_height == 0) {
                l_min_merch = l_max_merch;
            } else {
                l_min_merch = basket_height;
            }
        } else {
            if ((l_max_merch < l_first_max && l_first_max > 0) || l_first_max == 0) {
                l_min_merch = l_max_merch;
            } else {
                l_min_merch = l_first_max;
            }
        }
        return wpdSetFixed(l_min_merch); //.toFixed(5)); //Task_27323 regression 7 toFixed(3) added beacuse at backend value come 0.1601 and in js 0.16 due to tofixed(3)
    } catch (err) {
        error_handling(err);
        throw err;
    }
}
////Start 20240415 Rregression issue 12 20240430
function get_onload_max_merch(p_mod_index, p_shelf_index, p_modules, p_shelfs, p_default_max_merch, p_pog_index, p_pog_json) {
    var shelf_x = p_shelfs.X;
    var shelf_y = p_shelfs.Y;
    if (p_shelfs.MaxMerch > 0) {
        var max_merch = p_shelfs.MaxMerch;
    } else if (shelf_x >= p_modules.X - p_modules.W / 2 && shelf_x < p_modules.X + p_modules.W / 2 && shelf_y <= p_modules.H + p_pog_json[p_pog_index].BaseH && shelf_y > 0) {
        var max_merch = get_onload_shelf_max_merch(p_mod_index, p_shelf_index, p_pog_index, p_pog_json);
    } else if (shelf_y < p_modules.H + p_pog_json[p_pog_index].BaseH && shelf_y > 0) {
        var max_merch = p_modules.H + p_pog_json[p_pog_index].BaseH - shelf_y;
    } else {
        var max_merch = p_default_max_merch;
    }
    return max_merch;
}

function get_onload_shelf_max_merch(p_module_index, p_shelf_index, p_pog_index, p_pog_json) {
    try {
        var l_max_merch = 0;
        var basket_height = 0;
        var l_first_max = 0;
        var l_min_merch = 0;
        var index_arr = [];
        var moduledtl = p_pog_json[p_pog_index].ModuleInfo[p_module_index];
        var shelfdtl = moduledtl.ShelfInfo[p_shelf_index];
        var l_object_type = shelfdtl.ObjType;

        if (shelfdtl.MaxMerch !== 0) {
            l_first_max = shelfdtl.MaxMerch;
        }
        var shelf_y = shelfdtl.Y + shelfdtl.H;
        var shelf_start = wpdSetFixed(shelfdtl.X); //.toFixed(3));
        var shelf_end = wpdSetFixed(shelfdtl.X + shelfdtl.W); //.toFixed(3));

        var min_distance_arr = [];
        var l_max_merch = 0;
        if (l_object_type == "CHEST" || l_object_type == "BASKET") {
            basket_height = shelfdtl.BsktWallH;
        }
        if (moduledtl.ShelfInfo.length > 1) {
            if (l_object_type == "PEGBOARD") {
                min_distance_arr.push(shelfdtl.H + shelfdtl.LoOverHang);
                index_arr.push(p_shelf_index);
            } else {
                if (l_object_type == "HANGINGBAR") {
                    shelf_y = shelfdtl.Y;
                    var i = 0;
                    for (const Shelf of moduledtl.ShelfInfo) {
                        if (Shelf.ObjType !== "BASE" && Shelf.ObjType !== "NOTCH" && Shelf.ObjType !== "DIVIDER" && Shelf.ObjType !== "TEXTBOX") {
                            var div_start = wpdSetFixed(Shelf.X); //.toFixed(3));
                            var div_end = wpdSetFixed(Shelf.X + Shelf.W); //.toFixed(3));
                            if (p_shelf_index !== i && Shelf.Y + Shelf.H < shelf_y && ((shelf_start >= div_start && shelf_start <= div_end) || (shelf_end <= div_start && shelf_end >= div_end) || (shelf_start >= div_start && shelf_end <= div_end) || (div_start >= shelf_start && div_end <= shelf_end))) {
                                min_distance_arr.push(shelf_y - (Shelf.Y + Shelf.H));
                                index_arr.push(i);
                            }
                        }
                        i++;
                    }
                } else {
                    var i = 0;
                    for (const Shelf of moduledtl.ShelfInfo) {
                        if (Shelf.ObjType !== "BASE" && Shelf.ObjType !== "NOTCH" && Shelf.ObjType !== "DIVIDER" && Shelf.ObjType !== "TEXTBOX") {
                            var div_end = wpdSetFixed(Shelf.X + Shelf.W); //.toFixed(3));
                            var div_start = wpdSetFixed(Shelf.X); //.toFixed(3));
                            if (p_shelf_index !== i && Shelf.Y - Shelf.H > shelf_y && ((div_end > shelf_start && div_start <= shelf_start) || (div_start < shelf_end && div_start >= shelf_start)) && Shelf.Y <= moduledtl.H + g_pog_json[p_pog_index].BaseH) {
                                min_distance_arr.push(Shelf.Y - shelf_y);
                                index_arr.push(i);
                            }
                        }
                        i++;
                    }
                }
            }
            if (min_distance_arr.length == 0) {
                l_max_merch = moduledtl.H + p_pog_json[p_pog_index].BaseH - shelf_y;
            } else {
                l_max_merch = Math.min.apply(Math, min_distance_arr);
                var index = min_distance_arr.findIndex(function (number) {
                    return number == l_max_merch;
                });
                if (moduledtl.ShelfInfo[index_arr[index]].ObjType == "HANGINGBAR") {
                }
            }
        } else {
            l_max_merch = moduledtl.H + p_pog_json[p_pog_index].BaseH - shelf_y;
        }
        if (l_object_type == "CHEST" || l_object_type == "BASKET") {
            if ((l_max_merch < basket_height && basket_height > 0) || basket_height == 0) {
                l_min_merch = l_max_merch;
            } else {
                l_min_merch = basket_height;
            }
        } else {
            if ((l_max_merch < l_first_max && l_first_max > 0) || l_first_max == 0) {
                l_min_merch = l_max_merch;
            } else {
                l_min_merch = l_first_max;
            }
        }
        return wpdSetFixed(l_min_merch); //.toFixed(5));
    } catch (err) {
        error_handling(err);
        throw err;
    }
}
//End 20240415 Rregression issue 12 20240430

function get_item_xy(p_shelfs, p_items, p_item_width, p_item_height, p_pog_index) {
    logDebug("function : get_item_xy; item_width : " + p_item_width + "; item_height : " + p_item_height, "S");
    try {
        var itemx = 0,
            itemy = 0;

        if (p_shelfs.ObjType == "BASKET" && p_shelfs.BsktSpreadProduct == "BT") {
            itemx = p_shelfs.X - p_shelfs.W / 2 + p_item_width / 2;
            itemy = p_shelfs.Y + p_shelfs.H / 2 + p_items.Distance + p_item_height / 2;
        } else if (p_shelfs.ObjType == "HANGINGBAR") {
            itemx = p_shelfs.X - p_shelfs.W / 2 + p_items.Distance + p_item_width / 2;
            itemy = p_shelfs.Y - p_item_height / 2;
        } else if (p_shelfs.ObjType == "ROD") {
            itemx = p_shelfs.X;
            itemy = p_shelfs.Y - p_shelfs.H / 2 - p_item_height / 2;
        } else if (p_shelfs.ObjType == "PEGBOARD" || (p_shelfs.ObjType == "CHEST" && g_chest_as_pegboard == "Y")) {
            var peg_verti_arr = p_shelfs.peg_vert_values;
            var peg_details = [];
            $.each(peg_verti_arr, function (i, details) {
                peg_details.push(p_shelfs.Y + peg_verti_arr[i]);
            });
            var item_start = p_items.Y + p_item_height / 2;
            if (peg_details.length > 0) {
                var closest = peg_details.reduce((a, b) => {
                    return Math.abs(b - item_start) < Math.abs(a - item_start) ? b : a;
                });
            }
            itemx = p_shelfs.X - p_shelfs.W / 2 + p_items.PegBoardX + p_item_width / 2;
            itemy = parseFloat(closest) - p_item_height / 2;
            if (typeof p_items.PegBoardY !== "undefined" && p_items.PegBoardY !== "") {
                itemy = p_shelfs.Y - p_shelfs.H / 2 + p_items.PegBoardY + p_item_height / 2;
            } else {
                itemy = parseFloat(closest) - p_item_height / 2;
            }
        } else {
            itemx = p_shelfs.X - p_shelfs.W / 2 + p_items.Distance + p_item_width / 2;
            itemy = p_shelfs.Y + p_shelfs.H / 2 + p_item_height / 2;
        }

        if (p_items.Item == "DIVIDER" && p_shelfs.ObjType == "BASKET") {
            itemy = g_finalY;
        }
        logDebug("function : get_item_xy", "E");
        return [wpdSetFixed(itemx), wpdSetFixed(itemy)]; //ASA-1471 issue 9
    } catch (err) {
        error_handling(err);
        throw err;
    }
}

function crushItem(p_pog_index, p_moduleIndex, p_shelfIndex, p_itemIndex, p_crushType, p_setInd, p_itemDepthArr, p_itemDepthIndxArr, p_on_load = "N") {
    //ASA-1300 //ASA-1383 issue 8
    try {
        debugger;
        var crush_index_arr = [];
        var pogModule = g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex];
        var pogShelf = g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex];
        //we are using p_on_load to check if crushing has to be done when POG is getting created. At that time g_pog_json will only have the shelf which is currently
        // in the loop but cannot have other shelfs or items to judge how much crush to be done. so we use g_json which will have all the details of POG.
        if (p_on_load == "Y" && typeof g_json[0] !== "undefined" && g_json.length > 0) {
            //ASA-1383 issue 8 // 20240415 - Regression Issue 8
            if (typeof g_json[0].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex] !== "undefined") {
                // 20240415 - Regression Issue 8
                var open_shelf = g_json[0].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex];
            } else {
                var open_shelf = g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex];
            }
        }
        var pogItem = g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex].ItemInfo[p_itemIndex];
        var orientation = typeof pogItem == "undefined" ? -1 : pogItem.Orientation;
        var [item_owidth, item_oheight, item_odepth, actualHeight, wActualWidth, actualdepth] = get_new_orientation_dim(orientation, 0, 0, 0); //ASA-1371_26842 Found out its called 2 times without use. ,ASA-1398 issue 4 added the actualdepth parameter checking the depth change to height ,width
        var height_manualCrush = "N";
        var width_manualCrush = "N";
        var crush_width = 0,
            crush_height = 0;
        /*var auto_h_crush = 'N',//ASA-1353 issue 3 regression issue 20240428
            auto_v_crush = 'N',
            auto_d_crush = 'N'; ////Start Task-02_25977 prasanna*/
        if (p_itemIndex !== -1 && typeof pogItem !== "undefined") {
            //if there is no capping then we reset the H and D to its actual value and then process crushing again.
            if (pogItem.CrushVert > 0 && pogItem.CapStyle == "0" && pogItem.NVal == 0 && (p_crushType == "H" || p_crushType == "A")) {
                pogItem.H = pogItem.RH;
            }
            if (pogItem.CrushD > 0 && (p_crushType == "D" || p_crushType == "A")) {
                pogItem.D = pogItem.RD;
            }

            //Task-02_25977 KUSH FOR MASS UPDATE FOR AUTO CRUSH IN CHEST////ASA-1353 issue 3 regression issue 20240428
            /*if (pogItem.MassCrushV == "Y" && pogItem.MVertCrushed == "N" && pogItem.CHPerc > 0 && pogShelf.ObjType == 'CHEST') { //--Task_26821, Task_27323 regression 7 added check for the  chest       
                pogItem.MVertCrushed = 'Y';
                auto_v_crush = 'Y';
            }
            if (pogItem.MassCrushH == "Y" && pogItem.MHorizCrushed == "N" && pogItem.CWPerc > 0 && pogShelf.ObjType == 'CHEST') { //--Task_26821,Task_27323 regression 7 
                pogItem.MHorizCrushed = "Y";
                auto_h_crush = 'Y';
            }
            if (pogItem.MassCrushD == "Y" && pogItem.MDepthCrushed == "N" && pogItem.CDPerc > 0 && pogShelf.ObjType == 'CHEST') { //--Task_26821,Task_27323 regression 7 
                pogItem.MDepthCrushed = "Y";
                auto_d_crush = 'Y';
            }*/
            // changes for ASA-2024.3 START
            height_manualCrush = typeof pogItem.MVertCrushed == "undefined" || pogItem.MVertCrushed == null || pogItem.MVertCrushed == "N" ? "N" : "Y";
            // depth_manualCrush = typeof pogItem.MDepthCrushed == "undefined" || pogItem.MDepthCrushed == null || pogItem.MDepthCrushed == "N" ? "N" : "Y";
            if (actualHeight == "H") {
                crush_height = height_manualCrush == "N" ? pogItem.CHPerc : pogItem.CrushVert;
            } else if (actualHeight == "W") {
                crush_height = height_manualCrush == "N" ? pogItem.CWPerc : pogItem.CrushHoriz;
            } else if (actualHeight == "D") {
                crush_height = height_manualCrush == "N" ? pogItem.CDPerc : pogItem.CrushD;
            }
            width_manualCrush = typeof pogItem.MHorizCrushed == "undefined" || pogItem.MHorizCrushed == null || pogItem.MHorizCrushed == "N" ? "N" : "Y";
            if (wActualWidth == "H") {
                if (pogItem.MassCrushH == "Y") {
                    crush_width = pogItem.CrushHoriz;
                } else {
                    crush_width = width_manualCrush == "N" ? pogItem.CHPerc : pogItem.CrushVert;
                }
            } else if (wActualWidth == "W") {
                crush_width = width_manualCrush == "N" ? pogItem.CWPerc : pogItem.CrushHoriz;
            } else if (wActualWidth == "D") {
                crush_width = width_manualCrush == "N" ? pogItem.CDPerc : pogItem.CrushD;
            }
            // changes for ASA-2024.3 END
            // backupfor above changes start
            // //we find out if the item is manually crushed vertically or not.
            // height_manualCrush = typeof pogItem.MVertCrushed == "undefined" || pogItem.MVertCrushed == null || pogItem.MVertCrushed == "N" ? "N" : "Y"; //Task_26899 //ASA-1383 issue 8
            // //actualheight is actually the height changed to which dimension after orientation change.based on that we get the crush perc of that dimension.
            // if (actualHeight == "H") {
            //     //height_manualCrush = typeof pogItem.MVertCrushed == "undefined" || pogItem.MVertCrushed == "N" ? "N" : "Y";//Task_26899
            //     crush_height = height_manualCrush == "N" ? pogItem.CHPerc : pogItem.CrushVert;
            // } else if (actualHeight == "W") {
            //     //height_manualCrush = typeof pogItem.MHorizCrushed == "undefined" || pogItem.MHorizCrushed == "N" ? "N" : "Y";//Task_26899
            //     crush_height = height_manualCrush == "N" ? pogItem.CWPerc : pogItem.CrushHoriz;
            // } else if (actualHeight == "D") {
            //     //height_manualCrush = typeof pogItem.MDepthCrushed == "undefined" || pogItem.MDepthCrushed == "N" ? "N" : "Y";//Task_26899
            //     crush_height = height_manualCrush == "N" ? pogItem.CDPerc : pogItem.CrushD;
            // }
            // //we find out if the item is manually crushed horizontally or not.
            // width_manualCrush = typeof pogItem.MHorizCrushed == "undefined" || pogItem.MHorizCrushed == null || pogItem.MHorizCrushed == "N" ? "N" : "Y"; ////Task_26899  //ASA-1383 issue 8
            // if (wActualWidth == "H") {
            //     //Task-02_25977
            //     //when doing mass update we set the below tag MassCrushH. this means if the orientation is changed and width became height also we take the CWperc for crush.
            //     //instead of CHPerc.
            //     if (pogItem.MassCrushH == "Y") {
            //         width_manualCrush = "Y";
            //         crush_width = width_manualCrush == "N" ? pogItem.CWPerc : pogItem.CrushHoriz;
            //     } else {
            //         //width_manualCrush = typeof pogItem.MVertCrushed == "undefined" || pogItem.MVertCrushed == "N" ? "N" : "Y";//Task_26899
            //         crush_width = width_manualCrush == "N" ? pogItem.CHPerc : pogItem.CrushVert; //Task_26899
            //     }
            //     //we get the crush perc based on the change of dimension after orientation of item.
            // } else if (wActualWidth == "W") {
            //     //width_manualCrush = typeof pogItem.MHorizCrushed == "undefined" || pogItem.MHorizCrushed == "N" ? "N" : "Y";//Task_26899
            //     crush_width = width_manualCrush == "N" ? pogItem.CWPerc : pogItem.CrushHoriz;
            // } else if (wActualWidth == "D") {
            //     //width_manualCrush = typeof pogItem.MDepthCrushed == "undefined" || pogItem.MDepthCrushed == "N" ? "N" : "Y";//Task_26899
            //     crush_width = width_manualCrush == "N" ? pogItem.CDPerc : pogItem.CrushD;
            // }
            // backupfor above changes end
        }
        //there is a possibility that there are multiple items to be crush in depth. so we set all to its RD. that is remove the crushing done before.
        if (p_itemDepthIndxArr.length > 0) {
            var r = 0;
            for (idx of p_itemDepthIndxArr) {
                var y = 0;
                for (obj of g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex].ItemInfo) {
                    if (obj.CrushD > 0 && (p_crushType == "D" || p_crushType == "A") && y == p_itemDepthIndxArr[r]) {
                        obj.D = obj.RD;
                    }
                    y++;
                }
                r++;
            }
        }

        var spread_gap = 0,
            horiz_gap = 0;
        if (pogShelf.ObjType == "PEGBOARD") {
            horiz_gap = pogShelf.VertiSpacing;
        } else {
            horiz_gap = pogShelf.HorizGap;
        }

        if (horiz_gap > 0) {
            spread_gap = horiz_gap;
        } else {
            spread_gap = 0;
        }
        //before condition enters for CHEST items. because the logic for crush in chest is different.
        if (typeof pogItem !== "undefined" && pogShelf.ObjType == "CHEST" && g_chest_as_pegboard == "Y" && (pogShelf.AllowAutoCrush == "Y" || pogShelf.ManualCrush == "Y")) {
            //ASA-1300 start
            var return_val = "Y";
            // var [l_valid_width, l_valid_height, l_valid_depth, l_hit, l_hit_cnt_all, l_hit_dirc_horz_all, l_hit_dirc_vert_all] = check_chest_area_item_hit('A', pogItem, pogShelf.ItemInfo, pogShelf, pogItem.H, pogItem.W, pogItem.D, p_itemIndex);//ASA-1405 Issue 2
            // pogItem.D = pogItem.RD; // ASA-1405 issue 2
            // ASA-1405 Issue 2
            if (p_crushType == "H" || p_crushType == "A" || p_crushType == "W") {
                //crushing only H and W in the below function.
                //This below function will find out all the overlapping items and find out totally how much of widht and height to be crushed and return Y if done or N if could not crush.
                return_val = crushChestItemHW(p_on_load == "Y" && typeof open_shelf !== "undefined" ? open_shelf : pogShelf, pogItem, p_itemIndex, crush_height, crush_width, width_manualCrush, height_manualCrush, actualHeight, wActualWidth, p_setInd); //20240708 Regression issue 4
            }
            //This code is from crushing depth
            if (actualHeight == "D") {
                var heightPerc = pogItem.CrushVert;
                var heightPercMax = pogItem.CHPerc;
                var manualCrush = pogItem.MVertCrushed;
                crushVal = (typeof pogItem.MVertCrushed == "undefined" || pogItem.MVertCrushed == "N") && heightPercMax > 0 ? heightPercMax : heightPerc;
            } else {
                var deptPerc = pogItem.CrushD;
                var deptPercMax = pogItem.CDPerc;
                var manualCrush = pogItem.MDepthCrushed;
                crushVal = (typeof pogItem.MDepthCrushed == "undefined" || pogItem.MDepthCrushed == "N") && deptPercMax > 0 ? deptPercMax : deptPerc;
            }
            // ASA-1405 Issue 2
            // if (((p_crushType == "D" || p_crushType == "A") && l_valid_depth == 'N') || manualCrush == 'Y') {
            //for chest if items D is more than basket wall heigth. then we try to crush.
            if (((p_crushType == "D" || p_crushType == "A") && pogItem.D > pogShelf.BsktWallH) || manualCrush == "Y") {
                pogItem.D = pogItem.RD; // ASA-1405 issue 2
                var new_crush_perc = 0;
                var real_depth = pogItem.RD;
                var l_success = "N";
                var new_depth = pogItem.D; //ASA-1327 the value was assigned inside. but when crushVal =0 then undefined.

                if (crushVal > 0) {
                    //this code is manual crush N. the loop will continue till crush perc. if new depth is less than basket wall height then crushing passes.
                    if (manualCrush == "N") {
                        for (j = 0; j <= crushVal; j++) {
                            new_depth = wpdSetFixed(real_depth - (real_depth * j) / 100); //.toFixed(4));//ASA-1405 Issue 2
                            // ASA-1405 Issue 2
                            // var [l_width_valid, l_height_valid, l_depth_valid, l_hit, l_hit_cnt, l_hit_dirc_horz, l_hit_dirc_vert] = check_chest_area_item_hit('C', pogItem, pogShelf.ItemInfo, pogShelf, pogItem.H, pogItem.W, new_depth, p_itemIndex);
                            // if (l_hit == 'N') {
                            //Regression Issue 2 20240725, change > to <=
                            if (new_depth <= pogShelf.BsktWallH) {
                                new_crush_perc = j;
                                l_success = "Y";
                                break;
                            }
                        }
                    } else {
                        //This part is manual crush. here we don't loop and try to find the crush perc. but completely crush until the crush perc mentioned by user.
                        new_depth = wpdSetFixed(real_depth - (real_depth * crushVal) / 100); //.toFixed(4));//ASA-1405 Issue 2
                        // ASA-1405 Issue 2
                        // var [l_width_valid, l_height_valid, l_depth_valid, l_hit, l_hit_cnt, l_hit_dirc_horz, l_hit_dirc_vert] = check_chest_area_item_hit('C', pogItem, pogShelf.ItemInfo, pogShelf, pogItem.H, pogItem.W, new_depth, p_itemIndex);
                        // if (l_hit == 'N') {
                        //Regression Issue 2 20240725, change > to <=
                        if (new_depth <= pogShelf.BsktWallH) {
                            new_crush_perc = crushVal;
                            l_success = "Y";
                        }
                    }
                }
                if (l_success == "Y" && p_setInd == "Y") {
                    pogItem.D = wpdSetFixed(new_depth); //.toFixed(4));//ASA-1405 Issue 2
                    if (actualdepth == "W") {
                        //ASA-1398 ISSUE 4
                        pogItem.CrushHoriz = new_crush_perc;
                    } else if (actualdepth == "H") {
                        pogItem.CrushVert = new_crush_perc;
                    } else if (actualdepth == "D") {
                        pogItem.CrushD = new_crush_perc;
                    } //ASA-1398 ISSUE 4 -E;
                    pogItem.DChanged = "Y";
                    g_error_category = "";
                    return_val = "Y";
                } else {
                    if (manualCrush == "Y") {
                        //SA-1398 ISSUE 4
                        pogItem.D = wpdSetFixed(new_depth); //.toFixed(4));//ASA-1405 Issue 2
                        if (actualdepth == "W") {
                            pogItem.CrushHoriz = new_crush_perc;
                        } else if (actualdepth == "H") {
                            pogItem.CrushVert = new_crush_perc;
                        } else if (actualdepth == "D") {
                            pogItem.CrushD = new_crush_perc;
                        } //ASA-1398 ISSUE 4 -E;;
                        pogItem.DChanged = "Y";
                    }
                    g_error_category = "D";
                    return_val = "N";
                }
            }
            //Start Task-02_25977 prasanna////ASA-1353 issue 3 regression issue 20240428
            /*if (pogItem.MassCrushH == "Y" && auto_h_crush == "Y") { //Task-02_25977 KUSH FOR MASS UPDATE FOR AUTO CRUSH IN CHEST
                pogItem.MHorizCrushed = "N";
                pogItem.MassCrushH = 'N';
            }
            if (pogItem.MassCrushV == "Y" && auto_v_crush == "Y") { //Task-02_25977 KUSH FOR MASS UPDATE FOR AUTO CRUSH IN CHEST
                pogItem.MVertCrushed = "N";
                pogItem.MassCrushV = 'N';
            }
            if (pogItem.MassCrushD == "Y" && auto_d_crush == "Y") { //Task-02_25977 KUSH FOR MASS UPDATE FOR AUTO CRUSH IN CHEST
                pogItem.MDepthCrushed = "N";
                pogItem.MassCrushD = 'N';
            }*/
            //End Task-02_25977 prasanna
            return return_val;
        } else if (!(pogShelf.ObjType == "CHEST" && g_chest_as_pegboard == "Y")) {
            //End ASA-1300
            var return_val = "Y"; //UAT issue 9 Item Sizes are reverted for Crushed Items after Mass Update.
            //if Height crushing need to be done.
            if (p_crushType == "H" || p_crushType == "A") {
                var new_crush_perc = 0;
                var new_height = 0,
                    cap_height = 0,
                    item_height = pogItem.RH;
                // if we are calling crushitem function from create_shelf_from_json_lib. we need to use g_json and get the max merch
                //because the g_pog_json will not have all the shelfs above the current shelf and item at the moment this function is called. so we cannot get correct max merch.
                if (p_on_load == "Y" && typeof g_json[0] !== "undefined") {
                    //20240415 Rregression issue 12 20240430
                    var l_max_merch = get_onload_max_merch(p_moduleIndex, p_shelfIndex, pogModule, pogShelf, g_dft_max_merch, 0, g_json);
                } else {
                    var l_max_merch = get_cap_max_merch(p_moduleIndex, p_shelfIndex, pogModule, pogShelf, p_pog_index, g_dft_max_merch); //ASA-1353 issue 3 --Task_27104 20240419//20240415 - Regression Issue 8
                }

                //we capture the cap height because after crush to add it back to actual crushed H.
                if (pogItem.CapStyle == "1" || pogItem.CapStyle == "2" || pogItem.CapStyle == "3") {
                    cap_height = pogItem.H - pogItem.RH;
                    //l_max_merch = l_max_merch - nvl(cap_height);ASA-1410 issue 13
                    item_height = pogItem.RH + nvl(cap_height); //task 25959 Kush real height not included the cap height so we need to add the capheight
                }

                //if not manually crushed we run loop on crush perc and try to see if height is less than max merch.
                if (height_manualCrush == "N") {
                    for (i = 0; i <= crush_height; i++) {
                        new_height = item_height - (item_height * i) / 100;
                        if (l_max_merch >= new_height) {
                            new_crush_perc = i;
                            break;
                        }
                    }
                } else {
                    //if manually crushed by user. just crush the item till the value mentioned by user.
                    new_height = item_height - (item_height * crush_height) / 100;
                    new_crush_perc = crush_height;
                }
                //if there are items on top or bottom of the current item. we find the total height of all the items included.
                if ((typeof pogItem.TopObjID !== "undefined" && pogItem.TopObjID !== "") || (typeof pogItem.BottomObjID !== "undefined" && pogItem.BottomObjID !== "")) {
                    //TASK 25959 Kush -S
                    var item_top = pogItem.H;
                    var j = 0;
                    for (const items_info of pogShelf.ItemInfo) {
                        if (wpdSetFixed(pogItem.X) == wpdSetFixed(items_info.X) && j !== p_itemIndex) {
                            item_top += items_info.H;
                        }
                        j++;
                    }
                    new_height = item_top;
                } // Task 25959-E
                //if crushing did not pass. reset crush perc to 0.
                if (new_height > l_max_merch) {
                    g_error_category = "H";
                    return_val = "N"; //UAT issue 9 Item Sizes are reverted for Crushed Items after Mass Update.
                    if (height_manualCrush == "N") {
                        //Start ASA-1412 issue 8
                        if (actualHeight == "H") {
                            pogItem.CrushVert = 0;
                        } else if (actualHeight == "W") {
                            pogItem.CrushHoriz = 0;
                        } else if (actualHeight == "D") {
                            pogItem.CrushDepth = 0;
                        } //End ASA-1412 issue 8
                    }
                } else {
                    if (p_setInd == "Y") {
                        pogItem.H = new_height;
                        if (actualHeight == "H") {
                            //Task-02_25977
                            pogItem.CrushVert = new_crush_perc;
                        } else if (actualHeight == "W") {
                            pogItem.CrushHoriz = new_crush_perc;
                        } else if (actualHeight == "D") {
                            pogItem.CrushDepth = new_crush_perc;
                        }
                        var [itemx, itemy] = get_item_xy(pogShelf, pogItem, pogItem.W, pogItem.H, p_pog_index);
                        if (!(pogShelf.ObjType == "BASKET" && pogItem.Item == "DIVIDER")) {
                            pogItem.Y = itemy;
                        }
                        pogItem.HChanged = "Y";
                    }
                    g_error_category = "";
                    return_val = "Y"; //UAT issue 9 Item Sizes are reverted for Crushed Items after Mass Update.
                }
            }
            //width crush is done below.
            if (p_crushType == "W" || p_crushType == "A") {
                var l_shelf_found = "N";
                var shelf_width = 0;
                var crush_width_arr = [],
                    crush_horiz_arr = [];
                var new_item_sum = 0;
                var crush_item_ind = "N";
                var new_crush_perc = 0;
                var new_avilable_space = 0;
                var l_allow_comb_crush = "N";

                //Width crush has 2 different parts. one - crushing combine shelf items. here we should consider total width of all the shelfs which are combine in one set.
                //two - normal shelf item to be crushed based on width of that particular shelf.
                //Note: width crushing is always try to crush all the items in the shelf to fit into the shelf width. not only the current item sent to crush.could be all items in combine shelfs or single shelf.
                if (g_combinedShelfs.length > 0) {
                    ///ASA-1307
                    var [oldCombinationIndex, oldShelfCombIndx] = getCombinationShelf(p_pog_index, pogShelf.Shelf);
                    //check if the shelf in which the current item exists is combined with other shelfs are not. if yes
                    //then take the allow auto crush setup of the first shelf from the left. that is saved in the g_combineShelfs array.
                    if (oldCombinationIndex !== -1) {
                        l_shelf_found = "Y";
                        l_allow_comb_crush = g_combinedShelfs[oldCombinationIndex][0].AllowAutoCrush;
                    }
                    if (l_shelf_found == "Y") {
                        //g_combineShelfs array will have all the iteminfo of all the combine shelfs with the current items shelf.
                        var items_arr = g_combinedShelfs[oldCombinationIndex].ItemInfo;
                        /*if (typeof pogItem !== 'undefined') {
                        items_arr.push(pogItem);
                        }*/
                        //calculate the total width of all combine shelfs.
                        var i = 0;
                        for (var combineshelf of g_combinedShelfs[oldCombinationIndex]) {
                            shelf_width = shelf_width + combineshelf.W;
                            i++;
                        }
                    }
                }
                if (l_shelf_found == "Y") {
                    var i = 0;
                    var crush_item_ind = "N", //ASA-1677, was =-1 //start ASA-1353 issue 3 --Task_27104 20240417
                        crush_index_arr = [],
                        crush_id_arr = [], //ASA-1353 issue 3 20240424
                        crush_shelf_arr = [],
                        crush_mod_arr = [],
                        crush_width_arr = [],
                        crush_manual_arr = [], //ASA-1353 issue 3 Task_27104
                        crush_horiz_arr = []; //End ASA-1353 issue 3 --Task_27104 20240417
                    // if (width_manualCrush == 'N') {
                    //looping all the items from all shelfs that are combined with current item shelfs and get the list of items which have crush % and manual crush.
                    for (const items of items_arr) {
                        var items_crush_width = 0;
                        var orientation = items.Orientation;
                        var [item_owidth, item_oheight, item_odepth, wActualHeight, wActualWidth, wActualDepth] = get_new_orientation_dim(orientation, 0, 0, 0);
                        //Start Task_26899
                        // we are getting the manual crush setup and crush perc based on the orientation dim.
                        manualCrush = typeof items.MHorizCrushed == "undefined" || items.MHorizCrushed == null || items.MHorizCrushed == "N" ? "N" : "Y"; //ASA-1383 issue 8
                        if (wActualWidth == "W") {
                            //manualCrush = typeof items.MHorizCrushed == "undefined" || items.MHorizCrushed == "N" ? "N" : "Y";
                            items_crush_width = manualCrush == "N" && items.CWPerc > 0 ? items.CWPerc : items.CrushHoriz;
                        } else if (wActualWidth == "H") {
                            //manualCrush = typeof items.MVertCrushed == "undefined" || items.MVertCrushed == "N" ? "N" : "Y";
                            items_crush_width = manualCrush == "N" && items.CHPerc > 0 ? items.CHPerc : items.CrushVert;
                        } else if (wActualWidth == "D") {
                            //manualCrush = typeof items.MDepthCrushed == "undefined" || items.MDepthCrushed == "N" ? "N" : "Y";
                            items_crush_width = manualCrush == "N" && items.CDPerc > 0 ? items.CDPerc : items.CrushD;
                        }
                        //End Task_26899
                        if (items.Fixed == "N" && items_crush_width > 0 && ((manualCrush == "Y" && i !== p_itemIndex) || manualCrush == "N")) {
                            crush_item_ind = "Y";
                            crush_index_arr.push(items.IIndex);
                            crush_shelf_arr.push(items.SIndex);
                            crush_mod_arr.push(items.MIndex);
                            crush_id_arr.push(items.MIndex + "#" + items.SIndex + "#" + items.IIndex); //ASA-1353 issue 3 20240424
                            crush_width_arr.push(items.W);
                            crush_manual_arr.push(manualCrush); //ASA-1353 issue 3 Task_27104
                            crush_horiz_arr.push(items_crush_width);
                        }
                        i++;
                    }
                    //}
                    if (crush_item_ind == "Y") {
                        crush_item_ind = "N";
                        //this loop will run to 100% crush, but will be restricted to each items max crush perc inside the items_arr loop. it also considers each items
                        //manual crush setting too.
                        for (i = 0; i < 100; i++) {
                            new_item_sum = 0;
                            var new_width = 0;
                            var j = 0;
                            var mcrush_ind = "N"; //Task-01_27858 issue 14 20240530
                            for (const items of items_arr) {
                                var items_crush_width = 0;
                                //Start Task_26899
                                //getting manual crush setting and crush perc for each item in the loop.
                                var orientation = items.Orientation;
                                var [item_owidth, item_oheight, item_odepth, wActualHeight, wActualWidth, wActualDepth] = get_new_orientation_dim(orientation, 0, 0, 0);
                                manualCrush = typeof items.MHorizCrushed == "undefined" || items.MHorizCrushed == null || items.MHorizCrushed == "N" ? "N" : "Y"; //ASA-1383 issue 8

                                //As this is a combine shelf items. we need to get MIndex, SIndex and IIndex and the get the item details. or there can be possibility
                                //that we are getting same IIndex item from different shelf.
                                items_crush_width = crush_horiz_arr[crush_id_arr.indexOf(items.MIndex + "#" + items.SIndex + "#" + items.IIndex)]; //ASA-1353 issue 3 20240424
                                if (typeof items_crush_width == "undefined") {
                                    //ASA-1353 issue 3 20240424
                                    if (wActualWidth == "W") {
                                        items_crush_width = manualCrush == "N" && items.CWPerc > 0 ? items.CWPerc : items.CrushHoriz;
                                    } else if (wActualWidth == "H") {
                                        items_crush_width = manualCrush == "N" && items.CHPerc > 0 ? items.CHPerc : items.CrushVert;
                                    } else if (wActualWidth == "D") {
                                        items_crush_width = manualCrush == "N" && items.CDPerc > 0 ? items.CDPerc : items.CrushD;
                                    }
                                }
                                //End ASA-1353 issue 3 --Task_27104 20240417
                                //End Task_26899
                                //This condition will pass only when manual crush is 'N' and i is not reached the max crush perc of that item.
                                if (crush_id_arr.indexOf(items.MIndex + "#" + items.SIndex + "#" + items.IIndex) !== -1 && i <= items_crush_width && manualCrush == "N") {
                                    //ASA-1353 issue 3 20240424
                                    //we calculate new width after crush from crush perc loop.
                                    new_width = wpdSetFixed(items.RW - items.RW * (i / 100));
                                    //if the current item crushing has not reached the maximum of the crush perc then go in set the current crush perc.
                                    if (new_width >= wpdSetFixed(items.RW - items.RW * (items_crush_width / 100))) {
                                        new_item_sum += new_width;
                                        if (p_setInd == "Y") {
                                            //ASA-1307
                                            if (typeof g_pog_json[p_pog_index].ModuleInfo[items.MIndex] !== "undefined" && typeof g_pog_json[p_pog_index].ModuleInfo[items.MIndex].ShelfInfo[items.SIndex] !== "undefined" && typeof g_pog_json[p_pog_index].ModuleInfo[items.MIndex].ShelfInfo[items.SIndex].ItemInfo[items.IIndex] !== "undefined") {
                                                //ASA-1353 issue 3 20240424
                                                //Start Task_27812
                                                var item_info = g_pog_json[p_pog_index].ModuleInfo[items.MIndex].ShelfInfo[items.SIndex].ItemInfo[items.IIndex];
                                                item_info.W = new_width;
                                                if (wActualWidth == "W") {
                                                    //ASA-1353 issue 3 20240424
                                                    item_info.CrushHoriz = i;
                                                } else if (wActualWidth == "H") {
                                                    item_info.CrushVert = i;
                                                } else if (wActualWidth == "D") {
                                                    item_info.CrushD = i;
                                                }
                                                //g_pog_json[p_pog_index].ModuleInfo[items.MIndex].ShelfInfo[items.SIndex].ItemInfo[items.IIndex].CrushHoriz = i;
                                                //End Task_27812
                                            } else {
                                                items.W = new_width;
                                                if (wActualWidth == "W") {
                                                    //ASA-1353 issue 3 20240424
                                                    items.CrushHoriz = i;
                                                } else if (wActualWidth == "H") {
                                                    items.CrushVert = i;
                                                } else if (wActualWidth == "D") {
                                                    items.CrushD = i;
                                                }
                                                // items.CrushHoriz = i;//ASA-1353 issue 3 20240424
                                            } //End ASA-1353 issue 3 --Task_27104 20240417
                                        }
                                    } else {
                                        //else use the RW of the current item.
                                        new_item_sum += items.RW;
                                    }
                                } else if (manualCrush == "Y") {
                                    //manual crush will not be crush for suitable crush perc. but crushed completely.
                                    mcrush_ind = items_crush_width > 0 ? "Y" : "N"; //Task-01_27858 issue 14 20240530
                                    new_width = wpdSetFixed(items.RW - items.RW * (items_crush_width / 100));
                                    new_item_sum += new_width;
                                    if (p_setInd == "Y") {
                                        //ASA-1307
                                        if (typeof g_pog_json[p_pog_index].ModuleInfo[items.MIndex] !== "undefined" && typeof g_pog_json[p_pog_index].ModuleInfo[items.MIndex].ShelfInfo[items.SIndex] !== "undefined" && typeof g_pog_json[p_pog_index].ModuleInfo[items.MIndex].ShelfInfo[items.SIndex].ItemInfo[items.IIndex] !== "undefined") {
                                            //ASA-1353 issue 3 20240424
                                            //Start Task_27812
                                            var item_info = g_pog_json[p_pog_index].ModuleInfo[items.MIndex].ShelfInfo[items.SIndex].ItemInfo[items.IIndex];
                                            item_info.W = new_width;
                                            if (wActualWidth == "W") {
                                                //ASA-1353 issue 3 20240424
                                                item_info.CrushHoriz = items_crush_width; //ASA-1386 Issue 14 20240528
                                            } else if (wActualWidth == "H") {
                                                item_info.CrushVert = items_crush_width; //ASA-1386 Issue 14 20240528
                                            } else if (wActualWidth == "D") {
                                                item_info.CrushD = items_crush_width; //ASA-1386 Issue 14 20240528
                                            }
                                            //End Task_27812
                                        } else {
                                            items.W = new_width;
                                            if (wActualWidth == "W") {
                                                //ASA-1353 issue 3 20240424
                                                items.CrushHoriz = items_crush_width;
                                            } else if (wActualWidth == "H") {
                                                items.CrushVert = items_crush_width;
                                            } else if (wActualWidth == "D") {
                                                items.CrushD = items_crush_width;
                                            }
                                            //items.CrushHoriz = items_crush_width;//ASA-1353 issue 3 20240424
                                        } //End ASA-1353 issue 3 --Task_27104 20240417
                                    }
                                } else {
                                    // this is needed to set the crush perc back to 0. if the crushperc was changed to 0 by user from dim master update.
                                    if (items_crush_width == 0) {
                                        //--Task_26821
                                        if (typeof g_pog_json[p_pog_index].ModuleInfo[items.MIndex] !== "undefined" && typeof g_pog_json[p_pog_index].ModuleInfo[items.MIndex].ShelfInfo[items.SIndex] !== "undefined" && typeof g_pog_json[p_pog_index].ModuleInfo[items.MIndex].ShelfInfo[items.SIndex].ItemInfo[items.IIndex] !== "undefined") {
                                            //ASA-1353 issue 3 20240424
                                            //Start Task_27812
                                            var item_info = g_pog_json[p_pog_index].ModuleInfo[items.MIndex].ShelfInfo[items.SIndex].ItemInfo[items.IIndex];
                                            if (wActualWidth == "W") {
                                                item_info.CrushHoriz = 0;
                                            } else if (wActualWidth == "H") {
                                                item_info.CrushVert = 0;
                                            } else if (wActualWidth == "D") {
                                                item_info.CrushD = 0;
                                            }
                                            //g_pog_json[p_pog_index].ModuleInfo[items.MIndex].ShelfInfo[items.SIndex].ItemInfo[items.IIndex].CrushHoriz = 0;
                                            //End Task_27812
                                        } else {
                                            if (wActualWidth == "W") {
                                                //ASA-1353 issue 3 20240424
                                                items.CrushHoriz = 0;
                                            } else if (wActualWidth == "H") {
                                                items.CrushVert = 0;
                                            } else if (wActualWidth == "D") {
                                                items.CrushD = 0;
                                            }
                                            //items.CrushHoriz = 0;//ASA-1353 issue 3 20240424
                                        } //END ASA-1353 issue 3 --Task_27104 20240417
                                    }
                                    new_item_sum += items.W;
                                }
                                if (horiz_gap > 0) {
                                    new_item_sum += items.SpreadItem;
                                }
                                j++;
                            }
                            /*(if (width_manualCrush == "Y") {
                                mcrush_width = pogItem.RW - pogItem.RW * (crush_width / 100);
                                if (p_setInd == "Y") {
                                    pogItem.W = mcrush_width;
                                    if (wActualWidth == 'W') {//ASA-1353 issue 3 20240424
                                        pogItem.CrushHoriz = crush_width;
                                    } else if (wActualWidth == 'H') {
                                        pogItem.CrushVert = crush_width;
                                    } else if (wActualWidth == 'D') {
                                        pogItem.CrushD = crush_width;
                                    }
                                    //pogItem.CrushHoriz = crush_width;//ASA-1353 issue 3 20240424
                                }
                            }*/
                            //check if the available space is > 0 then crush is successfull on all the items that are crushed.
                            new_avilable_space = shelf_width - new_item_sum; // + mcrush_width);
                            if (new_avilable_space >= 0) {
                                new_crush_perc = i;
                                if (i > 0 || mcrush_ind == "Y") {
                                    //ASA-1353 regression issue //Task-01_27858 issue 14 20240530
                                    crush_item_ind = "Y";
                                    if (p_itemIndex !== -1 && crush_index_arr.indexOf(p_itemIndex) !== -1 && p_setInd == "Y") {
                                        pogShelf.ItemInfo[p_itemIndex].WChanged = "Y";
                                    }
                                }
                                break;
                            }
                        }
                        //if items are not crushed or no need to crush then set the old crush perc back to all the items.
                        if (crush_item_ind == "N") {
                            if (new_crush_perc > 0) {
                                ////ASA-1353 issue 3 regression issue 20240428
                                var j = 0;
                                for (const items of crush_index_arr) {
                                    if (crush_manual_arr[j] == "N" && typeof g_pog_json[p_pog_index].ModuleInfo[crush_mod_arr[j]] !== "undefined" && typeof g_pog_json[p_pog_index].ModuleInfo[crush_mod_arr[j]].ShelfInfo[crush_shelf_arr[j]] !== "undefined" && typeof g_pog_json[p_pog_index].ModuleInfo[crush_mod_arr[j]].ShelfInfo[crush_shelf_arr[j]].ItemInfo[crush_index_arr[j]] !== "undefined") {
                                        //ASA-1353 issue 3 Task_27104,//ASA 1387 issue 2 added to handle undefined shelfs and items in combination. As they are not pushed yet in the g_pog_json but are in combination
                                        g_pog_json[p_pog_index].ModuleInfo[crush_mod_arr[j]].ShelfInfo[crush_shelf_arr[j]].ItemInfo[crush_index_arr[j]].W = crush_width_arr[j];
                                        g_pog_json[p_pog_index].ModuleInfo[crush_mod_arr[j]].ShelfInfo[crush_shelf_arr[j]].ItemInfo[crush_index_arr[j]].CrushHoriz = crush_horiz_arr[j];
                                    }
                                    j++;
                                }
                            }
                            g_error_category = "W";
                            return_val = "N"; //UAT issue 9 Item Sizes are reverted for Crushed Items after Mass Update.
                        } else {
                            g_error_category = "";
                            return_val = "Y"; //UAT issue 9 Item Sizes are reverted for Crushed Items after Mass Update.
                        }
                    } else if (width_manualCrush == "Y" && crush_item_ind == "N" && typeof pogItem !== "undefined") {
                        //if manual crush for the current item in combine shelf is Y.
                        mcrush_width = wpdSetFixed(pogItem.RW - pogItem.RW * (crush_width / 100));
                        if (p_setInd == "Y") {
                            pogItem.W = mcrush_width;
                            pogItem.WChanged = "Y";
                            if (wActualWidth == "W") {
                                //ASA-1353 issue 3 20240424
                                pogItem.CrushHoriz = crush_width;
                            } else if (wActualWidth == "H") {
                                pogItem.CrushVert = crush_width;
                            } else if (wActualWidth == "D") {
                                pogItem.CrushD = crush_width;
                            }
                            //pogItem.CrushHoriz = crush_width;//ASA-1353 issue 3 20240424
                        }
                    } else {
                        return_val = "F"; //No items with crush > 0, run facing logic//UAT issue 9 Item Sizes are reverted for Crushed Items after Mass Update.
                    }
                } else {
                    //Width crush of normal shelf item to be crushed based on width of that particular shelf.
                    //Note: width crushing is always try to crush all the items in the shelf to fit into the shelf width. not only the current item sent to crush.could be all items in combine shelfs or single shelf.
                    var items_arr = pogShelf.ItemInfo;
                    var i = 0;
                    var crush_item_ind = "N", //ASA-1677 was =-1,//Start ASA-1353 issue 3 --Task_27104 20240417
                        crush_index_arr = [],
                        crush_width_arr = [],
                        crush_manual_arr = [], //ASA-1353 issue 3 Task_27104
                        crush_horiz_arr = []; //End ASA-1353 issue 3 --Task_27104 20240417
                    var hasFixedDivider = false;
                    //if (width_manualCrush == 'N') { //Task-02_25977-- ASA-1349 issue 5
                    //list out all the items from the itemInfo that have crush perc or manual crush = 'Y'
                    for (const items of items_arr) {
                        var items_crush_width = 0;
                        var orientation = items.Orientation;
                        var [item_owidth, item_oheight, item_odepth, wActualHeight, wActualWidth, wActualDepth] = get_new_orientation_dim(orientation, 0, 0, 0);
                        //Start Task_26899
                        //get each items crush perc based on the dim change due to orientation of the item.
                        manualCrush = typeof items.MHorizCrushed == "undefined" || items.MHorizCrushed == null || items.MHorizCrushed == "N" ? "N" : "Y"; //ASA-1383 issue 8
                        if (wActualWidth == "W") {
                            //manualCrush = typeof items.MHorizCrushed == "undefined" || items.MHorizCrushed == "N" ? "N" : "Y";
                            items_crush_width = manualCrush == "N" && items.CWPerc > 0 ? items.CWPerc : items.CrushHoriz;
                        } else if (wActualWidth == "H") {
                            //manualCrush = typeof items.MVertCrushed == "undefined" || items.MVertCrushed == "N" ? "N" : "Y";
                            items_crush_width = manualCrush == "N" && items.CHPerc > 0 ? items.CHPerc : items.CrushVert;
                        } else if (wActualWidth == "D") {
                            //manualCrush = typeof items.MDepthCrushed == "undefined" || items.MDepthCrushed == "N" ? "N" : "Y";
                            items_crush_width = manualCrush == "N" && items.CDPerc > 0 ? items.CDPerc : items.CrushD;
                        }
                        //End Task_26899
                        if (items.Fixed == "N" && items_crush_width > 0) {
                            // && ((manualCrush == "Y" && i !== p_itemIndex) || manualCrush == "N")) {//ASA-1349 issue 5
                            crush_item_ind = "Y";
                            crush_index_arr.push(i);
                            crush_width_arr.push(items.W);
                            crush_manual_arr.push(manualCrush); //ASA-1353 issue 3 Task_27104
                            crush_horiz_arr.push(items_crush_width);
                        } else if (items.Fixed == "Y") {
                            //ASA-1765 Issue 6, && items.Item == "DIVIDER") {
                            hasFixedDivider = true;
                        }
                        i++;
                    }
                    //}
                    //This is needed when calling crushitem from create_shelf_from_json_lib. we need to use g_json. because it will have all the items in the shelf
                    //but g_pog_json will only have the items till the current item sent to crush because items are added one by one in loop in create_shelf_from_json_lib.
                    if (p_on_load == "Y") {
                        //ASA-1353 regression issue
                        var items_arr = open_shelf.ItemInfo;
                    } else {
                        var items_arr = pogShelf.ItemInfo;
                    }
                    if (crush_item_ind == "Y" && !hasFixedDivider) {
                        crush_item_ind = "N";
                        //this loop will run for all 100%. but each item will be tried to crush for each crush perc loop. if available space becomes > 0. then loop will break.
                        for (i = 0; i < 100; i++) {
                            new_item_sum = 0;
                            var new_width = 0;
                            //var mcrush_width = 0;
                            var j = 0;
                            var mcrush_ind = "N"; //Task-01_27858 issue 14 20240530
                            for (const items of items_arr) {
                                var items_crush_width = 0;
                                var orientation = items.Orientation; //Task_26899
                                var [item_owidth, item_oheight, item_odepth, wActualHeight, wActualWidth, wActualDepth] = get_new_orientation_dim(orientation, 0, 0, 0); //Task_26899
                                //Start Task_26899
                                //getting item crush perc based on dim change due to orientation.
                                manualCrush = typeof items.MHorizCrushed == "undefined" || items.MHorizCrushed == null || items.MHorizCrushed == "N" ? "N" : "Y"; //ASA-1383 issue 8
                                if (wActualWidth == "W") {
                                    //ASA-1383 issue 8
                                    //manualCrush = typeof items.MHorizCrushed == "undefined" || items.MHorizCrushed == "N" ? "N" : "Y";
                                    items_crush_width = manualCrush == "N" && items.CWPerc > 0 ? items.CWPerc : items.CrushHoriz;
                                } else if (wActualWidth == "H") {
                                    //manualCrush = typeof items.MVertCrushed == "undefined" || items.MVertCrushed == "N" ? "N" : "Y";
                                    items_crush_width = manualCrush == "N" && items.CHPerc > 0 ? items.CHPerc : items.CrushVert;
                                } else if (wActualWidth == "D") {
                                    //manualCrush = typeof items.MDepthCrushed == "undefined" || items.MDepthCrushed == "N" ? "N" : "Y";
                                    items_crush_width = manualCrush == "N" && items.CDPerc > 0 ? items.CDPerc : items.CrushD;
                                }
                                //items_crush_width = crush_horiz_arr[crush_index_arr.indexOf(items.IIndex)];//ASA-1383 issue 8
                                //End ASA-1353 issue 3 --Task_27104 20240417

                                //End Task_26899
                                //this condition will pass only when item in the loop has crush perc and i will be creater then max crush perc set for this item.
                                if (crush_index_arr.indexOf(j) !== -1 && i <= items_crush_width) {
                                    //ASA-1349 issue 5
                                    var real_width = typeof items.RW !== "undefined" && items.RW !== null ? items.RW : items.W; //ASA-1383 issue 8
                                    if (manualCrush == "N") {
                                        //we check if calculated width is still less than the total crushing width of that item. then set the new crush perc to that item tags.
                                        new_width = wpdSetFixed(real_width - real_width * (i / 100)); //ASA-1383 issue 8
                                        if (new_width >= wpdSetFixed(real_width - real_width * (items_crush_width / 100))) {
                                            //ASA-1383 issue 8
                                            new_item_sum += new_width;
                                            if (p_setInd == "Y") {
                                                pogShelf.ItemInfo[j].W = new_width;
                                                if (wActualWidth == "W") {
                                                    pogShelf.ItemInfo[j].CrushHoriz = i;
                                                } else if (wActualWidth == "H") {
                                                    pogShelf.ItemInfo[j].CrushVert = i;
                                                } else if (wActualWidth == "D") {
                                                    pogShelf.ItemInfo[j].CrushD = i;
                                                }
                                                //pogShelf.ItemInfo[j].CrushHoriz = i;
                                            }
                                        } else {
                                            //else take the RW of the item for calculate the sum of all items width.
                                            new_item_sum += real_width; //ASA-1383 issue 8
                                        }
                                    } else if (manualCrush == "Y") {
                                        //manual crush does not depend on crush perc loop. will be crushed till the crush perc defind by user.
                                        mcrush_ind = items_crush_width > 0 ? "Y" : "N"; //Task-01_27858 issue 14 20240530
                                        new_width = wpdSetFixed(real_width - real_width * (items_crush_width / 100)); //ASA-1383 issue 8
                                        new_item_sum += new_width;
                                        if (p_setInd == "Y") {
                                            //ASA-1307
                                            pogShelf.ItemInfo[j].W = new_width;
                                            if (wActualWidth == "W") {
                                                pogShelf.ItemInfo[j].CrushHoriz = items_crush_width;
                                            } else if (wActualWidth == "H") {
                                                pogShelf.ItemInfo[j].CrushVert = items_crush_width;
                                            } else if (wActualWidth == "D") {
                                                pogShelf.ItemInfo[j].CrushD = items_crush_width;
                                            }
                                        }
                                    }
                                } else {
                                    //add the width of other items which does not have crush perc.
                                    new_item_sum += wpdSetFixed(items.W);
                                }
                                if (horiz_gap > 0) {
                                    //if horiz gap is defined in product details. add that too.
                                    new_item_sum += items.SpreadItem;
                                }
                                j++;
                            }
                            /*if (width_manualCrush == "Y") {//ASA-1349 issue 5
                                mcrush_width = pogItem.RW - pogItem.RW * (crush_width / 100);
                                if (p_setInd == "Y") {
                                    pogItem.W = mcrush_width;
                                    pogItem.CrushHoriz = crush_width;
                                }
                            }*/
                            //check if available space is > 0. then pass the crusing and break loop.
                            new_avilable_space = pogShelf.W + pogShelf.ROverhang + pogShelf.LOverhang - new_item_sum; // + mcrush_width; //ASA-1791 Task 3 Added Overhang 
                            if (new_avilable_space >= 0) {
                                new_crush_perc = i;
                                if (i > 0 || mcrush_ind == "Y") {
                                    //ASA-1353 regression issue//Task-01_27858 issue 14 20240530
                                    crush_item_ind = "Y";
                                    if (p_itemIndex !== -1 && crush_index_arr.indexOf(p_itemIndex) !== -1 && p_setInd == "Y") {
                                        pogShelf.ItemInfo[p_itemIndex].WChanged = "Y";
                                    }
                                }
                                break;
                            }
                        }
                        //if crush was not success or not needed. then reset crush perc to old value.
                        if (crush_item_ind == "N") {
                            var j = 0;
                            if (new_crush_perc > 0) {
                                ////ASA-1353 issue 3 regression issue 20240428
                                for (const items of crush_index_arr) {
                                    if (crush_manual_arr[j] == "N") {
                                        //ASA-1353 issue 3 --Task_27104
                                        pogShelf.ItemInfo[crush_index_arr[j]].W = crush_width_arr[j];
                                        pogShelf.ItemInfo[crush_index_arr[j]].CrushHoriz = crush_horiz_arr[j];
                                    }
                                    j++;
                                }
                            }
                            g_error_category = "W";
                            return_val = "N"; //UAT issue 9 Item Sizes are reverted for Crushed Items after Mass Update.
                        } else {
                            g_error_category = "";
                            return_val = "Y"; //UAT issue 9 Item Sizes are reverted for Crushed Items after Mass Update.
                        }
                    } else if (crush_item_ind == "Y" && hasFixedDivider) {
                        return_val = widthCrushItemWithFixedDivider(p_pog_index, p_moduleIndex, p_shelfIndex, p_itemIndex, p_setInd); //ASA-1597
                    } else if (width_manualCrush == "Y" && crush_item_ind == "N") {
                        //if there was no crush perc for any item and current item has manual crush then manually crush.
                        var mcrush_width = pogItem.RW - pogItem.RW * (crush_width / 100);
                        if (p_setInd == "Y") {
                            pogItem.W = mcrush_width;
                            pogItem.WChanged = "Y";
                            pogItem.CrushHoriz = crush_width;
                        }
                    } else {
                        return_val = "F"; //No items with crush > 0, run facing logic//UAT issue 9 Item Sizes are reverted for Crushed Items after Mass Update.
                    }
                }
            }
            //Depth crush is done here.
            if (p_crushType == "D" || p_crushType == "A") {
                var new_depth_arr = [],
                    new_index_arr = [],
                    new_manl_arr = [],
                    crush_item_ind = "N",
                    manualDCrush = "N";
                //we are using g_json if crushitem is called from create_shelf_from_json_lib. because g_pog_json will till current item and other shelfs and items
                //in that module will not yet populated because shelfs and items are populated one by one in loop in create_shelf_from_json_lib.
                //so we cannot find any shelf above the current shelf in g_pog_json. so use g_json.
                //Note: we are find the nearby shelf max depth because if any item hit on shelf on top. we need to crush that item till it will not hit the top shelf.
                if (p_on_load == "Y" && typeof g_json[0] !== "undefined") {
                    // ASA-1442 issue 7 S
                    var topdepth = onload_findNearByShelfMaxDepth(p_moduleIndex, p_shelfIndex, p_itemIndex, p_itemIndex, -1, 0, g_json); //ASA-1442 issue 5 added due to medicine shelf  if item current present in medicine shelf
                } else {
                    var topdepth = findNearByShelfMaxDepth(p_moduleIndex, p_shelfIndex, p_itemIndex, p_itemIndex, -1, p_pog_index); //ASA-1442 issue 5 added due to medicine shelf  if item current present in medicine shelf
                } // ASA-1442 issue 7 E
                //check all the items in the p_itemDepthArr and populate the array with item which have crush perc.
                for (i = 0; i < p_itemDepthArr.length; i++) {
                    /*if (actualHeight == "D") {//Task_26899
                        manualDCrush = typeof pogShelf.ItemInfo[p_itemDepthIndxArr[i]].MVertCrushed == "undefined" || pogShelf.ItemInfo[p_itemDepthIndxArr[i]].MVertCrushed == "N" ? "N" : "Y";
                    } else {*/
                    manualDCrush = typeof pogShelf.ItemInfo[p_itemDepthIndxArr[i]].MDepthCrushed == "undefined" || pogShelf.ItemInfo[p_itemDepthIndxArr[i]].MDepthCrushed == "N" ? "N" : "Y";
                    //}
                    if (p_itemDepthArr[i] > pogShelf.D - topdepth || manualDCrush == "Y") {
                        //ASA-1442 issue 5
                        new_depth_arr.push(p_itemDepthArr[i]);
                        new_index_arr.push(p_itemDepthIndxArr[i]);
                        new_manl_arr.push(manualDCrush);
                    }
                }
                var crush_value = 0,
                    crushVal = 0;
                //run the loop of all the items which have crush perc and try to crush.
                for (i = 0; i < new_depth_arr.length; i++) {
                    var orientation = pogShelf.ItemInfo[new_index_arr[i]].Orientation; //Task_26899
                    var [item_owidth, item_oheight, item_odepth, wActualHeight, wActualWidth, wActualDepth] = get_new_orientation_dim(orientation, 0, 0, 0); //Task_26899
                    //Start Task_26899
                    //get crush perc of each item based on changed dim due to orientation.
                    if (wActualDepth == "W") {
                        crushVal = manualDCrush == "N" && pogShelf.ItemInfo[new_index_arr[i]].CWPerc > 0 ? pogShelf.ItemInfo[new_index_arr[i]].CWPerc : pogShelf.ItemInfo[new_index_arr[i]].CrushHoriz;
                    } else if (wActualDepth == "H") {
                        crushVal = manualDCrush == "N" && pogShelf.ItemInfo[new_index_arr[i]].CHPerc > 0 ? pogShelf.ItemInfo[new_index_arr[i]].CHPerc : pogShelf.ItemInfo[new_index_arr[i]].CrushVert;
                    } else if (wActualDepth == "D") {
                        crushVal = manualDCrush == "N" && pogShelf.ItemInfo[new_index_arr[i]].CDPerc > 0 ? pogShelf.ItemInfo[new_index_arr[i]].CDPerc : pogShelf.ItemInfo[new_index_arr[i]].CrushD;
                    }

                    /*if (actualHeight == "D") {
                        var heightPerc = pogShelf.ItemInfo[new_index_arr[i]].CrushVert;
                        var heightPercMax = pogShelf.ItemInfo[new_index_arr[i]].CHPerc;
                        crushVal = manualDCrush == "N" && heightPercMax > 0 ? heightPercMax : heightPerc;//Task_26899
                    } else {
                        var deptPerc = pogShelf.ItemInfo[new_index_arr[i]].CrushD;
                        var deptPercMax = pogShelf.ItemInfo[new_index_arr[i]].CDPerc;
                        crushVal = manualDCrush == "N" && heightPercMax > 0 ? deptPercMax : deptPerc;//Task_26899
                    }*/
                    //End Task_26899
                    // we should minus topdepth from shelf D. to get the available shelf depth and then check with item D.
                    if (crushVal > 0 && (p_itemDepthArr[i] > pogShelf.D - topdepth || new_manl_arr[i] == "Y")) {
                        //ASA-1442 issue 5
                        var new_depth = 0; //Regression issue 14
                        var depth = pogShelf.ItemInfo[new_index_arr[i]].D;
                        var facing = pogShelf.ItemInfo[new_index_arr[i]].BaseD;
                        var real_depth = pogShelf.ItemInfo[new_index_arr[i]].RD; //depth * facing; VIVEKK
                        //if not manual crush then run the loop of crush perc and try to check the value is pass.
                        if (new_manl_arr[i] == "N") {
                            for (j = 0; j <= crushVal; j++) {
                                new_depth = real_depth - (real_depth * j) / 100;
                                if (pogShelf.D - topdepth >= new_depth) {
                                    //ASA-1442 issue 5
                                    crush_index_arr.push(new_index_arr[i]);
                                    crush_item_ind = "Y";
                                    crush_value = j;
                                    break;
                                }
                            }
                        } else {
                            //if manual crush. just crush the item with crush perc mentioned by user.
                            new_depth = real_depth - (real_depth * crushVal) / 100;
                            crush_index_arr.push(new_index_arr[i]);
                            crush_item_ind = "Y";
                            crush_value = crushVal;
                        }
                    }
                }
                //if crush was not successfull or not needed then set back to old values.
                if (crush_item_ind == "N") {
                    //ASA-1442 Issue 1
                    for (i = 0; i < p_itemDepthArr.length; i++) {
                        if (wpdSetFixed(pogShelf.ItemInfo[p_itemDepthIndxArr[i]].D) !== wpdSetFixed(pogShelf.ItemInfo[p_itemDepthIndxArr[i]].RD)) {
                            var orientation = pogShelf.ItemInfo[p_itemDepthIndxArr[i]].Orientation; //Task_26899
                            var [item_owidth, item_oheight, item_odepth, wActualHeight, wActualWidth, wActualDepth] = get_new_orientation_dim(orientation, 0, 0, 0); //Task_26899
                            if (manualDCrush == "N") {
                                if (wActualDepth == "W") {
                                    //ASA-1353 issue 3 20240424
                                    pogShelf.ItemInfo[p_itemDepthIndxArr[i]].CrushHoriz = 0;
                                } else if (wActualDepth == "H") {
                                    pogShelf.ItemInfo[p_itemDepthIndxArr[i]].CrushVert = 0;
                                } else if (wActualDepth == "D") {
                                    pogShelf.ItemInfo[p_itemDepthIndxArr[i]].CrushD = 0;
                                }
                            }
                        }
                    }
                }
                //if crush was successful then set the new crush value and D for each items.
                if (crush_item_ind == "Y" && p_itemDepthArr.length == crush_index_arr.length && p_setInd == "Y") {
                    for (i = 0; i < crush_index_arr.length; i++) {
                        var new_depth = pogShelf.ItemInfo[crush_index_arr[i]].RD - pogShelf.ItemInfo[crush_index_arr[i]].RD * (crush_value / 100);
                        pogShelf.ItemInfo[crush_index_arr[i]].D = new_depth;
                        pogShelf.ItemInfo[crush_index_arr[i]].CrushD = crush_value;
                    }
                    if (p_itemIndex !== -1) {
                        pogShelf.ItemInfo[p_itemIndex].DChanged = "Y";
                    }
                    g_error_category = "";
                    return_val = "Y"; //UAT issue 9 Item Sizes are reverted for Crushed Items after Mass Update.
                } else {
                    g_error_category = "D";
                    return_val = "N"; //UAT issue 9 Item Sizes are reverted for Crushed Items after Mass Update.
                }
            }
            /*if (pogItem.MassCrushH == "Y" && auto_h_crush == "Y") { //Task-02_25977 KUSH FOR MASS UPDATE FOR AUTO CRUSH IN CHEST////ASA-1353 issue 3 regression issue 20240428
                pogItem.MHorizCrushed = "N";
                pogItem.MassCrushH = 'N';
            }
            if (pogItem.MassCrushV == "Y" && auto_v_crush == "Y") { //Task-02_25977 KUSH FOR MASS UPDATE FOR AUTO CRUSH IN CHEST
                pogItem.MVertCrushed = "N";
                pogItem.MassCrushV = 'N';
            }
            if (pogItem.MassCrushD == "Y" && auto_d_crush == "Y") { //Task-02_25977 KUSH FOR MASS UPDATE FOR AUTO CRUSH IN CHEST
                pogItem.MDepthCrushed = "N";
                pogItem.MassCrushD = 'N';
            }*/
            return return_val; //UAT issue 9 Item Sizes are reverted for Crushed Items after Mass Update.
        }
    } catch (err) {
        error_handling(err);
        throw err;
    }
}

//ASA-1405
/*function check_chest_area_item_hit(p_check_type, p_item, p_items_list, p_shelf, p_height, p_width, p_depth, p_item_index) {
    try {
        var l_cnt = 0,
            l_valid_depth = "Y",
            l_valid_height = "Y",
            l_valid_width = "Y",
            l_hit = "N",
            l_hit_cnt = 0,
            l_hit_dirc_horz = "", //ASA-1405 Issue 2
            l_hit_dirc_vert = ""; //ASA-1405 Issue 2
        if ((p_check_type == "D" || p_check_type == "A") && p_depth > p_shelf.BsktWallH) {
            l_valid_depth = "N";
        }
        var item_start = (minX = parseFloat((p_item.X - p_width / 2).toFixed(4))),
            item_end = (maxX = parseFloat((p_item.X + p_width / 2).toFixed(4))),
            item_top = (maxY = parseFloat((p_item.Y + p_height / 2).toFixed(4))),
            item_bottom = (minY = parseFloat((p_item.Y - p_height / 2).toFixed(4)));
 
        if (p_check_type == "H" || p_check_type == "W" || p_check_type == "A" || p_check_type == "C" || p_check_type == "HC" || p_check_type == "WC") {
            for (const items of p_items_list) {
                if (l_cnt !== p_item_index) {
                    var div_start = parseFloat((items.X - items.W / 2).toFixed(4)),
                        div_end = parseFloat((items.X + items.W / 2).toFixed(4)),
                        div_top = parseFloat((items.Y + items.H / 2).toFixed(4)),
                        div_bottom = parseFloat((items.Y - items.H / 2).toFixed(4));
                    if (!(item_top < div_bottom || item_bottom > div_top) && !(item_end < div_start || item_start > div_end)) {
                        l_hit = "Y";
                        if (item_top > div_bottom && div_bottom > item_bottom) {
                            maxY = Math.min(maxY, div_bottom);
                            l_hit_dirc_vert = "T";
                            l_hit_cnt++;
                        }
                        if (item_end > div_start && div_start > item_start) {
                            maxX = Math.min(maxX, div_start);
                            l_hit_dirc_horz = "R";
                            l_hit_cnt++;
                        }
                        if (item_start < div_end && div_end < item_end) {
                            minX = Math.max(minX, div_end);
                            l_hit_dirc_horz = "L";
                            l_hit_cnt++;
                        }
                        if (item_bottom < div_top && div_top < item_top) {
                            minY = Math.max(minY, div_top);
                            l_hit_dirc_vert = "B";
                            l_hit_cnt++;
                        }
                    }
                }
                l_cnt++;
            }
            if (l_hit == "Y") {
                // Calculate the available width and height for item to be crushed
                const availableWidth = parseFloat(Math.abs(maxX - minX).toFixed(4)); //ASA-1405 issue 2, 3
                const availableHeight = parseFloat(Math.abs(maxY - minY).toFixed(4)); //ASA-1405 issue 2, 3
                if ((p_check_type == "W" || p_check_type == "A" || p_check_type == "WC") && p_width > availableWidth) {
                    l_valid_width = "N";
                }
                if ((p_check_type == "H" || p_check_type == "A" || p_check_type == "HC") && p_height > availableHeight) {
                    l_valid_height = "N";
                }
            } else {
                var shelf_start = parseFloat(p_shelf.X - p_shelf.W / 2).toFixed(4);
                var shelf_end = parseFloat(p_shelf.X + p_shelf.W / 2).toFixed(4);
                var shelf_bottom = parseFloat(p_shelf.Y - p_shelf.H / 2).toFixed(4);
                var shelf_top = parseFloat(p_shelf.Y + p_shelf.H / 2).toFixed(4);
                if ((p_check_type == "W" || p_check_type == "A" || p_check_type == "WC") && (parseFloat(item_start) < parseFloat(shelf_start) || parseFloat(item_end) > parseFloat(shelf_end))) {
                    l_hit = "Y";
                    l_valid_width = "N";
                }
                if ((p_check_type == "H" || p_check_type == "A" || p_check_type == "HC") && (parseFloat(item_bottom) < parseFloat(shelf_bottom) || parseFloat(item_top) > parseFloat(shelf_top))) {
                    l_hit = "Y";
                    l_valid_height = "N";
                }
            }
        }
 
        return [l_valid_width, l_valid_height, l_valid_depth, l_hit, l_hit_cnt, l_hit_dirc_horz, l_hit_dirc_vert];
    } catch (err) {
        error_handling(err);
        throw err;
    }
}*/

//End ASA1310_20240307 crush item onload

//Start ASA-1350 issue 6
async function recreate_all_items(p_module_index, p_shelf_index, p_shelf_obj_type, p_edit_ind, p_locationX, p_edit_item_index, p_item_length, p_fresh_item, p_shelf_edit, p_redoX, p_items_list, p_create_canvas, p_calc_supply, p_pog_index, p_pogcrDelistItemDftColor, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_merge_items = "Y", p_itemInsidePeg = "Y") {
    logDebug("function : recreate_all_items; p_module_index : " + p_module_index + "; p_shelf_index : " + p_shelf_index + "; shelf_obj_type : " + p_shelf_obj_type + "; p_edit_ind : " + p_edit_ind + "; locationX : " + p_locationX + "; edit_item_index : " + p_edit_item_index + "; item_length : " + p_item_length + "; shelf_edit : " + p_shelf_edit + "; redoX : " + p_redoX + "; create_canvas : " + p_create_canvas, "S");
    try {
        //ASA-1129, start
        var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index]; //ASA-1350 issue 6 converted whole length declaration to variable.
        var spread_product = shelfdtl.SpreadItem;
        var shelfCount = 1,
            [currCombinationIndex, currShelfCombIndx] = [-1, -1];
        (currCombinationIndex = -1), (currShelfCombIndx = -1);
        //check if current shelf that is sent for recreate is a part of combined shelf or not.
        if ((shelfdtl.ObjType == "SHELF" || shelfdtl.ObjType == "HANGINGBAR") && shelfdtl.Combine !== "N") {
            [currCombinationIndex, currShelfCombIndx] = getCombinationShelf(p_pog_index, shelfdtl.Shelf);
        }
        //if the shelf is a part of combine shelf then set all the items relative x and y and also populate them in the g_combineShelfs array.
        if (currCombinationIndex !== -1 && currShelfCombIndx !== -1) {
            shelfCount = g_combinedShelfs[currCombinationIndex].length;
            await setCombinedShelfItems(p_pog_index, currCombinationIndex, currShelfCombIndx, p_locationX, p_edit_ind, p_shelf_edit, p_redoX, p_edit_item_index, []); //ASA-1239
        }
        g_world = g_scene_objects[p_pog_index].scene.children[2];
        //if the shelf sent is a part of combined shelf then. run loop on all the shelfs in the combine set and recreate all of them.
        for (var s = 0; s < shelfCount; s++) {
            //get p_module_index and p_shelf_index for current shelf in combined shelfs set.
            if (currCombinationIndex !== -1 && currShelfCombIndx !== -1 && shelfCount > 1) {
                p_module_index = g_combinedShelfs[currCombinationIndex][s].MIndex;
                p_shelf_index = g_combinedShelfs[currCombinationIndex][s].SIndex;
                spread_product = g_combinedShelfs[currCombinationIndex].SpreadItem;
            }
            console.log("recreate all items ", p_module_index, p_shelf_index, p_shelf_obj_type, p_edit_ind, p_locationX, p_edit_item_index, p_item_length, p_fresh_item, p_shelf_edit, p_redoX, p_items_list, p_create_canvas, p_calc_supply, p_pog_index);
            var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index]; //ASA-1350 issue 6 combine shelf will change items positions.
            var imageFlag = g_show_live_image; //create_canvas == "-1" ? g_show_live_image : create_canvas == 1 ? g_show_live_image : g_show_live_image_comp;
            var spread_gap = shelfdtl.HorizGap;
            var horiz_gap = spread_gap;
            var combine_ind = shelfdtl.Combine;
            var rotation = shelfdtl.Rotation;
            var shelf_start_X = shelfdtl.X - shelfdtl.W / 2;
            var shelf_start_Y = shelfdtl.Y - shelfdtl.H / 2;
            var total_item_width = 0,
                items_arr = [];
            var finalX = 0;

            if (p_items_list !== -1 && p_items_list !== "" && typeof p_items_list !== "undefined") {
                var items_arr = p_items_list;
            } else {
                var items_arr = shelfdtl.ItemInfo;
            }

            // ASA-1095, Start
            //This is a logic to merge same adjacent items by adding facings when they are place one after the other.
            //Note: in page 25 this parameter is passed as Y by default.
            if (shelfdtl.ObjType == "SHELF" && (shelfdtl.SpreadItem == "L" || shelfdtl.SpreadItem == "R") && p_merge_items == "Y") {
                //ASA-1350 issue 6 no need to merge when calling from other pages.
                var i = 0;
                for (item of shelfdtl.ItemInfo) {
                    var merged_item_index = mergeAdjacentItems(p_pog_index, p_module_index, p_shelf_index, i);
                    i++;
                }
            }
            var item_cnt = shelfdtl.ItemInfo.length;
            // ASA-1095, End
            //remove all the items from world for that shelf.
            var i = 0;
            for (const items of items_arr) {
                var selectedObject = g_world.getObjectById(items.ObjID);
                g_world.remove(selectedObject);
                total_item_width += items.W;
                i++;
            }

            shelfdtl.AvlSpace = shelfdtl.W + shelfdtl.LOverhang + shelfdtl.ROverhang;

            //This code will run the spread product = RIGHT. because loop has to run in reverse
            if (spread_product == "R") {
                var items_arr = shelfdtl.ItemInfo;
                if (shelfdtl.ObjType !== "PEGBOARD" && !(shelfdtl.ObjType == "CHEST" && g_chest_as_pegboard == "Y")) {
                    //ASA-1765
                    var fixedItemPresent = items_arr.some((items) => items.Fixed === "Y");
                    if (!(spread_product == "R" && fixedItemPresent && (shelfdtl.ObjType == "HANGINGBAR" || shelfdtl.ObjType == "SHELF"))) {
                        //ASA-1327
                        var sorto = {
                            X: "asc",
                        };
                        items_arr.keySort(sorto);
                    }
                }

                for (var i = items_arr.length - 1; i >= 0; i--) {
                    item_cnt = item_cnt - 1;
                    //getting x axis starting from the right corner item. will be at the end of the shelf.
                    finalX = get_item_xaxis(items_arr[i].W, items_arr[i].H, items_arr[i].D, p_shelf_obj_type, p_locationX, horiz_gap, spread_product, spread_gap, p_module_index, p_shelf_index, item_cnt, p_edit_ind, shelfdtl.ItemInfo.length, p_shelf_edit, p_pog_index, p_itemInsidePeg);
                    //We need to set the divider shelfinfo with the new details of X and hold the div_index to update the objID too.
                    if (items_arr[i].Item == "DIVIDER") {
                        var shelf_arr = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo;
                        var div_index = -1;
                        var ShelfInfo = {};
                        var j = 0;
                        for (const shelfs of shelf_arr) {
                            if (shelfs.Shelf == items_arr[i].ItemID && shelfs.ObjType == "DIVIDER") {
                                div_index = j;
                            }
                            j++;
                        }
                        if (div_index > -1) {
                            g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[div_index].X = finalX;
                        }
                    }

                    shelfdtl.ItemInfo[item_cnt].Distance = finalX - items_arr[i].W / 2 - shelf_start_X;
                    if (shelfdtl.ObjType == "PEGBOARD" || (shelfdtl.ObjType == "CHEST" && g_chest_as_pegboard == "Y")) {
                        //ASA-1125
                        shelfdtl.ItemInfo[item_cnt].PegBoardX = finalX - items_arr[i].W / 2 - shelf_start_X;
                        shelfdtl.ItemInfo[item_cnt].PegBoardY = shelfdtl.ItemInfo[item_cnt].Y - items_arr[i].H / 2 - shelf_start_Y;
                        shelfdtl.ItemInfo[item_cnt].FromProductList = "N";
                    }
                    shelfdtl.ItemInfo[item_cnt].OldObjID = items_arr[i].ObjID;
                    var old_obj_id = items_arr[i].ObjID,
                        objID;

                    if (imageFlag == "Y" && items_arr[i].Item !== "DIVIDER" && items_arr[i].MerchStyle != 3) {
                        var details = g_orientation_json[shelfdtl.ItemInfo[item_cnt].Orientation];
                        var details_arr = details.split("###");
                        objID = await add_items_with_image(items_arr[i].ItemID, items_arr[i].W, items_arr[i].H, items_arr[i].D, items_arr[i].Color, finalX, items_arr[i].Y, "", p_module_index, p_shelf_index, i, items_arr[i].BHoriz, items_arr[i].BVert, items_arr[i].Item, parseInt(details_arr[0]), parseInt(details_arr[1]), "N", p_fresh_item, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_pog_index);
                    } else {
                        if (items_arr[i].Item == "DIVIDER") {
                            objID = add_items(items_arr[i].ItemID, items_arr[i].W, items_arr[i].H, items_arr[i].D, items_arr[i].Color, finalX, items_arr[i].Y, "", p_module_index, p_shelf_index, i, items_arr[i].Rotation, p_pog_index);
                        } else {
                            objID = await add_items_prom(items_arr[i].ItemID, items_arr[i].W, items_arr[i].H, items_arr[i].D, items_arr[i].Color, finalX, items_arr[i].Y, "", p_module_index, p_shelf_index, i, "N", p_fresh_item, p_pogcrDelistItemDftColor, "", p_pogcrDisplayItemInfo, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pog_index);
                        }
                    }
                    //this array is used in set back MIndex, SIndex and of the item after recreate. because the item could have been moved to different shelf
                    //based on the spread product. so we need to get the new index of the item after recreate the shelfs.
                    for (var m = 0; m < g_combineItemModf.length; m++) {
                        if (g_combineItemModf[m].NewMIndex == p_module_index && g_combineItemModf[m].NewSIndex == p_shelf_index && g_combineItemModf[m].OldObjID == old_obj_id) {
                            g_combineItemModf[m]["NewObjID"] = objID;
                        }
                    }
                    //setting the border of each item based on the conditoin.
                    var selectedObject = g_world.getObjectById(objID);
                    if (items_arr[i].DimUpdate == "E") {
                        selectedObject.BorderColour = g_dim_error_color;
                        selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                    } else if (items_arr[i].Status == "N") {
                        selectedObject.BorderColour = g_status_error_color;
                        selectedObject.Status = "N";
                        selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                    } else if (nvl(items_arr[i].MovingItem) == "No" && g_pogcr_auto_hlite_non_mv_item == "Y") {
                        selectedObject.BorderColour = g_nonMovingItemColor;
                        selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                    } else {
                        if (nvl(items.OOSPerc) > 80 && g_pogcr_enbl_oos_border == "Y") {
                            //ASA-1688
                            selectedObject.BorderColour = g_pogcr_oos_border_color; //ASA-1688 Added to give blue border to item
                            selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                        } else {
                            selectedObject.BorderColour = 0x000000;
                        }
                    }
                    var l_final_z = 0;
                    if (shelfdtl.ObjType == "PEGBOARD") {
                        l_final_z = shelfdtl.Z + shelfdtl.D / 2 + items_arr[i].D / 2;
                    } else if (shelfdtl.ObjType == "PALLET") {
                        if (shelfdtl.ItemInfo[i].Edited == "N") {
                            l_final_z = +(items_arr[i].D / 2);
                        } else {
                            l_final_z = shelfdtl.ItemInfo[i].Z;
                        }
                    } else {
                        l_final_z = 0.001 + shelfdtl.D / 1000;
                    }
                    shelfdtl.ItemInfo[i].X = finalX;
                    shelfdtl.ItemInfo[i].Z = l_final_z;
                    shelfdtl.ItemInfo[i].ObjID = objID;
                    shelfdtl.ItemInfo[i].CType = shelfdtl.ObjType;

                    //if the item is a top or bottom item. then we need to reset the object ID set in each item to identify which item is on top and which is below.
                    if ((typeof items_arr[i].TopObjID !== "undefined" && items_arr[i].TopObjID !== "") || (typeof items_arr[i].BottomObjID !== "undefined" && items_arr[i].BottomObjID !== "")) {
                        var tier_ind;
                        if (items_arr[i].TopObjID !== "" && typeof items_arr[i].TopObjID !== "undefined") {
                            tier_ind = "BOTTOM";
                        } else {
                            tier_ind = "TOP";
                        }
                        var returnval = reset_top_bottom_obj_id(tier_ind, old_obj_id, objID, finalX, "N", p_pog_index);
                    }

                    if (items_arr[i].Item == "DIVIDER") {
                        g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[div_index].ShelfDivObjID = objID;
                    }
                }
            } else {
                var i = 0;
                var items_arr = shelfdtl.ItemInfo;
                if (shelfdtl.ObjType !== "PEGBOARD" && !(shelfdtl.ObjType == "CHEST" && g_chest_as_pegboard == "Y")) {
                    //ASA-1765
                    var fixedItemPresent = items_arr.some((items) => items.Fixed === "Y");
                    if (!(spread_product == "L" && fixedItemPresent && (shelfdtl.ObjType == "HANGINGBAR" || shelfdtl.ObjType == "SHELF"))) {
                        //ASA-1327
                        var sorto = {
                            X: "asc",
                        };
                        //ASA-1970 Issue1 Start
                        if (g_allowItemSort == "Y") {
                            items_arr.keySort(sorto);
                        };
                        //ASA-1970 Issue1 End
                    }
                }
                for (const items of items_arr) {
                    if (p_redoX !== -1 && i == p_edit_item_index) {
                        finalX = p_redoX;
                    } else {
                        finalX = get_item_xaxis(items.W, items.H, items.D, p_shelf_obj_type, p_locationX, horiz_gap, spread_product, spread_gap, p_module_index, p_shelf_index, i, p_edit_ind, shelfdtl.ItemInfo.length, p_shelf_edit, p_pog_index, p_itemInsidePeg);
                    }
                    //We need to set the divider shelfinfo with the new details of X and hold the div_index to update the objID too.
                    if (items.Item == "DIVIDER") {
                        var shelf_arr = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo;
                        var div_index = -1;
                        var ShelfInfo = {};
                        var j = 0;
                        for (const shelfs of shelf_arr) {
                            if (shelfs.Shelf == items.ItemID && shelfs.ObjType == "DIVIDER") {
                                div_index = j;
                            }
                            j++;
                        }
                        if (div_index > -1) {
                            g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[div_index].X = finalX;
                        }
                    }
                    shelfdtl.ItemInfo[i].Distance = finalX - items.W / 2 - shelf_start_X;
                    if (shelfdtl.ObjType == "PEGBOARD" || (shelfdtl.ObjType == "CHEST" && g_chest_as_pegboard == "Y")) {
                        //ASA-1125
                        shelfdtl.ItemInfo[i].PegBoardX = finalX - items.W / 2 - shelf_start_X;
                        shelfdtl.ItemInfo[i].PegBoardY = shelfdtl.ItemInfo[i].Y - items.H / 2 - shelf_start_Y;
                        shelfdtl.ItemInfo[i].FromProductList = "N";
                    }
                    shelfdtl.ItemInfo[i].OldObjID = items.ObjID;
                    var old_obj_id = items.ObjID,
                        objID;
                    if (imageFlag == "Y" && items.Item !== "DIVIDER" && items_arr[i].MerchStyle != 3) {
                        var details = g_orientation_json[shelfdtl.ItemInfo[i].Orientation];
                        var details_arr = details.split("###");
                        objID = await add_items_with_image(items.ItemID, items.W, items.H, items.D, items.Color, finalX, shelfdtl.ItemInfo[i].Y, "", p_module_index, p_shelf_index, i, items.BHoriz, items.BVert, items.Item, parseInt(details_arr[0]), parseInt(details_arr[1]), "N", p_fresh_item, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_pog_index);
                    } else {
                        if (items.Item == "DIVIDER") {
                            objID = add_items(items.ItemID, items.W, items.H, items.D, items.Color, finalX, items.Y, "", p_module_index, p_shelf_index, i, items.Rotation, p_pog_index);
                        } else {
                            objID = await add_items_prom(items.ItemID, items.W, items.H, items.D, items.Color, finalX, shelfdtl.ItemInfo[i].Y, "", p_module_index, p_shelf_index, i, "N", p_fresh_item, p_pogcrDelistItemDftColor, "", p_pogcrDisplayItemInfo, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pog_index);
                        }
                    }
                    //this array is used in set back MIndex, SIndex and of the item after recreate. because the item could have been moved to different shelf
                    //based on the spread product. so we need to get the new index of the item after recreate the shelfs.
                    for (var m = 0; m < g_combineItemModf.length; m++) {
                        if (g_combineItemModf[m].NewMIndex == p_module_index && g_combineItemModf[m].NewSIndex == p_shelf_index && g_combineItemModf[m].OldObjID == old_obj_id) {
                            g_combineItemModf[m]["NewObjID"] = objID;
                        }
                    }
                    //setting the border of each item based on the conditoin.
                    var selectedObject = g_world.getObjectById(objID);
                    if (items.DimUpdate == "E") {
                        selectedObject.BorderColour = g_dim_error_color;
                        selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                    } else if (items.Status == "N") {
                        selectedObject.BorderColour = g_status_error_color;
                        selectedObject.Status = "N";
                        selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                    } else if (nvl(items.MovingItem) == "No" && g_pogcr_auto_hlite_non_mv_item == "Y") {
                        selectedObject.BorderColour = g_nonMovingItemColor;
                        selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                    } else {
                        if (nvl(items.OOSPerc) > 80 && g_pogcr_enbl_oos_border == "Y") {
                            //ASA-1688
                            selectedObject.BorderColour = g_pogcr_oos_border_color; //ASA-1688 Added to give blue border to item
                            selectedObject.WireframeObj.material.color.setHex(selectedObject.BorderColour);
                        } else {
                            selectedObject.BorderColour = 0x000000;
                        }
                    }
                    if (shelfdtl.ObjType == "PEGBOARD") {
                        l_final_z = shelfdtl.Z + shelfdtl.D / 2 + items.D / 2;
                    } else if (shelfdtl.ObjType == "PALLET") {
                        if (items.Edited == "N" && (typeof items.TopObjID == "undefined" || items.TopObjID == "") && typeof items.BottomObjID == "undefined" && items.BottomObjID == "") {
                            l_final_z = +(items.D / 2);
                        } else {
                            l_final_z = shelfdtl.ItemInfo[i].Z;
                        }
                    } else {
                        l_final_z = 0.001 + shelfdtl.D / 1000;
                    }

                    shelfdtl.ItemInfo[i].X = finalX;
                    shelfdtl.ItemInfo[i].Z = l_final_z;
                    shelfdtl.ItemInfo[i].ObjID = objID;
                    shelfdtl.ItemInfo[i].CType = shelfdtl.ObjType;
                    //if the item is a top or bottom item. then we need to reset the object ID set in each item to identify which item is on top and which is below.
                    if ((typeof items.TopObjID !== "undefined" && items.TopObjID !== "") || (typeof items.BottomObjID !== "undefined" && items.BottomObjID !== "")) {
                        var tier_ind;
                        if (items.TopObjID !== "" && typeof items.TopObjID !== "undefined") {
                            tier_ind = "BOTTOM";
                        } else {
                            tier_ind = "TOP";
                        }
                        var returnval = reset_top_bottom_obj_id(tier_ind, old_obj_id, objID, finalX, "N", p_pog_index);
                    }

                    if (items.Item == "DIVIDER" && div_index > -1) {
                        g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[div_index].ShelfDivObjID = objID;
                    }
                    i = i + 1;
                }
                console.log("finished loop ", p_module_index, p_shelf_index, shelfdtl.Shelf, getDateTime());
            }

            var items_arr = shelfdtl.ItemInfo;
            i = 0;
            for (const items of items_arr) {
                if ((typeof items.TopObjID !== "undefined" && items.TopObjID !== "") || (typeof items.BottomObjID !== "undefined" && items.BottomObjID !== "")) {
                    var tier_ind;
                    if (items.TopObjID !== "" && typeof items.TopObjID !== "undefined") {
                        tier_ind = "BOTTOM";
                    } else {
                        tier_ind = "TOP";
                    }
                    var returnval = reset_top_bottom_obj_id(tier_ind, items.OldObjID, items.ObjID, items.X, "Y", p_pog_index);
                }
                i = i + 1;
            }
            if (shelfdtl.ObjType == "SHELF" || shelfdtl.ObjType == "PALLET") {
                var returnval = reset_top_bottom_objects(p_module_index, p_shelf_index, "N", p_pog_index);
            }
            if (p_calc_supply == "") {
                var res = await calculateFixelAndSupplyDays("N", p_pog_index);
            }
            if (g_show_live_image == "Y" && g_canvas_objects.length > 0) {
                //Regression Issue 5
                animate_pog(p_pog_index);
            }
            g_item_edit_flag = "";
            g_item_index = "";
        }
        logDebug("function : recreate_all_items", "E");
        return finalX;
    } catch (err) {
        console.log("err", err);
        error_handling(err);
    }
}

//This function is used to reset TopObjID amd BottomObjID after recreate the items. this is necessary to identify which item is on top and which is below.
async function reset_top_bottom_obj_id(p_tier_ind, p_old_id, p_new_id, p_bottom_x, p_reset, p_pog_index) {
    logDebug("function : reset_top_bottom_obj_id; tier_ind : " + p_tier_ind + "; old_id : " + p_old_id + "; new_id : " + p_new_id + "; bottom_x : " + p_bottom_x + "; reset : " + p_reset, "S");
    var module_details = g_pog_json[p_pog_index].ModuleInfo;
    var j = 0;
    for (const Modules of module_details) {
        if (Modules.ParentModule == null || Modules.ParentModule == "undefined") {
            var k = 0;
            for (const Shelf of Modules.ShelfInfo) {
                if (typeof Shelf !== "undefined") {
                    if (Shelf.ObjType == "SHELF" || Shelf.ObjType == "PALLET") {
                        if (Shelf.ItemInfo.length > 0) {
                            var l = 0;
                            for (const items of Shelf.ItemInfo) {
                                if (p_reset == "Y" && p_tier_ind == "BOTTOM" && items.BottomObjID == p_new_id) {
                                    g_pog_json[p_pog_index].ModuleInfo[j].ShelfInfo[k].ItemInfo[l].X = p_bottom_x;
                                    selected_object = g_world.getObjectById(g_pog_json[p_pog_index].ModuleInfo[j].ShelfInfo[k].ItemInfo[l].ObjID);
                                    selected_object.position.set(p_bottom_x, items.Y, 0.001 + g_pog_json[p_pog_index].ModuleInfo[j].ShelfInfo[k].D / 1000);
                                }
                                if (p_tier_ind == "TOP" && items.TopObjID == p_old_id && p_reset == "N") {
                                    g_pog_json[p_pog_index].ModuleInfo[j].ShelfInfo[k].ItemInfo[l].TopObjID = p_new_id;
                                } else if (p_tier_ind == "BOTTOM" && items.BottomObjID == p_old_id) {
                                    g_pog_json[p_pog_index].ModuleInfo[j].ShelfInfo[k].ItemInfo[l].BottomObjID = p_new_id;
                                }
                                l++;
                            }
                        }
                    }
                }
                k++;
            }
        }
        j++;
    }
    logDebug("function : reset_top_bottom_obj_id", "E");
    return "SUCCESS";
}

function get_shelf_index(p_obj_id, p_pog_index) {
    logDebug("function : get_shelf_index; obj_id : " + p_obj_id, "S");
    var l_module_index = (l_shelf_index = -1); //ASA-1353 issue 3 --Task_27104 20240417 regression -- before it was using g_shelf_index and setting default -1. due to which drag drop had problem
    var module_details = g_pog_json[p_pog_index].ModuleInfo;
    $.each(module_details, function (j, Modules) {
        if (l_shelf_index > -1) {
            return false;
        }
        if (Modules.ParentModule == null || Modules.ParentModule == "undefined") {
            $.each(Modules.ShelfInfo, function (k, Shelf) {
                if (l_shelf_index > -1) {
                    return false;
                }
                if (typeof Shelf !== "undefined") {
                    if (Shelf.ObjType !== "BASE" && Shelf.ObjType !== "NOTCH" && Shelf.ObjType !== "DIVIDER") {
                        if (Shelf.SObjID == p_obj_id) {
                            l_module_index = j;
                            l_shelf_index = k;
                            return false;
                        }
                    }
                }
            });
        }
    });
    logDebug("function : l_shelf_index", "E");
    return [l_module_index, l_shelf_index];
}

// ASA-1129, Start
//This function is used to find out from all the module which are the items which fall under the combine rules and can be combined to gether. this will set the
//g_combineShelfs array with each combine set of shelfs.
async function generateCombinedShelfs(p_pog_index, p_module_index, p_shelf_index, p_pogcrDelistItemDftColor, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_merge_items = "Y", p_calc_days_of_supply = "", p_get_combiedetails,p_depth_check = "N") { // ASA-2041 issue 1 
    //ASA-1350 issue 6 add parameters
    try {
        logDebug("function : generateCombinedShelfs; p_pog_index : " + p_pog_index, "S");
        var activeCombines = [];
        var currShelf = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
        var currShelfStart = wpdSetFixed(currShelf.X - currShelf.W / 2);
        var currShelfEnd = wpdSetFixed(currShelf.X + currShelf.W / 2);
        var module_details = g_pog_json[p_pog_index].ModuleInfo;
        var CheckComb = [],
            currCombination = [],
            currCombArr = [];
        var sorto = {
            MIndex: "asc",
            X: "asc",
        };
        //This logic will only run for the shelf which is currently edit and Combine attr !== 'N'.
        if (currShelf.Combine !== "N" && (currShelf.ObjType == "SHELF" || currShelf.ObjType == "HANGINGBAR")) {
            var j = 0;
            var shelfFound = false;
            for (const Modules of module_details) {
                if (Modules.ParentModule == null || Modules.ParentModule == "undefined") {
                    var k = 0;
                    for (const shelf_info of Modules.ShelfInfo) {
                        //Conditions to check for each shelf to combine are as follows
                        //1. Combine != 'N',
                        //2. all the shelfs should have same Object Type, same Y, H, Rotation, Slope, D.
                        //3. if checking from left the current shelf start should be same as previous shelf end.
                        //4. if checking from right. current shelf end shouldbe same as next shelf start.
                        let  depthCheck = p_depth_check  == "D" ? true : wpdSetFixed(currShelf.D) == wpdSetFixed(shelf_info.D);   // ASA-2041 issue 1 create condition
                        if (typeof shelf_info !== "undefined" && shelf_info.Combine !== "N" && shelf_info.ObjType == currShelf.ObjType && wpdSetFixed(currShelf.Y) == wpdSetFixed(shelf_info.Y) && wpdSetFixed(currShelf.H) == wpdSetFixed(shelf_info.H) && currShelf.Rotation == shelf_info.Rotation && currShelf.Slope == shelf_info.Slope && depthCheck) { // ASA-2041 issue 1 check condition
                            //ASA-1292
                            var compareShelf,
                                compShelfSt = -1,
                                compShelfEnd = -1;
                            //First take the start and end of the current shelf and previous shelf.
                            if (activeCombines.length > 0) {
                                compareShelf = activeCombines[activeCombines.length - 1];
                                compShelfSt = wpdSetFixed(activeCombines[activeCombines.length - 1].X - activeCombines[activeCombines.length - 1].W / 2);
                                compShelfEnd = wpdSetFixed(activeCombines[activeCombines.length - 1].X + activeCombines[activeCombines.length - 1].W / 2);
                            } else {
                                compareShelf = currShelf;
                                compShelfSt = currShelfStart;
                                compShelfEnd = currShelfEnd;
                            }
                            //take start and end of current shelf.
                         //take start and end of current shelf.
                                var shelfStart = wpdSetFixed(shelf_info.X - shelf_info.W / 2);
                                var shelfEnd = wpdSetFixed(shelf_info.X + shelf_info.W / 2);

                                        //take start and end of current shelf.
                            var shelfStart = wpdSetFixed(shelf_info.X - shelf_info.W / 2);
                            var shelfEnd = wpdSetFixed(shelf_info.X + shelf_info.W / 2);

                            // we consider the current shelf is combine only when it matches the shelf start and shelf end. based on Combine setting.
                            if (shelf_info.Combine == "R" && (compareShelf.Combine == "B" || compareShelf.Combine == "L") && shelfEnd == compShelfSt) {
                                shelfFound = true;
                            } else if (shelf_info.Combine == "L" && (compareShelf.Combine == "B" || compareShelf.Combine == "R") && shelfStart == compShelfEnd) {
                                shelfFound = true;
                            } else if (shelf_info.Combine == "B" && ((compareShelf.Combine == "R" && shelfStart == compShelfEnd) || (compareShelf.Combine == "L" && shelfEnd == compShelfSt) || (compareShelf.Combine == "B" && (shelfStart == compShelfEnd || shelfEnd == compShelfSt)))) {
                                shelfFound = true;
                            }
                            if (shelfFound) {
                                // || shelf_info.Shelf == currShelf.Shelf) {
                                var dtls = {};
                                dtls["PIndex"] = p_pog_index;
                                dtls["MIndex"] = j;
                                dtls["SIndex"] = k;
                                dtls["Shelf"] = shelf_info.Shelf;
                                dtls["ObjType"] = shelf_info.ObjType;
                                dtls["Combine"] = shelf_info.Combine;
                                dtls["SpreadItem"] = shelf_info.SpreadItem;
                                dtls["AllowAutoCrush"] = shelf_info.AllowAutoCrush; //ASA=1307
                                dtls["SObjID"] = shelf_info.SObjID;
                                dtls["MObjID"] = Modules.MObjID;
                                dtls["Module"] = Modules.Module;
                                dtls["X"] = shelf_info.X;
                                dtls["Y"] = shelf_info.Y;
                                dtls["W"] = shelf_info.W;
                                dtls["H"] = shelf_info.H;
                                dtls["Slope"] = shelf_info.Slope;
                                dtls["Rotation"] = shelf_info.Rotation;
                                activeCombines.push(dtls);
                                shelfFound = false;
                            }
                        }
                        k++;
                    }
                }
                j++;
            }
        }
        var curr_comb_index = -1;
        var deleteCombine = false;
        //if the current shelf was not set to Combine !== 'N' then we need to check the current combine if that shelf exists or not and reset the combination.
        //Because there could be case when the shelf dimension or Combine attr is changed and that shelf no more pass the conditions.
        if (activeCombines.length == 0) {
            var [currCombinationIndex, currShelfCombIndx] = getCombinationShelf(p_pog_index, currShelf.Shelf);
            //if the current shelf exists in combination. then start the validations of combine shelf again for the combination set of shelfs.
            if (currCombinationIndex !== -1 && currShelfCombIndx !== -1) {
                curr_comb_index = currCombinationIndex;
                currCombination = g_combinedShelfs[currCombinationIndex];
                //This is the
                CheckComb = JSON.parse(JSON.stringify(currCombination));
                var currShelfCombination = g_combinedShelfs[currCombinationIndex][currShelfCombIndx];
                var currCombShelf = g_pog_json[currShelfCombination.PIndex].ModuleInfo[currShelfCombination.MIndex].ShelfInfo[currShelfCombination.SIndex];

                currCombination.splice(currShelfCombIndx, 1);
                currCombination.keySort(sorto);
                //if removing the current shelf the currcombination is left with single shelf. then delete that from g_combineShelfs array.
                if (currCombination.length < 2) {
                    deleteCombine = true;
                } else if (currCombination.length > 2) {
                    //if there are more than one shelf then start checking.
                    g_combinedShelfs.splice(currCombinationIndex, 1);
                    var c = 0;
                    var spilceSorto = {
                        SubCombIndex: "desc",
                    };
                    for (obj of currCombination) {
                        var mainShelf = currCombination[c];
                        var compShelf = currCombination[c + 1];
                        if (typeof compShelf == "undefined") {
                            break;
                        }
                        var mainShelfEnd = wpdSetFixed(mainShelf.X + mainShelf.W / 2);
                        var compShelfStart = wpdSetFixed(compShelf.X - compShelf.W / 2);
                        var mainPogShelf = g_pog_json[mainShelf.PIndex].ModuleInfo[mainShelf.MIndex].ShelfInfo[mainShelf.SIndex];
                        var compPogShelf = g_pog_json[compShelf.PIndex].ModuleInfo[compShelf.MIndex].ShelfInfo[compShelf.SIndex];
                        //Conditions to check for each shelf to combine are as follows
                        //1. Combine != 'N',
                        //2. all the shelfs should have same Object Type, same Y, H, Rotation, Slope, D.
                        //3. if checking from left the current shelf start should be same as previous shelf end.
                        //4. if checking from right. current shelf end shouldbe same as next shelf start.
                        if (typeof currCombination[c].CanCombine == "undefined") {
                            currCombination[c].CanCombine = false;
                            currCombination[c + 1].CanCombine = false;
                        }
                        //we are checking current shelf with next shelf. we the condition fails. we set CanCombine = false for next shelf. b
                        //but still maintain value of CanCombine of current shelf. because its already set when previous shelf loop ran.
                        if (!(mainShelfEnd == compShelfStart && ((mainPogShelf.Combine == "R" && (compPogShelf.Combine == "B" || compPogShelf.Combine == "L")) || (mainPogShelf.Combine == "B" && (compPogShelf.Combine == "L" || compPogShelf.Combine == "B"))))) {
                            currCombination[c].CanCombine = currCombination[c].CanCombine ? currCombination[c].CanCombine : false;
                            currCombination[c].SubCombIndex = currCombination[c].CanCombine ? currCombination[c].SubCombIndex : -1;
                            currCombination[c + 1].CanCombine = false;
                            currCombination[c + 1].SubCombIndex = -1;
                        } else {
                            if (typeof currCombination[c].CanCombine !== "undefined" && currCombination[c].CanCombine) {
                                currCombination[c + 1].CanCombine = true;
                                currCombination[c + 1].SubCombIndex = currCombination[c].SubCombIndex;
                            } else {
                                currCombination[c].CanCombine = true;
                                currCombination[c].SubCombIndex = c;
                                currCombination[c + 1].CanCombine = true;
                                currCombination[c + 1].SubCombIndex = c;
                            }
                        }
                        c++;
                    }
                    currCombination.keySort(spilceSorto);
                    var x = 0;
                    var currIndex = -1,
                        prevIndex = -1,
                        afterSplicecomb = [],
                        finalCombArr = [];
                    //after check from CanCombine flag. now take all the array with CanCombine true and push into finalCombArr.
                    for (comb of currCombination) {
                        currIndex = currCombination[x].SubCombIndex;
                        if (prevIndex !== currIndex && afterSplicecomb.length !== 0) {
                            finalCombArr.push(afterSplicecomb);
                            afterSplicecomb = [];
                        }
                        //This shelf which is pushed into afterSplicecomb array means this shelf can be combined.
                        if (currCombination[x].CanCombine && currCombination[x].SubCombIndex !== -1) {
                            afterSplicecomb.push(comb);
                        }
                        prevIndex = currCombination[x].SubCombIndex;
                        x++;
                    }
                    if (afterSplicecomb.length !== 0) {
                        finalCombArr.push(afterSplicecomb);
                    }
                    //Now set all other attrbutes needed for that set of combine shelf as below.
                    for (currArr of finalCombArr) {
                        currArr.keySort(sorto);
                        currArr.SpreadItem = currArr[0].SpreadItem;
                        currArr.AllowAutoCrush = currArr[0].AllowAutoCrush;
                        var startArray = [],
                            endArray = [];
                        for (shelf_info of currArr) {
                            var shelfDtl = g_pog_json[shelf_info.PIndex].ModuleInfo[shelf_info.MIndex].ShelfInfo[shelf_info.SIndex];
                            var shelfStart = wpdSetFixed(shelfDtl.X - shelfDtl.W / 2);
                            var shelfEnd = wpdSetFixed(shelfDtl.X + shelfDtl.W / 2);
                            startArray.push(shelfStart);
                            endArray.push(shelfEnd);
                            for (item of shelfDtl.ItemInfo) {
                                item.Fixed = "N";
                            }
                        }
                        var combinedStart = Math.min(...startArray);
                        var combinedEnd = Math.max(...endArray);
                        currArr["Start"] = combinedStart;
                        currArr["End"] = combinedEnd;
                        var spliceCombinationIndex = g_combinedShelfs.length;
                        g_combinedShelfs.push(currArr);
                        //after added new set of combine shelf and its attributes. set all the items from all shelfs into one tag ItemInfo inside that set of combination..
                        await setCombinedShelfItems(p_pog_index, spliceCombinationIndex, -1, -1, "N", "N", -1, -1, []); //ASA-1329
                        //Note: we try to reorder combine items based on there spread product and recreate all the combine shelfs.
                        for (shelf_info of currArr) {
                            var shelf = g_pog_json[shelf_info.PIndex].ModuleInfo[shelf_info.MIndex].ShelfInfo[shelf_info.SIndex];
                            if (reorder_items(shelf.MIndex, shelf.SIndex, p_pog_index)) {
                                var return_val = await recreate_all_items(shelf.MIndex, shelf.SIndex, shelf.ObjType, "Y", -1, -1, shelf.ItemInfo.length, "N", "N", -1, -1, g_start_canvas, p_calc_days_of_supply, p_pog_index, p_pogcrDelistItemDftColor, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_merge_items); //ASA-1350 issue 6 added parameters
                            }
                        }
                    }
                } else {
                    //This condition will come when currCombination length is exactly 2.
                    var mainShelf = currCombination[0];
                    var compShelf = currCombination[1];
                    var mainShelfEnd = wpdSetFixed(mainShelf.X + mainShelf.W / 2);
                    var compShelfStart = wpdSetFixed(compShelf.X - compShelf.W / 2);
                    var mainShelfCombine = mainShelf.Combine;
                    var compShelfCombine = compShelf.Combine;
                    //Now we check if all the combine rules pass or not. if not then delete the whole combine set from g_combineShelfs.
                    if (!(mainShelfEnd == compShelfStart && ((mainShelfCombine == "R" && (compShelfCombine == "B" || compShelfCombine == "L")) || (mainShelfCombine == "B" && (compShelfCombine == "L" || compShelfCombine == "B"))))) {
                        deleteCombine = true;
                    }
                }
                //if delete combine. we set Combine attr to N and reorder items and recreate_all_items which will reset the shelfs and place items based on each shelf.
                if (deleteCombine) {
                    for (shelfs of g_combinedShelfs[currCombinationIndex]) {
                        var shelf = g_pog_json[shelfs.PIndex].ModuleInfo[shelfs.MIndex].ShelfInfo[shelfs.SIndex];
                        if (reorder_items(shelf.MIndex, shelf.SIndex, p_pog_index)) {
                            shelf.Combine = "N";
                            var return_val = await recreate_all_items(shelf.MIndex, shelf.SIndex, shelf.ObjType, "Y", -1, -1, shelf.ItemInfo.length, "N", "N", -1, -1, g_start_canvas, p_calc_days_of_supply, p_pog_index, p_pogcrDelistItemDftColor, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_merge_items); //ASA-1350 issue 6 added parameters
                        }
                    }
                    //remove the combine shelfs from combine array.
                    g_combinedShelfs.splice(currCombinationIndex, 1);
                }
            }
        }

        var [currCombinationIndex, currShelfCombIndx] = getCombinationShelf(p_pog_index, currShelf.Shelf);
        //if activeCombines length > 0. that means the current shelf which is edited has satisfied the combine condition new set of combine shelfs list is created
        //together with combine shelf .
        if (activeCombines.length > 0 && currCombinationIndex == -1 && currShelfCombIndx == -1) {
            var activeCombinations = [],
                newCombinationIndex = -1;
            var dtls = {};
            //populate the details of the current shelf as it has passed the combine validation.
            dtls["PIndex"] = p_pog_index;
            dtls["MIndex"] = p_module_index;
            dtls["SIndex"] = p_shelf_index;
            dtls["Shelf"] = currShelf.Shelf;
            dtls["ObjType"] = currShelf.ObjType;
            dtls["Combine"] = currShelf.Combine;
            dtls["SpreadItem"] = currShelf.SpreadItem;
            dtls["AllowAutoCrush"] = currShelf.AllowAutoCrush;
            dtls["SObjID"] = currShelf.SObjID;
            dtls["MObjID"] = g_pog_json[p_pog_index].ModuleInfo[p_module_index].MObjID;
            dtls["Module"] = g_pog_json[p_pog_index].ModuleInfo[p_module_index].Module;
            dtls["X"] = currShelf.X;
            dtls["Y"] = currShelf.Y;
            dtls["W"] = currShelf.W;
            dtls["H"] = currShelf.H;
            dtls["Slope"] = currShelf.Slope;
            dtls["Rotation"] = currShelf.Rotation;
            //find if the shelfs in the activeCombines are already in the g_combineShelfs array. then find them and take them separately.
            for (shelf_info of activeCombines) {
                var [actCombIndx, actShelfCombIndx] = getCombinationShelf(p_pog_index, shelf_info.Shelf);
                if (actCombIndx !== -1 && actShelfCombIndx !== -1) {
                    activeCombinations.push(actCombIndx);
                }
            }
            //if there are shelfs already exists in the activeCombines list. then push all existing shelfs together with new shelf which has passed validation now.
            if (activeCombinations.length > 0) {
                var firstCombIndx = activeCombinations[0];
                g_combinedShelfs[firstCombIndx].push(dtls);
                if (activeCombinations.length > 1) {
                    for (combIndx of activeCombinations) {
                        if (combIndx !== firstCombIndx) {
                            for (actShelf of g_combinedShelfs[combIndx]) {
                                g_combinedShelfs[firstCombIndx].push(actShelf);
                                g_combinedShelfs.splice(actShelf, 1);
                            }
                        }
                    }
                }
                g_combinedShelfs[firstCombIndx].keySort(sorto);
                g_combinedShelfs[firstCombIndx].SpreadItem = g_combinedShelfs[firstCombIndx][0].SpreadItem;
                g_combinedShelfs[firstCombIndx].AllowAutoCrush = g_combinedShelfs[firstCombIndx][0].AllowAutoCrush;
                newCombinationIndex = firstCombIndx;
            } else {
                //This means the shelfs added in activeCombines are all new shels and does not exists in g_combineShelfs array already.
                activeCombines.push(dtls);
                activeCombines = activeCombines.filter((v, i, a) => a.findIndex((v2) => JSON.stringify(v2) === JSON.stringify(v)) === i); // ASA-1157
                activeCombines.keySort(sorto);
                activeCombines.SpreadItem = activeCombines[0].SpreadItem;
                activeCombines.AllowAutoCrush = activeCombines[0].AllowAutoCrush;
                g_combinedShelfs.push(activeCombines);
                newCombinationIndex = g_combinedShelfs.length - 1;
            }
            var startArray = [],
                endArray = [];
            //after getting all active combinations and setting g_combinedShelfs. now set all the necessary attr.
            for (shelf_info of g_combinedShelfs[newCombinationIndex]) {
                // var shelfDtl = g_pog_json[shelf_info.PIndex].ModuleInfo[shelf_info.MIndex].ShelfInfo[shelf_info.SIndex]; //ASA_2023-task-2
                var shelfDtl = (g_pog_json && g_pog_json[shelf_info.PIndex] && g_pog_json[shelf_info.PIndex].ModuleInfo && g_pog_json[shelf_info.PIndex].ModuleInfo[shelf_info.MIndex] && g_pog_json[shelf_info.PIndex].ModuleInfo[shelf_info.MIndex].ShelfInfo) ? g_pog_json[shelf_info.PIndex].ModuleInfo[shelf_info.MIndex].ShelfInfo[shelf_info.SIndex] : undefined;
                if (typeof shelfDtl === "undefined") {
                    logDebug("Warning: missing shelfDtl in generateCombinedShelfs (newCombinationIndex loop) for shelf: " + JSON.stringify(shelf_info), "W");
                    continue;
                }
                //ASA_2023-task-2
                var shelfStart = wpdSetFixed(shelfDtl.X - shelfDtl.W / 2);
                var shelfEnd = wpdSetFixed(shelfDtl.X + shelfDtl.W / 2);
                startArray.push(shelfStart);
                endArray.push(shelfEnd);
                 //ASA_2023-task-2
                // for (item of shelfDtl.ItemInfo) {
                //     item.Fixed = "N";
               
                 if (Array.isArray(shelfDtl.ItemInfo)) {
                    for (item of shelfDtl.ItemInfo) {
                        item.Fixed = "N";
                    }
                }
                //ASA_2023-task-2
            }
            var combinedStart = Math.min(...startArray);
            var combinedEnd = Math.max(...endArray);
            g_combinedShelfs[newCombinationIndex]["Start"] = combinedStart;
            g_combinedShelfs[newCombinationIndex]["End"] = combinedEnd;
            //this will set an ItemInfo tag for each combination set with all the items in all the shelfs.
            await setCombinedShelfItems(p_pog_index, newCombinationIndex, -1, -1, "N", "N", -1, -1, []); //ASA-1329
        }
        //below currCombArr is set to make those combine shelfs to be recreated with new details.
        if (g_combinedShelfs.length > 0 && typeof newCombinationIndex !== "undefined" && newCombinationIndex !== -1) {
            //ASA-1157
            currCombArr = JSON.parse(JSON.stringify(g_combinedShelfs[newCombinationIndex]));
        } else if (currCombination.length > 0) {
            currCombArr = JSON.parse(JSON.stringify(currCombination));
            var newCombinationIndex = curr_comb_index;
            if (!deleteCombine) {
                g_combinedShelfs[curr_comb_index].Start = wpdSetFixed(g_combinedShelfs[curr_comb_index][0].X - g_combinedShelfs[curr_comb_index][0].W / 2);
                g_combinedShelfs[curr_comb_index].End = wpdSetFixed(g_combinedShelfs[curr_comb_index][g_combinedShelfs[curr_comb_index].length - 1].X + g_combinedShelfs[curr_comb_index][g_combinedShelfs[curr_comb_index].length - 1].W / 2);
            }
        }
        //This condition means the current shelf is available in some combination set in g_combinedShelfs and currCombArr is the array created above with new details
        // so we need to recreate the shelfs are removed from combine. to make items reset into there respective shelfs.
        if (CheckComb.length > 0 && currCombArr.length > 0) {
            if (!deleteCombine) {
                await setCombinedShelfItems(p_pog_index, newCombinationIndex, -1, -1, "N", "N", -1, -1, []); //ASA-1329
            }
            if (currCombArr.length > 1) {
                //looping the old combination of shelf before it was reset. CheckComb is actually array which was JSON.parse(JSON.stringify.)
                for (var i = 0; i < CheckComb.length; i++) {
                    //take the first shelf details and pass to reorder_items and recreate_all_items so that it will recreate all combine shelfs.
                    var mainShelf = CheckComb[i];
                    // if (currShelf.SObjID !== mainShelf.SObjID) {
                    var j = 0;
                    var recreate = true;
                    //check how many shelfs are removed from new set of combine comparing with old combine set of shelfs and recreate those.
                    for (shelf_info of currCombArr) {
                        if (shelf_info.SObjID == mainShelf.SObjID) {
                            recreate = false;
                        }
                        j++;
                    }
                    // the shelf which was removed from combine to be individually recreated as below.
                    if (recreate) {
                        [mod_ind, shelf_ind] = get_shelf_index(mainShelf.SObjID, mainShelf.PIndex);
                        if (mod_ind !== -1) {
                            var shelf_info = g_pog_json[mainShelf.PIndex].ModuleInfo[mod_ind].ShelfInfo[shelf_ind];
                            if (shelf_info.ItemInfo.length > 0) {
                                shelf_info.Combine = "N";
                                if (reorder_items(mod_ind, shelf_ind, mainShelf.PIndex)) {
                                    var return_val = await recreate_all_items(mod_ind, shelf_ind, mainShelf.ObjType, "Y", -1, -1, shelf_info.ItemInfo.length, "N", "N", -1, -1, g_start_canvas, p_calc_days_of_supply, mainShelf.PIndex, p_pogcrDelistItemDftColor, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_merge_items); //ASA-1350 issue 6 added parameters
                                }
                            }
                        }
                    }
                }
            } else {
                //if (recreate) {
                //currCombArr will have all active combination of shelf with the current shelf which was edited. so recreate all those newly created combination shelfs.
                [mod_ind, shelf_ind] = get_shelf_index(currCombArr[0].SObjID, currCombArr[0].PIndex);
                if (mod_ind !== -1) {
                    var shelf_info = g_pog_json[currCombArr[0].PIndex].ModuleInfo[mod_ind].ShelfInfo[shelf_ind];
                    if (shelf_info.ItemInfo.length > 0) {
                        if (reorder_items(mod_ind, shelf_ind, currCombArr[0].PIndex)) {
                            shelf_info.Combine = "N";
                            var return_val = await recreate_all_items(mod_ind, shelf_ind, currCombArr[0].ObjType, "Y", -1, -1, shelf_info.ItemInfo.length, "N", "N", -1, -1, g_start_canvas, p_calc_days_of_supply, currCombArr[0].PIndex, p_pogcrDelistItemDftColor, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_merge_items); //ASA-1350 issue 6 added parameters
                        }
                    }
                }
                //}
            }
        } else {
            //if there was not change in the combination of current shelfs. we loop all the Shelfs and update there basic attributes which are necessary.
            var [currCombinationIndex, currShelfCombIndx] = getCombinationShelf(p_pog_index, currShelf.Shelf);
            if (currCombinationIndex !== -1 && currShelfCombIndx !== -1) {
                var module_details = g_pog_json[g_combinedShelfs[currCombinationIndex][0].PIndex].ModuleInfo;
                var mod_ind = -1,
                    shelf_ind = -1;
                $.each(module_details, function (j, Modules) {
                    if (shelf_ind > -1) {
                        return false;
                    }
                    if (Modules.ParentModule == null || Modules.ParentModule == "undefined") {
                        $.each(Modules.ShelfInfo, function (k, Shelf) {
                            if (shelf_ind > -1) {
                                return false;
                            }
                            if (typeof Shelf !== "undefined") {
                                if (Shelf.ObjType !== "BASE" && Shelf.ObjType !== "NOTCH" && Shelf.ObjType !== "DIVIDER") {
                                    if (Shelf.SObjID == g_combinedShelfs[currCombinationIndex][0].SObjID) {
                                        mod_ind = j;
                                        shelf_ind = k;
                                        return false;
                                    }
                                }
                            }
                        });
                    }
                });
                if (mod_ind !== -1 && shelf_ind !== -1) {
                    var shelf_info = g_pog_json[g_combinedShelfs[currCombinationIndex][0].PIndex].ModuleInfo[mod_ind].ShelfInfo[shelf_ind];
                    g_combinedShelfs[currCombinationIndex].SpreadItem = shelf_info.SpreadItem;
                    g_combinedShelfs[currCombinationIndex].AllowAutoCrush = shelf_info.AllowAutoCrush;
                    g_combinedShelfs[currCombinationIndex][currShelfCombIndx].SpreadItem = shelf_info.SpreadItem; //ASA-1386 Issue 7A
                    g_combinedShelfs[currCombinationIndex][currShelfCombIndx].AllowAutoCrush = shelf_info.AllowAutoCrush; //ASA-1386 Issue 7A
                }
            }
            //recreate the current shelf in case nothing happned and need to reset all the items to keep them without combine.
            //Note: we can add a check from above code that if this shelf was combined before and now it was removed from combine then recreate. so we no need to recreate
            //all shelfs everytime we call this function.
            if (reorder_items(p_module_index, p_shelf_index, p_pog_index)) {
                var return_val = await recreate_all_items(p_module_index, p_shelf_index, currShelf.ObjType, "Y", -1, -1, currShelf.ItemInfo.length, "N", "N", -1, -1, g_start_canvas, p_calc_days_of_supply, p_pog_index, p_pogcrDelistItemDftColor, p_merchStyle, p_pogcrLoadImgFrom, p_buId, p_pogcrItemLabelColor, p_pogcrItemNumLabelPosition, p_pogcrDisplayItemInfo, p_merge_items); //ASA-1350 issue 6 added parameters
            }
        }
        //This is a variable which will be stored in the DB as g_combineShelfs array format is not suitable to store in the json in table.
        //we use this GenrateCombineS and recreate g_combineShelfs array when getting json from table after mass update.
        if (p_get_combiedetails != "N") {
            g_pog_json[p_pog_index].GenrateCombineS = get_combine_arr(); //ASA-1353 issue 2;
        }
    } catch (err) {
        logDebug("function : generateCombinedShelfs", "E");
        error_handling(err);
    }
}

//This function is used to return the current position of item. that means after getting new x axis. which shelf should this be moved in the set of combine shelfs.
function updateCombinedItemInfo(p_pog_index, p_module_index, p_shelf_index, p_itemX, p_combo_index) {
    try {
        logDebug("function : updateCombinedItemInfo; p_pog_index : " + p_pog_index + "; pModuleIndex : " + p_module_index + "; pShelfIndex : " + p_shelf_index + "; pItemX : " + p_itemX + "; pCombIndx : " + p_combo_index, "S");
        var combinationShelfs = g_combinedShelfs[p_combo_index];
        var currModIndx, currShlfIndx, currShelf, currShelfStart, currShelfEnd;
        for (shelf_info of combinationShelfs) {
            currModIndx = shelf_info.MIndex;
            currShlfIndx = shelf_info.SIndex;
            currShelf = g_pog_json[p_pog_index].ModuleInfo[currModIndx].ShelfInfo[currShlfIndx];
            currShelfStart = currShelf.X - currShelf.W / 2;
            currShelfEnd = currShelf.X + currShelf.W / 2;
            if (p_itemX > currShelfStart && p_itemX <= currShelfEnd) {
                return [currModIndx, currShlfIndx];
            }
        }
        return [p_module_index, p_shelf_index];
    } catch (err) {
        logDebug("function : updateCombinedItemInfo", "E");
        error_handling(err);
    }
}

//This function is used to shuffle all the items in the group of combine shelfs.
//it will find the new shelf and move the iteminfo to the new ShelfInfo based on the Xaxis and also set ItemInfo tag for that combination with all the items in all the shelfs.
async function setCombinedShelfItems(p_pog_index, p_combinationIndex, p_currShelfCombIndx, p_locationX, p_edit_ind, p_shelf_edit, p_redo_x, p_edit_item_index, p_drag_details) {
    try {
        logDebug("function : setCombinedShelfItems; p_pog_index : " + p_pog_index + "; pCombinationIndex : " + p_combinationIndex + "; pCurrShelfCombIndx : " + p_currShelfCombIndx + "; pLocationX : " + p_locationX, "S");
        //g_combineItemModf = []; //Task_27808
        const spread_product = g_combinedShelfs[p_combinationIndex].SpreadItem;
        var combinationShelfs = JSON.parse(JSON.stringify(g_combinedShelfs[p_combinationIndex]));
        combinationShelfs["SpreadItem"] = spread_product;

        var currModIndx,
            currShlfIndx,
            currShelf,
            items_arr = [],
            newModIndex,
            newShlfIndex;

        var sorto = {
            NewMIndex: "asc",
            NewSIndex: "asc",
            OldMIndex: "asc",
            OldSIndex: "asc",
            OldIIndex: "asc",
            X: "asc",
        };
        //we use TransferItem tag to mark which item to be moved. so we set it to N at the begining.
        for (obj of g_combineItemModf) {
            //Task_27808
            obj.TransferItem = "N";
        }
        var horiz_gap;

        //if spread product = 'R' then we have to loop reverse.
        if (spread_product == "R") {
            combinationShelfs = combinationShelfs.reverse();
        }
        await set_shelf_item_index(p_pog_index);
        var i = 0;

        //first take all the items in all the shelfs an populate ItemInfo tag for that combination.
        for (combination of g_combinedShelfs) {
            var item_details = [];
            for (shelf_info of combination) {
                if (p_pog_index == shelf_info.PIndex) {
                    //ASA-1443
                    var items_arr = g_pog_json[shelf_info.PIndex].ModuleInfo[shelf_info.MIndex].ShelfInfo[shelf_info.SIndex].ItemInfo;
                    item_details = item_details.concat(items_arr);
                }
            }
            var sorto = {
                MIndex: "asc",
                SIndex: "asc",
                X: "asc",
            };
            item_details.keySort(sorto);

            if (item_details.length > 0) {
                //ASA-1507 #3
                g_combinedShelfs[i].ItemInfo = item_details;
            }
            i++;
        }

        for (shelf_info of combinationShelfs) {
            currModIndx = shelf_info.MIndex;
            currShlfIndx = shelf_info.SIndex;
            currShelf = g_pog_json[p_pog_index].ModuleInfo[currModIndx].ShelfInfo[currShlfIndx];
            horiz_gap = currShelf.HorizGap;
            items_arr = g_pog_json[shelf_info.PIndex].ModuleInfo[shelf_info.MIndex].ShelfInfo[shelf_info.SIndex].ItemInfo;
            var item_cnt = items_arr.length;
            var itemX = -1;
            if (spread_product == "R") {
                for (var i = items_arr.length - 1; i >= 0; i--) {
                    item_cnt = item_cnt - 1;
                    itemX = get_item_xaxis(items_arr[i].W, items_arr[i].H, items_arr[i].D, currShelf.ObjType, p_locationX, horiz_gap, spread_product, horiz_gap, currModIndx, currShlfIndx, item_cnt, p_edit_ind, g_pog_json[p_pog_index].ModuleInfo[currModIndx].ShelfInfo[currShlfIndx].ItemInfo.length, p_shelf_edit, p_pog_index);
                    //This below will find the new module and shelf index where this item should be moved and that will be stored in an array.
                    [newModIndex, newShlfIndex] = updateCombinedItemInfo(p_pog_index, currModIndx, currShlfIndx, itemX, p_combinationIndex);
                    //we first get the new x axis based on its spread product setting for combination and then check if that item will be part of that shelf which it was
                    //before. then mark TransferItem = 'Y'
                    if (!(newModIndex == currModIndx && newShlfIndex == currShlfIndx)) {
                        items_arr[i].OldX = items_arr[i].X; //ASA-1329
                        items_arr[i].X = itemX; //ASA-1329
                        var info = {};
                        info["NewMIndex"] = newModIndex;
                        info["NewSIndex"] = newShlfIndex;
                        info["OldMIndex"] = currModIndx;
                        info["OldSIndex"] = currShlfIndx;
                        info["OldIIndex"] = i;
                        info["OldObjID"] = items_arr[i].ObjID;
                        info["TransferItem"] = "Y"; //Task_27808
                        g_combineItemModf.push(info);
                    }
                }
            } else {
                var i = 0;
                for (const items of items_arr) {
                    if (p_redo_x !== -1 && i == p_edit_item_index) {
                        itemX = p_redo_x;
                    } else {
                        itemX = get_item_xaxis(items.W, items.H, items.D, currShelf.ObjType, p_locationX, horiz_gap, spread_product, horiz_gap, currModIndx, currShlfIndx, i, p_edit_ind, g_pog_json[p_pog_index].ModuleInfo[currModIndx].ShelfInfo[currShlfIndx].ItemInfo.length, p_shelf_edit, p_pog_index);
                    }
                    items.OldX = items.X;
                    items.X = itemX;
                    //This below will find the new module and shelf index where this item should be moved and that will be stored in an array.
                    [newModIndex, newShlfIndex] = updateCombinedItemInfo(p_pog_index, currModIndx, currShlfIndx, itemX, p_combinationIndex);
                    //we first get the new x axis based on its spread product setting for combination and then check if that item will be part of that shelf which it was
                    //before. then mark TransferItem = 'Y'
                    if (!(newModIndex == currModIndx && newShlfIndex == currShlfIndx)) {
                        var info = {};
                        info["NewMIndex"] = newModIndex;
                        info["NewSIndex"] = newShlfIndex;
                        info["OldMIndex"] = currModIndx;
                        info["OldSIndex"] = currShlfIndx;
                        info["OldIIndex"] = i;
                        info["OldObjID"] = currShelf.ItemInfo[i].ObjID;
                        info["TransferItem"] = "Y"; //Task_27808
                        g_combineItemModf.push(info);
                    }
                    i++;
                }
            }
        }
        g_combineItemModf.keySort(sorto);
        //Now loop the array with all the details of items to be moved to other shelfs.
        for (modf of g_combineItemModf) {
            if (modf.TransferItem == "Y") {
                //Task_27808
                var min_distance_arr = [],
                    min_index_arr = [],
                    itemInfo = [];

                for (obj of g_pog_json[p_pog_index].ModuleInfo[modf.OldMIndex].ShelfInfo[modf.OldSIndex].ItemInfo) {
                    if (modf.OldObjID == obj.ObjID) {
                        itemInfo = obj;
                        break;
                    }
                }

                if (typeof itemInfo !== "undefined") {
                    var i = 0;
                    //finding the items to next the current item has to be placed.
                    for (const items of g_pog_json[p_pog_index].ModuleInfo[modf.NewMIndex].ShelfInfo[modf.NewSIndex].ItemInfo) {
                        if (spread_product !== "R") {
                            if (items.X < itemInfo.X) {
                                min_distance_arr.push(itemInfo.X - items.X);
                                min_index_arr.push(i);
                            }
                        } else {
                            if (items.X > itemInfo.X) {
                                min_distance_arr.push(items.X - itemInfo.X);
                                min_index_arr.push(i);
                            }
                        }

                        i++;
                    }
                    var min_distance = Math.min.apply(Math, min_distance_arr);
                    var index = min_distance_arr.findIndex(function (number) {
                        return number == min_distance;
                    });
                    if (min_distance_arr.length > 0) {
                        var upd_item_index = spread_product !== "R" ? min_index_arr[index] + 1 : min_index_arr[index] - 1;
                        if (spread_product == "R" && upd_item_index == -1) {
                            upd_item_index = 0;
                        }
                    } else {
                        var upd_item_index = 0;
                    }

                    itemInfo.MIndex = modf.NewMIndex;
                    itemInfo.SIndex = modf.NewSIndex;
                    itemInfo.IIndex = upd_item_index;
                    if (typeof p_drag_details !== "undefined" && p_drag_details !== null && p_drag_details.length > 0) {
                        //ASA-1329 added beacuse if the item added is splice to new postion by this function then we need to update the MIndex,SIndex, item index and use this value outside to update the new values
                        if (p_drag_details[0].MIndex == modf.OldMIndex && p_drag_details[0].SIndex == modf.OldSIndex && p_drag_details[0].IIndex == modf.OldIIndex && p_drag_details[0].Iobjid == modf.OldObjID) {
                            p_drag_details[0].MIndex = modf.NewMIndex;
                            p_drag_details[0].SIndex = modf.NewSIndex;
                            p_drag_details[0].IIndex = upd_item_index;
                        }
                    } //ASA1329
                    //move the itemInfo to new shelf as below.
                    g_pog_json[p_pog_index].ModuleInfo[modf.NewMIndex].ShelfInfo[modf.NewSIndex].ItemInfo.splice(upd_item_index, 0, itemInfo);
                }
            }
        }
        //loop those same setup array and remove the itemInfo from old shelfs.
        for (modf of g_combineItemModf) {
            var objId = modf.OldObjID;
            var itemInfo = g_pog_json[p_pog_index].ModuleInfo[modf.OldMIndex].ShelfInfo[modf.OldSIndex].ItemInfo; //ASA-1329 issue1
            if (typeof itemInfo !== "undefined" && modf.TransferItem == "Y") {
                //Task_27808
                for (var i = 0; i < itemInfo.length; i++) {
                    if (objId == itemInfo[i].ObjID) {
                        itemInfo.splice(i, 1);
                    }
                }
            }
        }
        await set_shelf_item_index(p_pog_index);
        var i = 0;
        //now reset the ItemInfo tag for the combination on the current shelf and populate all the items based on the new setup done.
        for (combination of g_combinedShelfs) {
            var item_details = [];
            for (shelf_info of combination) {
                if (p_pog_index == shelf_info.PIndex) {
                    //ASA-1443
                    var items_arr = g_pog_json[shelf_info.PIndex].ModuleInfo[shelf_info.MIndex].ShelfInfo[shelf_info.SIndex].ItemInfo;
                    item_details = item_details.concat(items_arr);
                    var l_item = 0; //ASA-1466 -S
                    for (const item of items_arr) {
                        if (typeof p_drag_details !== "undefined" && p_drag_details !== null && p_drag_details.length > 0) {
                            //ASA-1329 added beacuse if the item added is splice to new postion by this function then we need to update the MIndex,SIndex, item index and use this value outside to update the new values
                            if (p_drag_details[0].MIndex == item.MIndex && p_drag_details[0].SIndex == item.SIndex && p_drag_details[0].Iobjid == item.ObjID) {
                                p_drag_details[0].MIndex = item.MIndex;
                                p_drag_details[0].SIndex = item.SIndex;
                                p_drag_details[0].IIndex = l_item;
                            }
                        } //ASA1329
                        l_item++;
                    } //ASA-1466 -E
                }
            }
            var sorto = {
                MIndex: "asc",
                SIndex: "asc",
                X: "asc",
            };
            item_details.keySort(sorto);
            if (item_details.length > 0) {
                //ASA-1507 #3
                g_combinedShelfs[i].ItemInfo = item_details;
            }
            i++;
        }
        render();
    } catch (err) {
        logDebug("function : setCombinedShelfItems", "E");
        error_handling(err);
    }
}

//This function will set all the index of each info's.
async function set_shelf_item_index(p_pog_index) {
    logDebug("function : set_shelf_item_index", "S");
    return new Promise(function (resolve, reject) {
        if (typeof g_pog_json !== "undefined" && g_pog_json.length > 0) {
            if (typeof g_pog_json[p_pog_index] !== "undefined") {
                var module_details = g_pog_json[p_pog_index].ModuleInfo;
                $.each(module_details, function (j, Modules) {
                    if (Modules.ParentModule == null || Modules.ParentModule == "undefined") {
                        $.each(Modules.ShelfInfo, function (k, Shelf) {
                            if (typeof Shelf !== "undefined") {
                                if (Shelf.ObjType !== "NOTCH" && Shelf.ObjType !== "BASE") {
                                    g_pog_json[p_pog_index].ModuleInfo[j].ShelfInfo[k].PIndex = p_pog_index; //Regression 20240724
                                    g_pog_json[p_pog_index].ModuleInfo[j].ShelfInfo[k].SIndex = k;
                                    g_pog_json[p_pog_index].ModuleInfo[j].ShelfInfo[k].MIndex = j;
                                }
                                if (Shelf.ItemInfo.length > 0) {
                                    $.each(Shelf.ItemInfo, function (l, items) {
                                        g_pog_json[p_pog_index].ModuleInfo[j].ShelfInfo[k].ItemInfo[l].PIndex = p_pog_index; //Regression 20240724
                                        g_pog_json[p_pog_index].ModuleInfo[j].ShelfInfo[k].ItemInfo[l].MIndex = j;
                                        g_pog_json[p_pog_index].ModuleInfo[j].ShelfInfo[k].ItemInfo[l].SIndex = k;
                                        g_pog_json[p_pog_index].ModuleInfo[j].ShelfInfo[k].ItemInfo[l].IIndex = l;
                                    });
                                }
                            }
                        });
                    }
                });
            }
        }
        resolve("SUCCESS");
        logDebug("function : set_shelf_item_index", "E");
    });
}

//this function is used in get_item_xaxis to get the previous item details of a combination shelfs to find out the current shelfs x axis.
function getLastItemCombinedShelf(p_combineShelfs, p_spreadProduct, p_objID) {
    try {
        logDebug("function : getLastItemCombinedShelf", "S");
        var z = 0,
            comitemID = -1;
        for (const items of p_combineShelfs.ItemInfo) {
            if (items.ObjID == p_objID) {
                comitemID = z;
                break;
            }

            z++;
        }
        var dtls = {};
        if (p_spreadProduct == "R") {
            if (typeof p_combineShelfs.ItemInfo[comitemID + 1] !== "undefined") {
                dtls["IIndex"] = comitemID + 1;
                dtls["X"] = p_combineShelfs.ItemInfo[comitemID + 1].X;
                dtls["W"] = p_combineShelfs.ItemInfo[comitemID + 1].W;
                dtls["CurrIndex"] = comitemID;
            }
        } else {
            if (typeof p_combineShelfs.ItemInfo[comitemID - 1] !== "undefined") {
                dtls["IIndex"] = comitemID - 1;
                dtls["X"] = p_combineShelfs.ItemInfo[comitemID - 1].X;
                dtls["W"] = p_combineShelfs.ItemInfo[comitemID - 1].W;
                dtls["CurrIndex"] = comitemID;
            }
        }
        return dtls;
    } catch (err) {
        logDebug("function : getLastItemCombinedShelf", "E");
        error_handling(err);
    }
} // ASA-1129, End
//End ASA-1350 issue 6
//Start ASA-1353 issue 3 --Task_27104 20240417
//This function is used inside create_module_from_json_lib. when the json is coming from table data or from mass update.
//need for this function is to create g_combineShelfs array. because the g_combineShelfs array is a local variable used only on screen.
//So need to save what are combination already present in POG. so we regenerate g_combinedShelfs for use when POG is opened.
function create_g_combine_shelfs(p_pog_json, p_pog_index) {
    if (p_pog_json[p_pog_index].GenrateCombineS.length > 0) {
        var Sorto = {
            SComIndex: "asc",
            ShelfCombIndx: "asc",
        };
        p_pog_json[p_pog_index].GenrateCombineS.keySort(Sorto);
        for (main_obj of p_pog_json[p_pog_index].GenrateCombineS) {
            var main_arr = [],
                item_arr = [];
            var l_callowcrush,
                //  l_start , Regression issue 5
                // l_end ,Regression issue 5
                l_spread;
            var min_x_arr = [],
                max_x_Arr = []; //Regression issue 5
            for (obj of main_obj) {
                if (obj.ObjType == "SHELF" || obj.ObjType == "HANGINGBAR") {
                    var details = {};
                    details["AllowAutoCrush"] = obj.AllowAutoCrush;
                    details["Combine"] = obj.Combine;
                    details["H"] = wpdSetFixed(obj.H);
                    details["MIndex"] = obj.MIndex;
                    details["Module"] = obj.Module;
                    details["ObjType"] = obj.ObjType;
                    details["PIndex"] = p_pog_index; //Regression 9, 10, 11 20241007
                    details["Rotation"] = obj.Rotation;
                    details["SIndex"] = obj.SIndex;
                    details["Shelf"] = obj.Shelf;
                    details["Slope"] = obj.Slope;
                    details["SpreadItem"] = obj.SpreadItem;
                    details["W"] = wpdSetFixed(obj.SW);
                    details["X"] = wpdSetFixed(obj.X);
                    details["Y"] = wpdSetFixed(obj.Y);
                    main_arr.push(details);
                    l_callowcrush = obj.CombAllowCrush;
                    // l_start = obj.CombStart;//Regression issue 5
                    // l_end = obj.CombEnd;//Regression issue 5
                    min_x_arr.push(wpdSetFixed(obj.X - obj.SW / 2)); //Regression issue 5
                    max_x_Arr.push(wpdSetFixed(obj.X + obj.SW / 2)); //Regression issue 5
                    l_spread = obj.CombSpreadItem;
                }
                if (obj.OBJECT == "ITEM") {
                    var item_details = {};
                    // var item_details = p_pog_json[p_pog_index].ModuleInfo[obj.MIndex].ShelfInfo[obj.SIndex].ItemInfo[obj.IIndex];

                    // item_details.W = item_width * item_details.BHoriz;
                    // item_details.H = item_height * item_details.BVert;
                    //item_details.D = item_depth * item_details.BaseD;
                    //item_details.X = p_pog_json[p_pog_index].ModuleInfo[obj.MIndex].ShelfInfo[obj.SIndex].X + item_details.X + (item_details.W / 2);
                    //item_details.Y = item_details.Y + (item_details.H / 2);
                    item_details["W"] = wpdSetFixed(obj.W);
                    item_details["Item"] = obj.Item;
                    item_details["MIndex"] = obj.MIndex;
                    item_details["SIndex"] = obj.SIndex;
                    item_details["IIndex"] = obj.IIndex;
                    item_details["Orientation"] = obj.Orientation;
                    item_details["CrushHoriz"] = obj.CrushHoriz;
                    item_details["CrushVert"] = obj.CrushVert;
                    item_details["CrushD"] = obj.CrushD;
                    item_details["MHorizCrushed"] = obj.MHorizCrushed;
                    item_details["MVertCrushed"] = obj.MVertCrushed;
                    item_details["MDepthCrushed"] = obj.MDepthCrushed;
                    item_details["CWPerc"] = obj.CWPerc;
                    item_details["CHPerc"] = obj.CHPerc;
                    item_details["CDPerc"] = obj.CDPerc;
                    item_details["H"] = wpdSetFixed(obj.H);
                    item_details["D"] = wpdSetFixed(obj.D);
                    item_details["X"] = wpdSetFixed(obj.X);
                    item_details["Y"] = wpdSetFixed(obj.Y);
                    item_details["Z"] = wpdSetFixed(obj.Z);
                    item_details["RW"] = obj.RW;
                    item_details["RH"] = obj.RH;
                    item_details["RD"] = obj.RD;
                    item_details["BHoriz"] = obj.BHoriz; //ASA-1353 issue 3 regression issue 20240428
                    item_details["BVert"] = obj.BVert; //ASA-1353 issue 3 regression issue 20240428
                    item_details["BaseD"] = obj.BaseD; //ASA-1353 issue 3 regression issue 20240428
                    item_details["Fixed"] = obj.Fixed; //ASA-1353 issue 3 --Task_27104 20240419
                    item_details["SpreadItem"] = obj.SpreadItem;
                    item_arr.push(item_details);
                }
            }
            main_arr.AllowAutoCrush = l_callowcrush;
            // main_arr.End = l_end;//Regression issue 5
            // main_arr.Start = l_start;//Regression issue 5
            main_arr.Start = Math.min.apply(Math, min_x_arr); //Regression issue 5
            main_arr.End = Math.max.apply(Math, max_x_Arr); //Regression issue 5
            main_arr.SpreadItem = l_spread;
            main_arr.ItemInfo = item_arr;
            g_combinedShelfs.push(main_arr);
        }
    }
}
//End ASA-1353 issue 3 --Task_27104 20240417 //Start 20240415 - Regression Issue 8 remove from page_4.js to main as its used in common_main

//Start ASA-1369 revert
/*function get_cap_max_merch(p_mod_index, p_shelf_index, p_modules, p_shelfs, p_pog_index) {
    var l_max_merch = 0;
    var l_calc_max_merch = 0;
    if (p_shelfs.MaxMerch > 0) {
        l_max_merch = p_shelfs.MaxMerch;
    } else if (p_shelfs.Y < p_modules.H + g_pog_json[p_pog_index].BaseH && p_shelfs.Y > 0) {
        l_max_merch = p_modules.H + g_pog_json[p_pog_index].BaseH - p_shelfs.Y;
    } else {
        l_max_merch = parseFloat($v("P25_POGCR_DFT_MAX_MERCH"));
    }
    if (p_shelfs.X >= p_modules.X - p_modules.W / 2 && p_shelfs.X < p_modules.X + p_modules.W / 2 && p_shelfs.Y <= p_modules.H + g_pog_json[p_pog_index].BaseH && p_shelfs.Y > 0) {
        l_calc_max_merch = get_module_max_merch(p_mod_index, p_shelf_index, p_pog_index);
    }
 
    return l_calc_max_merch < l_max_merch && l_calc_max_merch > 0 ? l_calc_max_merch : l_max_merch;
}*/

//This is a global function to get the max merch of the item. (Max merch: the distance between the shelf on which item is present and shelf on top of it for shelf
//for hanging bar -- the distance between hanging bar and shelf below it.)
function get_cap_max_merch(p_mod_index, p_shelf_index, p_modules, p_shelfs, p_pog_index, p_default_max_merch, p_override = "N", p_byPassMedicineOverhung = "N" /*ASA-1638*/, p_item_index = 0 /*ASA-1892 Issue2 added p_item_index*/) {
    // Regression 2 added p_byPassMedicineOverhung
    if (p_shelfs.MaxMerch > 0 && p_override == "N") {
        var max_merch = p_shelfs.MaxMerch;
    } else if (p_shelfs.X >= p_modules.X - p_modules.W / 2 && p_shelfs.X < p_modules.X + p_modules.W / 2 && p_shelfs.Y <= p_modules.H + g_pog_json[p_pog_index].BaseH && p_shelfs.Y > 0) {
        var max_merch = get_module_max_merch(p_mod_index, p_shelf_index, p_pog_index, p_byPassMedicineOverhung, p_item_index); /*ASA-1892 Issue2 added p_item_index*/
    } else if (p_shelfs.Y < p_modules.H + g_pog_json[p_pog_index].BaseH && p_shelfs.Y > 0) {
        var max_merch = p_modules.H + g_pog_json[p_pog_index].BaseH - p_shelfs.Y;
    } else {
        var max_merch = p_default_max_merch;
    }
    return max_merch;
}
//End ASA-1369 revert // End 20240415 - Regression Issue 8
//Start 20240415 Rregression issue 29 20240430
// ASA-1095
//This function is used in recreate_all_items. to find out in a specific shelf if there are same items adjacently. so they can be combined together by increate horizontal
//facings.
function mergeAdjacentItems(p_pog_index, p_moduleIndex, p_shelfIndex, p_itemIndex) {
    try {
        var editIndex = -1,
            merged = false;
        var dropIndex = -1,
            nextIndex = -1;
        var lastitemIndex = g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex].ItemInfo.length - 1;
        var itemInfo = g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex].ItemInfo[p_itemIndex];
        var currItemID = itemInfo.ItemID,
            nextItem = -1,
            dropItem = -1;
        var objId = itemInfo.ObjID;
        //ASA-1765 Issue 3, added itemInfo.Item !== "DIVIDER"
        if (typeof lastitemIndex !== "undefined" && lastitemIndex !== 0 && itemInfo.Item !== "DIVIDER") {
            if (p_itemIndex == 0) {
                nextIndex = p_itemIndex + 1;
            } else if (p_itemIndex == lastitemIndex) {
                dropIndex = p_itemIndex - 1;
            } else {
                nextIndex = p_itemIndex + 1;
                dropIndex = p_itemIndex - 1;
            }

            nextItem = nextIndex !== -1 ? g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex].ItemInfo[nextIndex] : -1;
            dropItem = dropIndex !== -1 ? g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex].ItemInfo[dropIndex] : -1;
            //checking is as below
            // 1. it should be same item, 2. vertical facings should be same, 3. depth facings to be same.
            if (nextItem !== -1 && currItemID == nextItem.ItemID && itemInfo.BVert == nextItem.BVert && itemInfo.BaseD == nextItem.BaseD) {
                nextItem.BHoriz = nextItem.BHoriz + itemInfo.BHoriz;
                editIndex = p_itemIndex + 1;
                merged = true;
            } else if (dropItem !== -1 && currItemID == dropItem.ItemID && itemInfo.BVert == dropItem.BVert && itemInfo.BaseD == dropItem.BaseD) {
                dropItem.BHoriz = dropItem.BHoriz + itemInfo.BHoriz;
                editIndex = dropIndex;
                merged = true;
            }
            //if can be merged. then that item will be removed from world and current item horiz facings will be increased.
            if (merged) {
                var shelfs = g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex];
                var items = g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex].ItemInfo[editIndex];
                var i = 0;

                g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex].ItemInfo.splice(p_itemIndex, 1);
                var object = g_world.getObjectById(objId);
                if (typeof object !== "undefined") {
                    g_world.remove(object);
                }

                for (const fitems of g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex].ItemInfo) {
                    if (fitems.ObjID == items["ObjID"]) {
                        editIndex = i;
                        break;
                    }
                    i++;
                }
                var [select_width, select_height, select_depth] = get_select_dim(items);
                items.Exists = "N";
                //after increasing horiz facings. that item is sent for validation. if validation is passed we pass those results to calling place.
                const [item_width, item_height, item_depth, real_width, real_height, real_depth] = set_dim_validate_item(p_moduleIndex, p_shelfIndex, editIndex, select_width, select_height, select_depth, items.ItemNesting, items.NVal, items.BHoriz, items.BVert, items.BaseD, items.Orientation, items.OrgCWPerc, items.OrgCHPerc, items.OrgCDPerc, "Y", "Y", "Y", p_pog_index);
                if (item_width !== "ERROR") {
                    var [itemx, itemy] = get_item_xy(shelfs, items, item_width, item_height, p_pog_index);
                    items.X = itemx;
                    items.Y = itemy;
                    items.Exists = "E";
                    items.W = item_width;
                    items.H = item_height;
                    items.D = item_depth;
                    items.RW = real_width;
                    items.RH = real_height;
                    items.RD = real_depth;
                }
            }
        }
        return editIndex;
    } catch (err) {
        error_handling(err);
    }
}
//Start ASA-1353 issue 3 --Task_27104 20240417
function get_combine_arr() {
    //asa-1353 mass update to add details for combination
    var shelf_arr = [];
    var combine_arr = [];
    var shelf_object = {};
    var i = 0;
    for (combination of g_combinedShelfs) {
        var item_details = {};
        shelf_arr = [];
        var j = 0;
        for (shelf_info of combination) {
            shelf_object = {};
            shelf_object["SW"] = shelf_info.W;
            shelf_object["Shelf"] = shelf_info.Shelf;
            shelf_object["H"] = shelf_info.H;
            shelf_object["OBJECT"] = "SHELF";
            shelf_object["SComIndex"] = i;
            shelf_object["ShelfCombIndx"] = j;
            //Start ASA-1353 issue 3 --Task_27104
            shelf_object["AllowAutoCrush"] = shelf_info.AllowAutoCrush;
            shelf_object["Combine"] = shelf_info.Combine;
            shelf_object["Module"] = shelf_info.Module;
            shelf_object["ObjType"] = shelf_info.ObjType;
            shelf_object["PIndex"] = shelf_info.PIndex;
            shelf_object["MIndex"] = shelf_info.MIndex;
            shelf_object["SIndex"] = shelf_info.SIndex;
            shelf_object["Rotation"] = shelf_info.Rotation;
            shelf_object["Slope"] = shelf_info.Slope;
            shelf_object["SpreadItem"] = shelf_info.SpreadItem;
            shelf_object["W"] = shelf_info.W;
            shelf_object["X"] = shelf_info.X;
            shelf_object["Y"] = shelf_info.Y;
            shelf_object["CombSpreadItem"] = g_combinedShelfs[0].SpreadItem;
            shelf_object["CombAllowCrush"] = g_combinedShelfs[0].AllowAutoCrush;
            shelf_object["CombStart"] = g_combinedShelfs[0].Start;
            shelf_object["CombEnd"] = g_combinedShelfs[0].End;
            //End ASA-1353 issue 3 --Task_27104
            shelf_arr.push(shelf_object);
            j++;
        }

        for (items of combination.ItemInfo) {
            item_details = {};
            item_details["SW"] = items.RW;
            item_details["Item"] = items.Item;
            //Start ASA-1353 issue 3 --Task_27104
            item_details["MIndex"] = items.MIndex;
            item_details["SIndex"] = items.SIndex;
            item_details["IIndex"] = items.IIndex;
            item_details["Shelf"] = g_pog_json[items.PIndex].ModuleInfo[items.MIndex].ShelfInfo[items.SIndex].Shelf; //ASA-1843 Change g_pog_index to items.PIndex
            item_details["Orientation"] = items.Orientation;
            item_details["CrushHoriz"] = items.CrushHoriz;
            item_details["CrushVert"] = items.CrushVert;
            item_details["CrushD"] = items.CrushD;
            item_details["MHorizCrushed"] = items.MHorizCrushed;
            item_details["MVertCrushed"] = items.MVertCrushed;
            item_details["MDepthCrushed"] = items.MDepthCrushed;
            item_details["CWPerc"] = items.CWPerc;
            item_details["CHPerc"] = items.CHPerc;
            item_details["CDPerc"] = items.CDPerc;
            item_details["H"] = items.H;
            item_details["D"] = items.D;
            item_details["X"] = items.X;
            item_details["Y"] = items.Y;
            item_details["Z"] = items.Z;
            item_details["RW"] = items.RW;
            item_details["RH"] = items.RH;
            item_details["RD"] = items.RD;
            item_details["W"] = items.W;
            item_details["SpreadItem"] = items.SpreadItem;
            item_details["Fixed"] = items.Fixed; //ASA-1353 issue 3 --Task_27104 20240419'
            item_details["BHoriz"] = items.BHoriz; //Task_27624
            item_details["BVert"] = items.BVert; //Task_27624
            item_details["BaseD"] = items.BaseD; //Task_27624
            //End ASA-1353 issue 3 --Task_27104
            item_details["OBJECT"] = "ITEM";
            item_details["IComIndex"] = i;
            shelf_arr.push(item_details);
        }
        combine_arr.push(shelf_arr);
        i++;
    }
    return combine_arr;
}
//End ASA-1353 issue 3 --Task_27104 20240417

//End 20240415 Rregression issue 29 20240430

/*START ASA-1410*/
//This function will check passed items cap style and set all the required attributes to recreate those items and show capping on screen.
//this function is also used in "check_crush_facing_correct" to auto correct items onload. if the validation fails. it will mark it as validation failed.
async function set_item_capping(p_pog_index, p_module_index, p_shelf_index, p_item_index, p_on_load, p_set_value) {
    logDebug("function : set_item_capping; i_item_index : " + p_item_index, "S");
    try {
        //This function is also called from create_shelf_from_json_lib. when a POG is done mass update. the capping attributes are copied from the previous
        // version json for same item and added in new version same item. Now when user opens that POG. we need to apply same capping.
        //for that we will not have the details of shelfs above the item currently passed in g_pog_json because items and shelfs are added in loop only.
        //so we use g_json and p_on_load will be Y.
        if (p_on_load == "Y" && typeof g_json[0] !== "undefined" && g_json.length > 0) {
            //ASA-1410 issue 10 20240625
            if (typeof g_json[0].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index] !== "undefined") {
                var shelfdtl = g_json[0].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
                var itemdtl = shelfdtl.ItemInfo[p_item_index];
                var item_height = itemdtl.RH * itemdtl.BVert;
                var real_depth = itemdtl.RD * itemdtl.BaseD;
            } else {
                var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
                var itemdtl = shelfdtl.ItemInfo[p_item_index];
                var item_height = itemdtl.RH;
                var real_depth = itemdtl.RD;
            }
        } else {
            var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];
            var itemdtl = shelfdtl.ItemInfo[p_item_index];
            var item_height = itemdtl.RH;
            var real_depth = itemdtl.RD;
        } //End ASA-1410 issue 10 20240625
        //var shelfdtl = g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index];//ASA-1410 issue 10 20240625

        var itemdtl_cnt = -1;
        var modules = g_pog_json[p_pog_index].ModuleInfo[p_module_index];
        /*var item_height = itemdtl.RH,//itemdtl.H //ASA-1410//ASA-1410 issue 10 20240625
            // item_depth = itemdtl.D, //ASA-1410
            real_depth = itemdtl.RD,*/

        //var new_height = p_item_height * p_vert_facing + (items.VertGap / 100) * (p_vert_facing - 1); //ASA-1170 : - crush_height;
        var new_height = 0,
            cap_width = 0,
            cap_height = 0,
            valid_pass = "N", //ASA-1410 Issue 10 //ASA-1412 issue 1 20240628
            cap_depth = 0,
            cap_max_merch = 0; //ASA-1412 issue 1 20240628
        // capping is only allowed for SHELF.
        if ((itemdtl.CapStyle == "1" || itemdtl.CapStyle == "2" || itemdtl.CapStyle == "3") && shelfdtl.ObjType == "SHELF") {
            var cap_merch = itemdtl.CapMerch;
            //if called from create_shelf_from_json_lib then user g_json
            if (p_on_load == "Y" && typeof g_json[0] !== "undefined") {
                //ASA-1410 issue 10 20240625
                var l_max_merch = get_onload_max_merch(p_module_index, p_shelf_index, modules, shelfdtl, g_dft_max_merch, 0, g_json);
            } else {
                var l_max_merch = get_cap_max_merch(p_module_index, p_shelf_index, modules, shelfdtl, p_pog_index, g_dft_max_merch); //ASA-1353 issue 3 --Task_27104 20240419//20240415 - Regression Issue 8
            }
            cap_max_merch = l_max_merch; //ASA-1412 issue 1 20240628
            var cap_max_high = itemdtl.CapMaxH;
            //var new_depth = real_depth * itemdtl.BaseD;//ASA-1410 issue 10 20240625

            var cap_merch = itemdtl.CapMerch == "" ? "0" : itemdtl.CapMerch;
            var cap_orientation = itemdtl.CapOrientaion == "" ? "4" : itemdtl.CapOrientaion;
            //based on the merch style of the cap setting get the dimensions.
            if (cap_merch == "0") {
                if (wpdSetFixed(itemdtl.UW) !== wpdSetFixed(itemdtl.OrgUW) || wpdSetFixed(itemdtl.UH) !== wpdSetFixed(itemdtl.OrgUH) || wpdSetFixed(itemdtl.UD) !== wpdSetFixed(itemdtl.OrgUD)) {
                    cap_width = itemdtl.OrgUW;
                    cap_height = itemdtl.OrgUH;
                    cap_depth = itemdtl.OrgUD;
                } else {
                    cap_width = itemdtl.UW;
                    cap_height = itemdtl.UH;
                    cap_depth = itemdtl.UD;
                }
            } else if (cap_merch == "2") {
                if (wpdSetFixed(itemdtl.CW) !== wpdSetFixed(itemdtl.OrgCW) || wpdSetFixed(itemdtl.CH) !== wpdSetFixed(itemdtl.OrgCH) || wpdSetFixed(itemdtl.CD) !== wpdSetFixed(itemdtl.OrgCD)) {
                    cap_width = itemdtl.OrgCW;
                    cap_height = itemdtl.OrgCH;
                    cap_depth = itemdtl.OrgCD;
                } else {
                    cap_width = itemdtl.CW;
                    cap_height = itemdtl.CH;
                    cap_depth = itemdtl.CD;
                }
            } else if (cap_merch == "1") {
                if (wpdSetFixed(itemdtl.TW) !== wpdSetFixed(itemdtl.OrgTW) || wpdSetFixed(itemdtl.TH) !== wpdSetFixed(itemdtl.OrgTH) || wpdSetFixed(itemdtl.TD) !== wpdSetFixed(itemdtl.OrgTD)) {
                    cap_width = itemdtl.OrgTW;
                    cap_height = itemdtl.OrgTH;
                    cap_depth = itemdtl.OrgTD;
                } else {
                    cap_width = itemdtl.TW;
                    cap_height = itemdtl.TH;
                    cap_depth = itemdtl.TD;
                }
            } else if (cap_merch == "3") {
                if (wpdSetFixed(itemdtl.DW) !== wpdSetFixed(itemdtl.OrgDW) || wpdSetFixed(itemdtl.DH) !== wpdSetFixed(itemdtl.OrgDH) || wpdSetFixed(itemdtl.DD) !== wpdSetFixed(itemdtl.OrgDD)) {
                    cap_width = itemdtl.OrgDW;
                    cap_height = itemdtl.OrgDH;
                    cap_depth = itemdtl.OrgDD;
                } else {
                    cap_width = itemdtl.DW;
                    cap_height = itemdtl.DH;
                    cap_depth = itemdtl.DD;
                }
            }
            // if there is cap orientation set. get the dimensions based on orientation.
            var [cWidth, cHeight, cDepth, capActualHeight, capActualWidth, capActualDepth] = get_new_orientation_dim(cap_orientation, cap_width, cap_height, cap_depth);

            var orgCapDepth = cap_height;
            var mCapDepthCount = itemdtl.CapDepth !== "" && itemdtl.CapDepth > 1 ? parseInt(itemdtl.CapDepth) : 1;
            var mCapDepth = orgCapDepth * mCapDepthCount;
            if (mCapDepth > real_depth) {
                //ASA-1410 issue 10 20240625
                itemdtl.CapDepth = Math.trunc(real_depth / cDepth);
            }
            //if the actual cap height is W. then user cap_width else always use depth.
            if (capActualHeight == "W") {
                cap_height = cap_width;
            } else {
                cap_height = cap_depth;
            }
            var mCapCount = itemdtl.CapFacing !== "" && itemdtl.CapFacing > 0 && itemdtl.CapFacing > cap_max_high && cap_max_high > 0 ? parseInt(cap_max_high) : parseInt(itemdtl.CapFacing);
            //validation if RD is less then capping dimension depth then no capping allowed.
            //validation if no of cappings exceeds items CapMaxH. then set back capping to CapMaxH.
            //Logic for cap style = 1 (Min cap)
            //always set 1 capping only and vertical facings does not change.
            if (itemdtl.CapStyle == "1") {
                l_max_merch = l_max_merch - item_height;
                itemdtl_cnt = Math.trunc(l_max_merch / cap_height);
                if (real_depth < cDepth) {
                    itemdtl_cnt = 0;
                }
                if (itemdtl_cnt > 0) {
                    itemdtl_cnt = 1;
                    new_height = item_height + cap_height * itemdtl_cnt;
                }
                //Logic for cap style = 2 (Med Cap)
                //keep the vertical facings intact and increase no of capping count till reach the max merch.
            } else if (itemdtl.CapStyle == "2") {
                //  l_max_merch = l_max_merch - new_height; //vivek
                l_max_merch = l_max_merch - item_height;
                itemdtl_cnt = Math.trunc(l_max_merch / cap_height);
                if (itemdtl.MaxHCapStyle == "2" && itemdtl_cnt > cap_max_high && cap_max_high > 0) {
                    itemdtl_cnt = cap_max_high;
                }
                if (itemdtl_cnt > 0) {
                    //ASA-1412 issue 11 2240709
                    itemdtl_cnt = itemdtl.MCapTopFacing == "Y" && mCapCount > 0 ? mCapCount : itemdtl_cnt;
                } else {
                    itemdtl_cnt = 0;
                }
                if (real_depth < cDepth) {
                    itemdtl_cnt = 0;
                }
                if (itemdtl_cnt > 0) {
                    //  p_item_height = new_height + cap_height * items_cnt; //ASA-1170 //vivek
                    new_height = item_height + cap_height * itemdtl_cnt;
                }
                //logic for cap style = 3 (Max Cap)
                //vertical facings will be changed to 1 and then calculate no of capping allowed till max merch.
            } else if (itemdtl.CapStyle == "3") {
                l_max_merch = l_max_merch - item_height / itemdtl.BVert; //ASA-1410 issue 10 20240625
                itemdtl_cnt = Math.trunc(l_max_merch / cap_height);
                if (itemdtl.MaxHCapStyle == "3" && itemdtl_cnt > cap_max_high && cap_max_high > 0) {
                    itemdtl_cnt = cap_max_high;
                }
                // itemdtl_cnt = itemdtl.MCapTopFacing == "Y" && mCapCount > 0 ? mCapCount : itemdtl_cnt;

                if (itemdtl_cnt > 0) {
                    //ASA-1412 issue 11 2240709
                    itemdtl_cnt = itemdtl.MCapTopFacing == "Y" && mCapCount > 0 ? mCapCount : itemdtl_cnt;
                } else {
                    itemdtl_cnt = 0;
                }

                if (real_depth < cDepth) {
                    itemdtl_cnt = 0;
                }
                if (itemdtl_cnt > 0) {
                    new_height = item_height / itemdtl.BVert + cap_height * itemdtl_cnt; //ASA-1412 issue 1 20240708
                    itemdtl.BVert = 1;
                }
            }
        }
        //if there is no items does not have dimensions. retain the cap settings as below.
        if (cap_width == 0 && cap_height == 0 && cap_depth == 0 && p_set_value == "Y") {
            //ASA-1410 Issue 10 //ASA-1412 issue 1 20240628
            g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapMerch = cap_merch;
            g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapOrientaion = cap_orientation;
        } else {
            //ASA-1410 Issue 10
            if (itemdtl_cnt > 0) {
                //setting all the capping attributes to make the item show its cappings on screen after recreate.
                var capHorzCount = itemdtl.BHoriz;
                var capCount = itemdtl_cnt * capHorzCount * mCapDepthCount;
                if (p_set_value == "Y") {
                    //ASA-1410 Issue 10 //ASA-1412 issue 1 20240628
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapFacing = itemdtl_cnt;
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapMerch = cap_merch;
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapOrientaion = cap_orientation;
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapHeight = cap_height;
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].MCapTopFacing = itemdtl.MCapTopFacing;
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapDepth = Math.trunc(real_depth / cDepth);

                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapCount = itemdtl_cnt;

                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapHorz = capHorzCount;

                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapTotalCount = capCount;
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].H = new_height;
                    var [new_x, itemy] = get_item_xy(shelfdtl, itemdtl, itemdtl.W, itemdtl.H, p_pog_index);
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].Y = itemy;
                }
            } else {
                //Setting all the settings back to default when capping fails.
                if (p_set_value == "Y") {
                    //ASA-1410 Issue 10 //ASA-1412 issue 1 20240628
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapFacing = 0;
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapHeight = 0;
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].MCapTopFacing = "N";
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapCount = 0;
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapHorz = 0;
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapDepth = 0;
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapTotalCount = 0;
                    // g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapStyle = '0';//ASA-1412 issue 11 2240709       //ASA-1476 #5
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].CapStyle = itemdtl.CapStyle; //ASA-1412 issue 11 2240709       //ASA-1476 #5
                    //itemdtl.CapStyle = '0';//ASA-1412 issue 11 2240709
                    //item_height = item_height;// * itemdtl.BVert + (nvl(itemdtl.VertGap) / 100) * (itemdtl.BVert - 1);//ASA-1410 issue 10 20240625 ASA-1476 Issue 3
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].H = item_height; //ASA-1476 Issue 3
                    var [new_x, itemy] = get_item_xy(shelfdtl, itemdtl, itemdtl.W, itemdtl.H, p_pog_index);
                    g_pog_json[p_pog_index].ModuleInfo[p_module_index].ShelfInfo[p_shelf_index].ItemInfo[p_item_index].Y = itemy;
                }
            }
        } //ASA-1410 Issue 10
        //This function is also used for validating
        if (cap_max_merch >= new_height) {
            //ASA-1410 Issue 10 //ASA-1412 issue 1 20240628
            valid_pass = "Y";
        }
        return valid_pass;
    } catch (err) {
        error_handling(err);
    }
}
/*END ASA-1410*/

//ASA-1405
//This function is used to find out if the item sent in the param is hitting any of the items in the whole chest.
//its called in loop while crushing item for chest. this will pass N and then the crushing will stop and it will pass.
function checkChestCrushedItemHit(p_citem_x, p_citem_y, p_citem_w, p_citem_h, p_shelf, p_item_index) {
    try {
        var l_cnt = 0;
        var citem_start = wpdSetFixed(p_citem_x - p_citem_w / 2),
            citem_end = wpdSetFixed(p_citem_x + p_citem_w / 2),
            citem_top = wpdSetFixed(p_citem_y + p_citem_h / 2),
            citem_bottom = wpdSetFixed(p_citem_y - p_citem_h / 2);
        const shelf_start = wpdSetFixed(p_shelf.X - p_shelf.W / 2),
            shelf_end = wpdSetFixed(p_shelf.X + p_shelf.W / 2),
            shelf_bottom = wpdSetFixed(p_shelf.Y - p_shelf.H / 2),
            shelf_top = wpdSetFixed(p_shelf.Y + p_shelf.H / 2);
        for (const items of p_shelf.ItemInfo) {
            if (l_cnt !== p_item_index) {
                var ov_start = wpdSetFixed(items.X - items.W / 2),
                    ov_end = wpdSetFixed(items.X + items.W / 2),
                    ov_top = wpdSetFixed(items.Y + items.H / 2),
                    ov_bottom = wpdSetFixed(items.Y - items.H / 2);
                if (!(citem_top < ov_bottom || citem_bottom > ov_top) && !(citem_end < ov_start || citem_start > ov_end)) {
                    if ((citem_top > ov_bottom && ov_bottom > citem_bottom && !(citem_bottom < ov_top && ov_top < citem_top) && ((citem_start < ov_end && ov_end < citem_end) || (citem_end > ov_start && ov_start > citem_start))) || (!(citem_top > ov_bottom && ov_bottom > citem_bottom) && citem_bottom < ov_top && ov_top < citem_top && ((citem_start < ov_end && ov_end < citem_end) || (citem_end > ov_start && ov_start > citem_start))) || (((citem_top > ov_bottom && ov_bottom > citem_bottom) || (citem_bottom < ov_top && ov_top < citem_top)) && !(citem_start < ov_end && ov_end < citem_end) && citem_end > ov_start && ov_start > citem_start) || (((citem_top > ov_bottom && ov_bottom > citem_bottom) || (citem_bottom < ov_top && ov_top < citem_top)) && citem_start < ov_end && ov_end < citem_end && !(citem_end > ov_start && ov_start > citem_start))) {
                        return "Y";
                    }
                } else if (citem_top > shelf_top || citem_bottom < shelf_bottom || citem_start < shelf_start || citem_end > shelf_end) {
                    return "Y";
                }
            }
            l_cnt++;
        }
        return "N";
    } catch (err) {
        error_handling(err);
    }
}
function getChestOverlappedItemDimension(p_item_x, p_item_y, p_item_w, p_item_h, p_overlapped_item) {
    try {
        const item_start = wpdSetFixed(p_item_x - p_item_w / 2),
            item_end = wpdSetFixed(p_item_x + p_item_w / 2),
            item_top = wpdSetFixed(p_item_y + p_item_h / 2),
            item_bottom = wpdSetFixed(p_item_y - p_item_h / 2);
        var ov_top, ov_bottom, ov_start, ov_end;
        var crushedWidth = 0,
            crushedHeight = 0,
            leftOverlap = 0,
            rightOverlap = 0,
            topOverlap = 0,
            bottomOverlap = 0;
        var itemHit = "N",
            shelfHit = "N";

        //Objtype CHEST means if the items is hanging outside the CHEST. so check which part of the item is hanging outside.
        if (nvl(p_overlapped_item.ObjType) == "CHEST") {
            ov_top = wpdSetFixed(p_overlapped_item.Y + p_overlapped_item.H / 2);
            ov_bottom = wpdSetFixed(p_overlapped_item.Y - p_overlapped_item.H / 2);
            ov_start = wpdSetFixed(p_overlapped_item.X - p_overlapped_item.W / 2);
            ov_end = wpdSetFixed(p_overlapped_item.X + p_overlapped_item.W / 2);

            if (item_top > ov_top) {
                topOverlap = item_top - ov_top;
                crushedHeight = topOverlap;
                shelfHit = "Y";
            }
            if (item_bottom < ov_bottom) {
                bottomOverlap = ov_bottom - item_bottom;
                crushedHeight += bottomOverlap;
                shelfHit = "Y";
            }
            if (item_start < ov_start) {
                leftOverlap = shelf_start - ov_start;
                crushedWidth = leftOverlap;
                shelfHit = "Y";
            }
            if (item_end > ov_end) {
                rightOverlap = item_end - ov_end;
                crushedWidth += rightOverlap;
                shelfHit = "Y";
            }
        } else {
            ov_top = wpdSetFixed(p_overlapped_item.Y + p_overlapped_item.H / 2);
            ov_bottom = wpdSetFixed(p_overlapped_item.Y - p_overlapped_item.H / 2);
            ov_start = wpdSetFixed(p_overlapped_item.X - p_overlapped_item.W / 2);
            ov_end = wpdSetFixed(p_overlapped_item.X + p_overlapped_item.W / 2);

            //This will check the overlapping item with hit item that which part of the item is overlapped. left,right, top or bottom.
            if (item_top > ov_bottom && ov_bottom > item_bottom && !(item_bottom < ov_top && ov_top < item_top)) {
                topOverlap = item_top - ov_bottom;
                crushedHeight = topOverlap;
                itemHit = "Y";
            }
            if (item_bottom < ov_top && ov_top < item_top && !(item_top > ov_bottom && ov_bottom > item_bottom)) {
                bottomOverlap = ov_top - item_bottom;
                crushedHeight += bottomOverlap;
                itemHit = "Y";
            }
            if (item_start < ov_end && ov_end < item_end && !(item_end > ov_start && ov_start > item_start)) {
                leftOverlap = ov_end - item_start;
                crushedWidth = leftOverlap;
                itemHit = "Y";
            }
            if (item_end > ov_start && ov_start > item_start && !(item_start < ov_end && ov_end < item_end)) {
                rightOverlap = item_end - ov_start;
                crushedWidth += rightOverlap;
                itemHit = "Y";
            }
        }
        //Here we are find out if which part is overlapping and maintaining the position of the item.Example
        //if right side of the item is overlapping the right side of the item will be crushed and left side of the item will maintain same position.
        const crushWidthPerc = Math.ceil((crushedWidth / p_item_w) * 100);
        const crushHeightPerc = Math.ceil((crushedHeight / p_item_h) * 100);
        const newWidth = wpdSetFixed(p_item_w * (1 - crushWidthPerc / 100));
        const newHeight = wpdSetFixed(p_item_h * (1 - crushHeightPerc / 100));
        var newX = p_item_x,
            newY = p_item_y;
        if (crushWidthPerc !== 0) {
            if (rightOverlap > leftOverlap) {
                if (shelfHit == "Y") {
                    newX = ov_end - newWidth / 2;
                } else {
                    newX = ov_start - newWidth / 2;
                }
            } else {
                if (shelfHit == "Y") {
                    newX = ov_start + newWidth / 2;
                } else {
                    newX = ov_end + newWidth / 2;
                }
            }
        }
        if (crushHeightPerc !== 0) {
            if (topOverlap > bottomOverlap) {
                if (shelfHit == "Y") {
                    newY = ov_top - newHeight / 2;
                } else {
                    newY = ov_bottom - newHeight / 2;
                }
            } else {
                if (shelfHit == "Y") {
                    newY = ov_bottom + newHeight / 2;
                } else {
                    newY = ov_top + newHeight / 2;
                }
            }
        }
        //setting the array with newly created details and pass it to calling place.
        if (itemHit == "Y" || shelfHit == "Y") {
            if (crushWidthPerc == 0 && crushHeightPerc !== 0) {
                return [p_item_x, newY, p_item_w, newHeight, 0, crushHeightPerc];
            } else if (crushWidthPerc !== 0 && crushHeightPerc == 0) {
                return [newX, p_item_y, newWidth, p_item_h, crushWidthPerc, 0];
            } else if (crushWidthPerc !== 0 && crushHeightPerc !== 0) {
                if (shelfHit == "Y") {
                    return [newX, newY, newWidth, newHeight, crushWidthPerc, crushHeightPerc];
                } else {
                    if (crushWidthPerc > crushHeightPerc) {
                        return [p_item_x, newY, p_item_w, newHeight, 0, crushHeightPerc];
                    } else {
                        return [newX, p_item_y, newWidth, p_item_h, crushWidthPerc, 0];
                    }
                }
            } else {
                return [p_item_x, p_item_y, p_item_w, p_item_h, 0, 0];
            }
        } else {
            return [p_item_x, p_item_y, p_item_w, p_item_h, 0, 0];
        }
    } catch (err) {
        error_handling(err);
    }
}

//This function is called from crushitem function. so find all the items that overlap on a specific item and try to find out how much to be crush so that the position
//of the item is not moved.
function crushChestItemHW(p_shelf, p_item, p_item_index, p_crush_height_perc, p_crush_width_perc, p_item_manual_wc_ind, p_item_manual_hc_ind, p_actualHeight, p_actualWidth, p_set_ind) {
    try {
        var l_cnt = 0;
        var item_height = p_item.RH + nvl(p_item.CapHeight),
            item_width = p_item.RW,
            item_X = p_item.X,
            item_Y = p_item.Y;
        var itemHitArr = [];
        var item_start = wpdSetFixed(item_X - item_width / 2),
            item_end = wpdSetFixed(item_X + item_width / 2),
            item_top = wpdSetFixed(item_Y + item_height / 2),
            item_bottom = wpdSetFixed(item_Y - item_height / 2);
        //First find out all the items that hit the current item to be crushed.
        for (const item of p_shelf.ItemInfo) {
            if (l_cnt !== p_item_index) {
                var div_start = wpdSetFixed(item.X - item.W / 2),
                    div_end = wpdSetFixed(item.X + item.W / 2),
                    div_top = wpdSetFixed(item.Y + item.H / 2),
                    div_bottom = wpdSetFixed(item.Y - item.H / 2);
                if (!(item_top < div_bottom || item_bottom > div_top) && !(item_end < div_start || item_start > div_end)) {
                    itemHitArr.push(item);
                }
                l_cnt++;
            }
        }

        var shelf_start = wpdSetFixed(p_shelf.X - p_shelf.W / 2),
            shelf_end = wpdSetFixed(p_shelf.X + p_shelf.W / 2),
            shelf_bottom = wpdSetFixed(p_shelf.Y - p_shelf.H / 2),
            shelf_top = wpdSetFixed(p_shelf.Y + p_shelf.H / 2);
        //Check in current item is outside the chest in all sides.
        if (item_top > shelf_top || item_bottom < shelf_bottom || item_start <= shelf_start || item_end > shelf_end) {
            itemHitArr.push(p_shelf);
        }

        var [itemX, itemY, itemW, itemH] = [item_X, item_Y, item_width, item_height];
        var finalWidthCrushPerc = 0,
            finalHeightCrush = 0;
        for (ovpItem of itemHitArr) {
            // call the below function and find out what is the percentage of overlap and which side. so that only that much of item is crushed and item new XY will be set
            // so that item is maintaining same position.
            [itemX, itemY, itemW, itemH, itemWidthCrush, itemHeightCrush] = getChestOverlappedItemDimension(itemX, itemY, itemW, itemH, ovpItem);
            finalWidthCrushPerc += itemWidthCrush;
            finalHeightCrush += itemHeightCrush;
        }

        if (p_set_ind == "Y") {
            // check if total width and height crush perec is less than max crush perc. then set the items crush perc, H,W,X,Y
            if (finalWidthCrushPerc <= p_crush_width_perc && finalHeightCrush <= p_crush_height_perc && p_item_manual_wc_ind == "N" && p_item_manual_hc_ind == "N") {
                p_item.W = itemW;
                p_item.X = itemX;
                p_item.WChanged = "Y";
                if (p_actualWidth == "W") {
                    p_item.CrushHoriz = finalWidthCrushPerc;
                } else if (p_actualWidth == "H") {
                    p_item.CrushVert = finalWidthCrushPerc;
                } else if (p_actualWidth == "D") {
                    p_item.CrushD = finalWidthCrushPerc;
                }

                p_item.H = itemH;
                p_item.Y = itemY;
                p_item.HChanged = "Y";
                if (p_actualHeight == "H") {
                    p_item.CrushVert = finalHeightCrush;
                } else if (p_actualHeight == "W") {
                    p_item.CrushHoriz = finalHeightCrush;
                } else if (p_actualHeight == "D") {
                    p_item.CrushD = finalHeightCrush;
                }
                g_error_category = "";
                return "Y";
                //If manual crush is set to Y. the directly crush the item for the crush perc set by user.
            } else if (p_item_manual_wc_ind == "Y" || p_item_manual_hc_ind == "Y") {
                const manualWidth = wpdSetFixed(item_width - item_width * (p_crush_width_perc / 100));
                const manualHeight = wpdSetFixed(item_height - item_height * (p_crush_height_perc / 100));
                if (checkChestCrushedItemHit(p_item.X, p_item.Y, p_item_manual_wc_ind == "Y" ? manualWidth : item_width, p_item_manual_hc_ind == "Y" ? manualHeight : p_item.H, p_shelf, p_item_index) == "N") {
                    if (p_item_manual_wc_ind == "Y") {
                        p_item.W = manualWidth;
                        p_item.WChanged = "Y";
                        if (p_actualWidth == "W") {
                            p_item.CrushHoriz = p_crush_width_perc;
                        } else if (p_actualWidth == "H") {
                            p_item.CrushVert = p_crush_width_perc;
                        } else if (p_actualWidth == "D") {
                            p_item.CrushD = p_crush_width_perc;
                        }
                    }

                    if (p_item_manual_hc_ind == "Y") {
                        p_item.H = manualHeight;
                        p_item.HChanged = "Y";
                        if (p_actualHeight == "H") {
                            p_item.CrushVert = p_crush_height_perc;
                        } else if (p_actualHeight == "W") {
                            p_item.CrushHoriz = p_crush_height_perc;
                        } else if (p_actualHeight == "D") {
                            p_item.CrushD = p_crush_height_perc;
                        }
                    }
                    g_error_category = "";
                    return "Y";
                } else {
                    g_error_category = "W";
                    return "N";
                }
            } else {
                g_error_category = "";
                return "Y";
            }
        }
        g_error_category = "";
        return "Y";
    } catch (err) {
        error_handling(err);
    }
}

//ASA-1405
//ASA-1936.2 Regression Fix
function permuteArrayOfArrays(p_arr) {
    let result = [];
    function permuteHelper(arr, m = []) {
        if (arr.length === 0) {
            result.push(m);
        } else {
            for (let i = 0; i < arr.length; i++) {
                let curr = arr.slice();
                let next = curr.splice(i, 1);
                permuteHelper(curr.slice(), m.concat(next));
            }
        }
    }
    permuteHelper(p_arr);
    return result;
}

function getSafeRandomizedLayout(itemHitArr, item_X, item_Y, item_width, item_height, iterations = 5000) { //ASA-1936 Issue 2
    let bestLayout = null;
    let bestTotalArea = -Infinity;

    for (let iter = 0; iter < iterations; iter++) {
        const shuffledItems = itemHitArr.slice().sort(() => Math.random() - 0.5);

        const layoutResult = [];
        let currentX = item_X;
        let currentY = item_Y;
        let maxRowHeight = 0;
        let totalArea = 0;

        for (const ovpItem of shuffledItems) {
            let [itemX, itemY, itemW, itemH, itemWidthCrush, itemHeightCrush] =
                getChestOverlappedItemDimension(currentX, currentY, item_width, item_height, ovpItem);
            const minW = item_width * 0.5;
            const minH = item_height * 0.5;
            if (itemW < minW) itemW = minW;
            if (itemH < minH) itemH = minH;

            layoutResult.push({
                item: ovpItem,
                ItemX: currentX,
                ItemY: currentY,
                ItemW: itemW,
                ItemH: itemH,
                ItemWidthCrush: itemWidthCrush,
                ItemHeightCrush: itemHeightCrush,
                Area: itemW * itemH
            });

            totalArea += itemW * itemH;
            currentX += itemW;
            maxRowHeight = Math.max(maxRowHeight, itemH);
        }
        if (totalArea > bestTotalArea) {
            bestTotalArea = totalArea;
            bestLayout = layoutResult;
        }
    }

    return bestLayout;
}

//ASA-1405
function getObjectWithHighestValue(p_arr, p_key) {
    return p_arr.reduce((maxObj, currentObj) => {
        return currentObj[p_key] > (maxObj[p_key] || -Infinity) ? currentObj : maxObj;
    }, {});
}

function showItemSubLabel(p_subLabel, p_itemLabelInd, p_pogcrItemBackLabelColor, p_itemLabelPos, p_pog_index) {
    try {
        var module_details = g_pog_json[p_pog_index].ModuleInfo;
        var details = {};
        var finalAction;
        if (typeof g_undoRedoAction == "undefined") {
            g_undoRedoAction = "REDO";
        }
        if (g_undoRedoAction == "REDO") {
            finalAction = "U";
        } else {
            finalAction = "R";
        }
        var i = 0;
        if (p_itemLabelInd == "Y") {
            for (const modules of module_details) {
                if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                    var l_shelf_details = modules.ShelfInfo;
                    var j = 0;
                    for (const shelfs of l_shelf_details) {
                        if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX") {
                            if (shelfs.ItemInfo.length > 0) {
                                var item_Details = shelfs.ItemInfo;
                                var k = 0;
                                for (const items of item_Details) {
                                    if (items.Item !== "DIVIDER") {
                                        //&& items.LocID !== "" && typeof items.LocID !== "undefined"
                                        var item_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(items.ObjID);
                                        if (typeof item_obj !== "undefined") {
                                            if (typeof items.SubLblObjID !== "undefined" && items.SubLblObjID !== -1) {
                                                var label_obj = item_obj.getObjectById(items.SubLblObjID);
                                                item_obj.remove(label_obj);
                                            }
                                            var back_color = p_pogcrItemBackLabelColor,
                                                text_color,
                                                red,
                                                green,
                                                blue;
                                            if (hexToRgb(back_color) == null) {
                                                red = parseInt("FF", 16);
                                                green = parseInt("FF", 16);
                                                blue = parseInt("FF", 16);
                                            } else {
                                                red = hexToRgb(back_color).r;
                                                green = hexToRgb(back_color).r;
                                                blue = hexToRgb(back_color).g;
                                            }
                                            text_color = getTextColor(red, green, blue);
                                            var text_display = "";
                                            var SalesInfo = get_sales_info(p_pog_index, items.ItemID);
                                            if (p_subLabel == "LPR") {
                                                text_display = nvl(items.ItemID) !== 0 ? items.ItemID : "";
                                            } else if (p_subLabel == "LQT") {
                                                text_display = nvl(items.SalesUnit) !== 0 ? items.SalesUnit : "";
                                            } else if (p_subLabel == "LSL") {
                                                var avgsales = parseFloat(items.AvgSales).toFixed(2);
                                                text_display = nvl(items.AvgSales) !== 0 ? avgsales : "";
                                            } else if (p_subLabel == "LST") {
                                                text_display = nvl(items.StoreSOH) !== 0 ? items.StoreSOH : "";
                                            } else if (p_subLabel == "LDP") {
                                                text_display = nvl(items.ActualDPP) !== 0 ? items.ActualDPP : "";
                                            } else if (p_subLabel == "LSC") {
                                                text_display = nvl(items.StoreCnt) !== 0 ? items.StoreCnt : "";
                                            } else if (p_subLabel == "LNP") {
                                                if (nvl(items.NewItem) !== 0 && items.NewItem !== "N" && items.LiveNewItem !== "Y") {
                                                    text_display = items.NewItem;
                                                } else if (items.LiveNewItem !== "N" && g_pogcr_live_new_item == "Y") {
                                                    text_display = nvl(items.LiveNewItem) !== 0 && items.LiveNewItem == "Y" ? "New" : ""; //ASA-1250
                                                }
                                            } else if (p_subLabel == "COS") {
                                                //ASA-1407 -S
                                                var det_arr = items.SizeDesc.split("*");
                                                var cap_capacity = items.CapFacing * items.CapDepth * items.CapHorz * parseInt(items.CapMerch == 1 ? items.UnitperTray : 1); //ASA-1605
                                                //var cap_capacity = items.CapFacing * items.CapDepth * items.CapHorz; //ASA-1341 Issue-2 added Cap_capacity in COS Calculation. //ASA-1605
                                                details = (items.BHoriz * items.BVert * items.BaseD * parseInt(items.MerchStyle == 1 ? items.UnitperTray : items.MerchStyle == 2 ? items.UnitperCase : 1) + cap_capacity) / parseInt(det_arr[1]); //ASA-1605 //ASA-1871 adding condition for case
                                                //details = ((items.BHoriz * items.BVert * items.BaseD) + cap_capacity) / parseInt(det_arr[1]); //ASA-1247 //ASA-1605

                                                if (isNaN(details) || !isFinite(details)) {
                                                    text_display = "";
                                                } else {
                                                    text_display = details.toFixed(1);
                                                }
                                            } else if (p_subLabel == "DOS") {
                                                details = (items.BHoriz * items.BVert * items.BaseD * parseInt(items.MerchStyle == 1 ? items.UnitperTray : items.MerchStyle == 2 ? items.UnitperCase : 1)) / (SalesInfo.SalesUnitPerWeek / 7); //ASA-1605 //ASA-1871 adding condition for case
                                                //details = (items.BHoriz * items.BVert * items.BaseD) / (SalesInfo.SalesUnitPerWeek / 7); //ASA-1605
                                                if (isNaN(details) || !isFinite(details)) {
                                                    text_display = "";
                                                } else {
                                                    text_display = details.toFixed(1);
                                                }
                                            } else if (p_subLabel == "SU") {
                                                text_display = nvl(SalesInfo.SalesUnitPerWeek) !== 0 ? SalesInfo.SalesUnitPerWeek : "";
                                            } else if (p_subLabel == "SV") {
                                                text_display = nvl(SalesInfo.SalesPerWeek) !== 0 ? SalesInfo.SalesPerWeek : "";
                                            } else if (p_subLabel == "VRMPer") {
                                                text_display = nvl(SalesInfo.VRMPer) !== 0 ? SalesInfo.VRMPer : ""; //ASA-1407 Task 1
                                            } else if (p_subLabel == "EDLP") {
                                                //ASA-1407 -E
                                                text_display = nvl(items.EDLP) !== 0 ? items.EDLP : "";
                                            }
                                            console.log("text", nvl(items.LiveNewItem), items.LiveNewItem);
                                            if (text_display !== "") {
                                                var return_obj = addlabelText(text_display, g_labelFont, g_labelActualSize, text_color, "center", back_color);
                                                item_obj.add(return_obj);
                                                return_obj.position.x = 0;
                                                if ((p_itemLabelPos == "CENTER" || p_itemLabelPos == "BOTTOM") && p_itemLabelInd == "Y") {
                                                    return_obj.position.y = items.H / 2 + 0.0015625 * g_labelFont;
                                                } else {
                                                    return_obj.position.y = 0 - items.H / 2 + 0.0015625 * g_labelFont;
                                                }

                                                if (shelfs.Rotation !== 0 || shelfs.Slope !== 0) {
                                                    // return_obj.position.z = items.D / 2 + 0.0005;    //ASA-1496 #3
                                                    return_obj.position.z = items.D / 2 + 0.0055; //ASA-1496 #3
                                                } else {
                                                    // return_obj.position.z = 0.0005;                     //ASA-1496 #3
                                                    return_obj.position.z = 0.0015; //ASA-1496 #3
                                                }
                                                g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].ItemInfo[k].SubLblObjID = return_obj.id;
                                            }
                                        }
                                    } else if (items.Item !== "DIVIDER") {
                                        if (typeof items.SubLblObjID !== "undefined" && items.SubLblObjID !== -1) {
                                            var item_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(items.ObjID);
                                            if (typeof item_obj !== "undefined") {
                                                var label_obj = item_obj.getObjectById(items.SubLblObjID);
                                                item_obj.remove(label_obj);
                                            }
                                        }
                                    }
                                    k = k + 1;
                                }
                            }
                        }
                        j = j + 1;
                    }
                }
                i = i + 1;
            }
        } else {
            var i = 0;
            for (const modules of module_details) {
                if (typeof modules.ParentModule == "undefined" || modules.ParentModule == null) {
                    var l_shelf_details = modules.ShelfInfo;
                    var j = 0;
                    for (const shelfs of l_shelf_details) {
                        if (shelfs.ObjType !== "BASE" && shelfs.ObjType !== "NOTCH" && shelfs.ObjType !== "DIVIDER" && shelfs.ObjType !== "TEXTBOX") {
                            if (shelfs.ItemInfo.length > 0) {
                                var item_Details = shelfs.ItemInfo;
                                var k = 0;
                                for (const items of item_Details) {
                                    if (items.Item !== "DIVIDER" && items.LocID !== "" && typeof items.LocID !== "undefined") {
                                        var item_obj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(items.ObjID);
                                        if (typeof item_obj !== "undefined") {
                                            if (typeof items.SubLblObjID !== "undefined" && items.SubLblObjID !== -1) {
                                                var label_obj = item_obj.getObjectById(items.SubLblObjID);
                                                item_obj.remove(label_obj);
                                            }
                                            g_pog_json[p_pog_index].ModuleInfo[i].ShelfInfo[j].ItemInfo[k].SubLblObjID = -1;
                                        }
                                    }
                                    k = k + 1;
                                }
                            }
                        }
                        j = j + 1;
                    }
                }
                i = i + 1;
            }
        }

        const oldLabelStatus = g_itemSubLabelInd;
        const oldLabelType = g_itemSubLabel;
        details["item_sale_label_ind"] = oldLabelStatus;
        details["item_sale_label_type"] = oldLabelType;

        g_undo_details = [];
        g_undo_details.push(details);
        if (finalAction == "U") {
            g_delete_details.multi_delete_shelf_ind = "N";
            g_undo_all_obj_arr = [];

            g_undo_all_obj_arr.push(g_undo_details);
            g_undo_all_obj_arr.push(g_cut_copy_arr);
            g_undo_all_obj_arr.previousAction = "ITEM_SALE_LABEL";
            if (g_cut_support_obj_arr.length > 0) {
                g_undo_all_obj_arr.hasSupportArr = "Y";
            } else {
                g_undo_all_obj_arr.hasSupportArr = "N";
            }
            g_undo_all_obj_arr.g_MultiObjects = "N";
            g_undo_all_obj_arr.multi_delete_shelf_ind = "N";
            g_undo_final_obj_arr.push(g_undo_all_obj_arr);
            if (g_delete_details["is_dragging"] != "Y") {
                //ASA-1577
                g_delete_details = [];
            }
            g_multi_drag_shelf_arr = [];
            g_multi_drag_item_arr = [];
            g_cut_copy_arr = [];
            g_undo_details = [];
        } else {
            g_delete_details.multi_delete_shelf_ind = "N";
            g_redo_all_obj_arr = [];
            g_redo_all_obj_arr.push(g_undo_details);
            g_redo_all_obj_arr.push(g_cut_copy_arr);
            g_redo_all_obj_arr.previousAction = "ITEM_SALE_LABEL";
            if (g_cut_support_obj_arr.length > 0) {
                g_redo_all_obj_arr.hasSupportArr = "Y";
            } else {
                g_redo_all_obj_arr.hasSupportArr = "N";
            }
            g_redo_all_obj_arr.g_MultiObjects = "N";
            g_redo_all_obj_arr.multi_delete_shelf_ind = "N";
            g_redo_final_obj_arr.push(g_redo_all_obj_arr);
            if (g_delete_details["is_dragging"] != "Y") {
                //ASA-1577
                g_delete_details = [];
            }
            g_multi_drag_shelf_arr = [];
            g_multi_drag_item_arr = [];
            g_cut_copy_arr = [];
            g_undo_details = [];
        }
        g_itemSubLabelInd = p_itemLabelInd;
        g_itemSubLabel = p_subLabel;
        animate_pog(p_pog_index);
        render(p_pog_index);
    } catch (err) {
        error_handling(err);
    }
}
//this function is called for add merch. which will add red color box for each shelf showing its max merch. //ASA-1519 issue 21
function add_merch_border(p_object, p_width, p_height, p_shelf_height, p_obj_type, p_rotation, p_slope, p_maxmerch) {
    try {
        logDebug("function : add_merch_border; width : " + p_width + "; height : " + p_height + "; shelf_height : " + p_shelf_height + "; obj_type : " + p_obj_type + "; rotation : " + p_rotation + "; slope : " + p_slope, "S");
        var geometry = new THREE.BoxGeometry(p_width, p_height - 0.01, 0);
        var geo = new THREE.EdgesGeometry(geometry);
        var mat = new THREE.LineBasicMaterial({
            color: 0xff0000,
            linewidth: 2,
        });
        var wireframe = new THREE.LineSegments(geo, mat);
        wireframe.renderOrder = 1;

        p_object.add(wireframe);
        wireframe.uuid = "merch_border";
        p_object.merchid = wireframe.id;
        wireframe.position.x = 0;
        if (p_rotation !== 0 || p_slope !== 0) {
            wireframe.rotateY((p_rotation * Math.PI) / 180);
            wireframe.rotateX((p_slope * Math.PI) / 180);
        }
        if (p_obj_type == "HANGINGBAR") {
            wireframe.position.y = -(p_height / 2 + p_shelf_height / 2);
            if (p_maxmerch.Topmerch == "Y" && p_maxmerch.MaxMerch == 0) {
                p_maxmerch.Merch = 0;
            } else if (p_maxmerch.Topmerch !== "Y" && p_maxmerch.MaxMerch != 0) {
                p_maxmerch.Merch = p_maxmerch.MaxMerch;
            } else {
                p_maxmerch.Merch = wpdSetFixed(-(p_height / 2 + p_shelf_height / 2)); //ASA-1531 issue 21
            }
        } else {
            wireframe.position.y = p_height / 2 + p_shelf_height / 2 + 0.0005;
            if ((p_maxmerch.Topmerch == "Y") & (p_maxmerch.MaxMerch == 0)) {
                p_maxmerch.Merch = 0;
            } else if (p_maxmerch.Topmerch !== "Y" && p_maxmerch.MaxMerch != 0) {
                p_maxmerch.Merch = p_maxmerch.MaxMerch;
            } else {
                p_maxmerch.Merch = wpdSetFixed(p_height / 2 + p_shelf_height / 2 + 0.0005);
            } //ASA-1531 issue 21
        }
        logDebug("function : add_merch_border", "E");
    } catch (err) {
        error_handling(err);
    }
}
//this function is called for add merch. which will add red color box for each shelf showing its max merch.
async function add_merch(p_add_ind, p_pog_index) {
    //ASA-1519 issue 21
    try {
        logDebug("function : add_merch; add_ind : " + p_add_ind, "S");
        var details = {};
        var finalAction;
        if (typeof g_undoRedoAction == "undefined") {
            g_undoRedoAction = "REDO";
        }
        if (g_undoRedoAction == "REDO") {
            finalAction = "U";
        } else {
            finalAction = "R";
        }
        if (p_add_ind == "Y") {
            var module_details = g_pog_json[p_pog_index].ModuleInfo;
            $.each(module_details, function (j, Modules) {
                if (Modules.ParentModule == null || typeof Modules.ParentModule == "undefined") {
                    $.each(Modules.ShelfInfo, function (k, Shelf) {
                        if (typeof Shelf !== "undefined") {
                            if (Shelf.ObjType !== "NOTCH" && Shelf.ObjType !== "BASE" && Shelf.ObjType !== "TEXTBOX" && Shelf.ObjType !== "DIVIDER" && Shelf.ObjType !== "ROD" && Shelf.ObjType !== "PEGBOARD") {
                                if (Shelf.MaxMerch > 0) {
                                    var max_merch = Shelf.MaxMerch;
                                } else if (Shelf.X >= Modules.X - Modules.W / 2 && Shelf.X < Modules.X + Modules.W / 2 && Shelf.Y <= Modules.H + g_pog_json[p_pog_index].BaseH && Shelf.Y > 0) {
                                    var max_merch = get_module_max_merch(j, k, p_pog_index);
                                    Shelf.TOP = "Y";
                                } else if (Shelf.Y < Modules.H + g_pog_json[p_pog_index].BaseH && Shelf.Y > 0) {
                                    var max_merch = Modules.H + g_pog_json[p_pog_index].BaseH - Shelf.Y;
                                } else {
                                    var max_merch = g_default_max_merch;
                                }
                                var selected_object = g_scene_objects[p_pog_index].scene.children[2].getObjectById(Shelf.SObjID);
                                var shelf_width = 0;
                                shelf_width = Shelf.Rotation !== 0 || Shelf.Slope !== 0 ? Shelf.ShelfRotateWidth : Shelf.W;
                                var selected_object = g_scene_objects[p_pog_index].scene.children[2].getObjectById(Shelf.SObjID);
                                if (typeof selected_object.merchid !== "undefined") {
                                    var merchobj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(selected_object.merchid);
                                    if (typeof merchobj !== "undefined") {
                                        selected_object.remove(merchobj);
                                    }
                                }
                                add_merch_border(selected_object, shelf_width, max_merch, Shelf.H, Shelf.ObjType, Shelf.Rotation, Shelf.Slope, Shelf); //ASA-1531 issue 21
                            }
                        }
                    });
                }
            });
        } else {
            var module_details = g_pog_json[p_pog_index].ModuleInfo;
            $.each(module_details, function (j, Modules) {
                if (Modules.ParentModule == null || typeof Modules.ParentModule == "undefined") {
                    $.each(Modules.ShelfInfo, function (k, Shelf) {
                        if (typeof Shelf !== "undefined") {
                            if (Shelf.ObjType !== "NOTCH" && Shelf.ObjType !== "BASE" && Shelf.ObjType !== "TEXTBOX" && Shelf.ObjType !== "DIVIDER" && Shelf.ObjType !== "ROD" && Shelf.ObjType !== "PEGBOARD") {
                                var selected_object = g_scene_objects[p_pog_index].scene.children[2].getObjectById(Shelf.SObjID);
                                var merchobj = g_scene_objects[p_pog_index].scene.children[2].getObjectById(selected_object.merchid);
                                selected_object.remove(merchobj);
                            }
                        }
                    });
                }
            });
        }
        var oldStatus;
        if (p_add_ind == "Y") {
            oldStatus = "N";
        } else {
            oldStatus = "Y";
        }

        details["g_show_max_merch"] = oldStatus;
        if (typeof g_scene_objects[p_pog_index].Indicators !== "undefined") {
            g_scene_objects[p_pog_index].Indicators.MaxMerch = p_add_ind;
        }
        g_undo_details = [];
        g_undo_details.push(details);
        if (finalAction == "U") {
            g_delete_details.multi_delete_shelf_ind = "N";
            g_undo_all_obj_arr = [];

            g_undo_all_obj_arr.push(g_undo_details);
            g_undo_all_obj_arr.push(g_cut_copy_arr);
            g_undo_all_obj_arr.previousAction = "MAX_MERCH";
            if (g_cut_support_obj_arr.length > 0) {
                g_undo_all_obj_arr.hasSupportArr = "Y";
            } else {
                g_undo_all_obj_arr.hasSupportArr = "N";
            }
            g_undo_all_obj_arr.g_MultiObjects = "N";
            g_undo_all_obj_arr.multi_delete_shelf_ind = "N";
            g_undo_final_obj_arr.push(g_undo_all_obj_arr);
            g_delete_details = [];
            g_multi_drag_shelf_arr = [];
            g_multi_drag_item_arr = [];
            g_cut_copy_arr = [];
            g_undo_details = [];
        } else {
            g_delete_details.multi_delete_shelf_ind = "N";
            g_redo_all_obj_arr = [];
            g_redo_all_obj_arr.push(g_undo_details);
            g_redo_all_obj_arr.push(g_cut_copy_arr);
            g_redo_all_obj_arr.previousAction = "MAX_MERCH";
            if (g_cut_support_obj_arr.length > 0) {
                g_redo_all_obj_arr.hasSupportArr = "Y";
            } else {
                g_redo_all_obj_arr.hasSupportArr = "N";
            }
            g_redo_all_obj_arr.g_MultiObjects = "N";
            g_redo_all_obj_arr.multi_delete_shelf_ind = "N";
            g_redo_final_obj_arr.push(g_redo_all_obj_arr);
            g_delete_details = [];
            g_multi_drag_shelf_arr = [];
            g_multi_drag_item_arr = [];
            g_cut_copy_arr = [];
            g_undo_details = [];
        }
        render(p_pog_index);
        logDebug("function : add_merch", "E");
    } catch (err) {
        error_handling(err);
    }
}

// When we have fixed divider in a shelf, hypothetically it means that the shelf is divided into multiple shelfs with. As we would have different available space
// for item on the left/right side of fixed divider or between fixed dividers. The below function will divide the shelf into parts and crush according to available space between
// fixed divider start/end points and shelf start/end points
function widthCrushItemWithFixedDivider(p_pog_index, p_moduleIndex, p_shelfIndex, p_itemIndex, p_setInd) {
    try {
        var returnValue = "Y";
        var pogShelf = g_pog_json[p_pog_index].ModuleInfo[p_moduleIndex].ShelfInfo[p_shelfIndex];
        var pogShelfItems = pogShelf.ItemInfo;
        var shelfStart = wpdSetFixed(pogShelf.X - pogShelf.W / 2);
        var shelfEnd = wpdSetFixed(pogShelf.X + pogShelf.W / 2);

        var partionedShelf = []; //This will hold the parts of the shelf
        var partShelfArr = [];
        var partItemArr = [];
        var prevDividerIndx = -1,
            shelfPartStart = -1,
            shelfPartEnd = -1;
        var i = 0,
            partIndx = 0;
        var itemCrushed = "N"; //ASA-1765 Issue 6

        for (item of pogShelfItems) {
            if (item.Fixed == "Y") {
                //item.Item == "DIVIDER" &&
                if (i == 0) {
                    shelfPartStart = wpdSetFixed(item.X + item.W / 2);
                    shelfPartEnd = shelfEnd;
                    partShelfArr.AvlSpace = shelfPartEnd - shelfPartStart;
                } else {
                    partShelfArr.ItemInfo = partItemArr;
                    partItemArr = [];
                    if (partIndx == 0 && partionedShelf.length == 0) {
                        shelfPartStart = shelfStart;
                        shelfPartEnd = wpdSetFixed(item.X - item.W / 2);
                        partShelfArr.AvlSpace = shelfPartEnd - shelfPartStart;
                        partionedShelf.push(partShelfArr);
                        partShelfArr = [];
                        partIndx++;
                    } else if (partIndx > 0) {
                        shelfPartStart = pogShelfItems[prevDividerIndx].X + pogShelfItems[prevDividerIndx].W / 2;
                        shelfPartEnd = wpdSetFixed(item.X - item.W / 2);
                        partShelfArr.AvlSpace = shelfPartEnd - shelfPartStart;
                        partionedShelf.push(partShelfArr);
                        partShelfArr = [];
                        partIndx++;
                    } else {
                        console.log(pogShelfItems, partionedShelf, partShelfArr, partItemArr);
                    }
                }
                prevDividerIndx = i;
            } else {
                item.IIndex = i;
                partItemArr.push(item);
            }
            //ASA-1765 Issue 3, added nvl(partShelfArr) !== 0
            if (i == pogShelfItems.length - 1) {
                //&& nvl(partShelfArr) !== 0) {
                if (!(item.Fixed == "Y")) {
                    //item.Item == "DIVIDER" &&
                    partShelfArr.ItemInfo = partItemArr;
                    shelfPartStart = wpdSetFixed(pogShelfItems[prevDividerIndx].X + pogShelfItems[prevDividerIndx].W / 2);
                    shelfPartEnd = shelfEnd;
                    partShelfArr.AvlSpace = shelfPartEnd - shelfPartStart;
                    partionedShelf.push(partShelfArr);
                    partShelfArr = [];
                    partItemArr = [];
                } else {
                    if (nvl(partShelfArr) !== 0) {
                        //ASA-1765 Issue 6
                        shelfPartEnd = wpdSetFixed(item.X - item.W / 2);
                        partShelfArr.AvlSpace = shelfPartEnd - shelfPartStart;
                        partionedShelf.push(partShelfArr);
                    }
                }
            }
            i++;
        }
        var j = 0;
        for (partShelf of partionedShelf) {
            var crush_item_ind = "N",
                crush_index_arr = [],
                crush_width_arr = [],
                crush_manual_arr = [];
            var new_crush_perc = 0;

            var new_avilable_space = 0;

            //if (returnValue !== "N") { //ASA-1765 Issue 6
            for (items of partShelf.ItemInfo) {
                var items_crush_width = 0;
                var orientation = items.Orientation;
                var [item_owidth, item_oheight, item_odepth, wActualHeight, wActualWidth, wActualDepth] = get_new_orientation_dim(orientation, 0, 0, 0);
                var manualCrush = typeof items.MHorizCrushed == "undefined" || items.MHorizCrushed == null || items.MHorizCrushed == "N" ? "N" : "Y";
                if (wActualWidth == "W") {
                    items_crush_width = manualCrush == "N" && items.CWPerc > 0 ? items.CWPerc : items.CrushHoriz;
                } else if (wActualWidth == "H") {
                    items_crush_width = manualCrush == "N" && items.CHPerc > 0 ? items.CHPerc : items.CrushVert;
                } else if (wActualWidth == "D") {
                    items_crush_width = manualCrush == "N" && items.CDPerc > 0 ? items.CDPerc : items.CrushD;
                }
                if (items.Fixed == "N" && items_crush_width > 0) {
                    crush_item_ind = "Y";
                    crush_index_arr.push(items.IIndex);
                    crush_width_arr.push(items.W);
                    crush_manual_arr.push(manualCrush);
                }
            }
            if (crush_item_ind == "Y") {
                crush_item_ind = "N";
                for (var c = 0; c < 100; c++) {
                    var new_item_sum = 0;
                    var new_width = 0;
                    var mcrush_ind = "N";
                    for (items of partShelf.ItemInfo) {
                        var items_crush_width = 0;
                        var orientation = items.Orientation;
                        var [item_owidth, item_oheight, item_odepth, wActualHeight, wActualWidth, wActualDepth] = get_new_orientation_dim(orientation, 0, 0, 0);
                        manualCrush = typeof items.MHorizCrushed == "undefined" || items.MHorizCrushed == null || items.MHorizCrushed == "N" ? "N" : "Y";
                        if (wActualWidth == "W") {
                            items_crush_width = manualCrush == "N" && items.CWPerc > 0 ? items.CWPerc : items.CrushHoriz;
                        } else if (wActualWidth == "H") {
                            items_crush_width = manualCrush == "N" && items.CHPerc > 0 ? items.CHPerc : items.CrushVert;
                        } else if (wActualWidth == "D") {
                            items_crush_width = manualCrush == "N" && items.CDPerc > 0 ? items.CDPerc : items.CrushD;
                        }

                        //ASA-1765 Issue 3, changed to c <= items_crush_width, was i <= items_crush_width
                        if (crush_index_arr.indexOf(items.IIndex) !== -1 && c <= items_crush_width) {
                            var real_width = typeof items.RW !== "undefined" && items.RW !== null ? items.RW : items.W;
                            if (manualCrush == "N") {
                                new_width = wpdSetFixed(real_width - real_width * (c / 100));
                                if (new_width >= wpdSetFixed(real_width - real_width * (items_crush_width / 100))) {
                                    new_item_sum += new_width;
                                    if (p_setInd == "Y") {
                                        pogShelf.ItemInfo[items.IIndex].W = new_width;
                                        if (wActualWidth == "W") {
                                            pogShelf.ItemInfo[items.IIndex].CrushHoriz = c;
                                        } else if (wActualWidth == "H") {
                                            pogShelf.ItemInfo[items.IIndex].CrushVert = c;
                                        } else if (wActualWidth == "D") {
                                            pogShelf.ItemInfo[items.IIndex].CrushD = c;
                                        }
                                    }
                                } else {
                                    new_item_sum += real_width;
                                }
                            } else if (manualCrush == "Y") {
                                mcrush_ind = items_crush_width > 0 ? "Y" : "N";
                                new_width = wpdSetFixed(real_width - real_width * (items_crush_width / 100));
                                new_item_sum += new_width;
                                if (p_setInd == "Y") {
                                    pogShelf.ItemInfo[items.IIndex].W = new_width;
                                    if (wActualWidth == "W") {
                                        pogShelf.ItemInfo[items.IIndex].CrushHoriz = items_crush_width;
                                    } else if (wActualWidth == "H") {
                                        pogShelf.ItemInfo[items.IIndex].CrushVert = items_crush_width;
                                    } else if (wActualWidth == "D") {
                                        pogShelf.ItemInfo[items.IIndex].CrushD = items_crush_width;
                                    }
                                }
                            }
                        } else {
                            new_item_sum += wpdSetFixed(items.W);
                        }
                        if (pogShelf.HorizGap > 0) {
                            new_item_sum += items.SpreadItem;
                        }
                    }
                    new_avilable_space = partShelf.AvlSpace - new_item_sum; //ASA-1765 Issue 3, was partionedShelf.AvlSpace
                    if (new_avilable_space >= 0) {
                        new_crush_perc = c;
                        if (c > 0 || mcrush_ind == "Y") {
                            crush_item_ind = "Y";
                            if (p_itemIndex !== -1 && crush_index_arr.indexOf(p_itemIndex) !== -1 && p_setInd == "Y") {
                                pogShelf.ItemInfo[p_itemIndex].WChanged = "Y";
                            }
                        }
                        break;
                    }
                }
                if (crush_item_ind == "N") {
                    var k = 0;
                    if (new_crush_perc > 0) {
                        for (const items of crush_index_arr) {
                            if (crush_manual_arr[k] == "N") {
                                pogShelf.ItemInfo[crush_index_arr[k]].W = crush_width_arr[k];
                                pogShelf.ItemInfo[crush_index_arr[k]].CrushHoriz = crush_horiz_arr[k];
                            }
                            k++;
                        }
                    }
                    if (itemCrushed !== "Y") {
                        //ASA-1765 Issue 6
                        g_error_category = "W";
                        returnValue = "N";
                    }
                } else {
                    g_error_category = "";
                    returnValue = "Y";
                    itemCrushed = "Y"; //ASA-1765 Issue 6
                }
            }
            //}
            j++;
        }
        return returnValue;
    } catch (err) {
        error_handling(err);
    }
}

//ASA-1628
function autoPositionShelfVertically(pPogIndex, pModuleIndex, pShelfIndex, pShelfX, pShelfY, pShelfObjectType, pSubShelfPerc, pConsiderSubshelf = "N") {
    try {
        logDebug("function : autoPositionShelfVertically; pPogIndex:" + pPogIndex + "; pModuleIndex:" + pModuleIndex + "; pShelfIndex:" + pShelfIndex, "S");
        var sortByX = {
            X: "asc",
        };
        var currModule = g_pog_json[pPogIndex].ModuleInfo[pModuleIndex];
        var currShelf = g_pog_json[pPogIndex].ModuleInfo[pModuleIndex].ShelfInfo[pShelfIndex];
        var prevModuleIndex = -1;
        var prevRealModule = -1;
        var orderNo = 0;
        var posYchanged = true;
        var allPogModules = JSON.parse(JSON.stringify(g_pog_json[pPogIndex].ModuleInfo));
        allPogModules.keySort(sortByX);
        var i = 0;
        for (const pogModule of allPogModules) {
            if (typeof pogModule.ParentModule == "undefined" || pogModule.ParentModule == null) {
                if (orderNo == 0 && currModule.Module == pogModule.Module) {
                    return [pShelfY, notchUpdated];
                } else if (currModule.Module == pogModule.Module) {
                    prevModuleIndex = prevRealModule;
                }
                prevRealModule = i;
                orderNo++;
            }
            i++;
        }
        //ASA-1628 Issue 9
        if (prevModuleIndex == -1 && nvl(currShelf) == 0) {
            return [pShelfY, notchUpdated];
        }
        var prevModuleShelfs = allPogModules[prevModuleIndex].ShelfInfo;
        var prevModuleW = allPogModules[prevModuleIndex].W;
        var yArr = [];
        var s = 0;
        for (prevShelf of prevModuleShelfs) {
            if ((prevShelf.ObjType == "SHELF" || prevShelf.ObjType == "HANGINGBAR") && (currShelf.ObjType == "SHELF" || currShelf.ObjType == "HANGINGBAR")) {
                if (pConsiderSubshelf == "Y" || (pConsiderSubshelf == "N" && wpdSetFixed(prevShelf.W / prevModuleW.W) * 100 >= 100 - parseFloat(pSubShelfPerc))) {
                    var object = {};
                    object["Distance"] = Math.abs(wpdSetFixed(currShelf.Y - prevShelf.Y));
                    object["Indx"] = s;
                    yArr.push(object);
                }
            }
            s++;
        }
        var returnY = currShelf.Y;
        var prevShelf;
        if (yArr.length !== 0) {
            var closestShelfIndx = yArr.reduce((min, current) => (current.Distance < min.Distance ? current : min)).Indx;
            const minDistance = Math.min(...yArr.map((item) => item.Distance));
            var count = yArr.filter((item) => item.Distance === minDistance).length;
            posYchanged = count > 1 ? false : true;
            if (count == 1) {
                var closestShelfY = prevModuleShelfs[closestShelfIndx].Y + prevModuleShelfs[closestShelfIndx].H / 2;
                prevShelf = prevModuleShelfs[closestShelfIndx];
                returnY = wpdSetFixed(closestShelfY - currShelf.H / 2);
            }
        }

        var shelfHitTextbox = "N";
        //Check if shelf overlaps with any textbox
        var shlfStr = wpdSetFixed(pShelfX - currShelf.W / 2);
        var shlfEnd = wpdSetFixed(pShelfX + currShelf.W / 2);
        var shlfTop = wpdSetFixed(returnY + currShelf.H / 2);
        var shlfBtm = wpdSetFixed(returnY - currShelf.H / 2);
        if (textboxHit(pPogIndex, pModuleIndex, pShelfIndex, shlfStr, shlfEnd, shlfTop, shlfBtm, "N")) {
            returnY = pShelfY;
            posYchanged = false;
            shelfHitTextbox = "Y";
        }

        //Check if heighest item is above module top or any item overlaps with a textbox
        if (currShelf.ItemInfo.length > 0 && shelfHitTextbox == "N") {
            var itemHarr = [];
            var itemHit = "N";
            for (item of currShelf.ItemInfo) {
                itemHarr.push(wpdSetFixed(returnY + currShelf.H / 2 + item.H));
                var item_x, item_y;
                if (pShelfObjectType == "HANGINGBAR") {
                    item_x = wpdSetFixed(pShelfX - currShelf.W / 2 + item.Distance + item.W / 2);
                    item_y = wpdSetFixed(returnY - item.H / 2);
                } else {
                    item_x = wpdSetFixed(pShelfX - currShelf.W / 2 + item.Distance + item.W / 2);
                    item_y = wpdSetFixed(returnY + currShelf.H / 2 + item.H / 2);
                }
                var itemStr = wpdSetFixed(item_x - item.W / 2);
                var itemEnd = wpdSetFixed(item_x + item.W / 2);
                var itemTop = wpdSetFixed(item_y + item.H / 2);
                var itemBtm = wpdSetFixed(item_y - item.H / 2);
                if (textboxHit(pPogIndex, pModuleIndex, pShelfIndex, itemStr, itemEnd, itemTop, itemBtm)) {
                    returnY = pShelfY;
                    posYchanged = false;
                    itemHit = "Y";
                    break;
                }
            }
            if (itemHit == "N") {
                var maxItemH = Math.max(...itemHarr);
                var currModuleTop = wpdSetFixed(currModule.Y + currModule.H / 2);
                var currShelfTop = wpdSetFixed(returnY + currShelf.H / 2); //ASA-1659
                if ((maxItemH > currModuleTop && currShelf.ObjType == "SHELF") || (currShelfTop > currModuleTop && currShelf.ObjType == "HANGINGBAR")) {
                    returnY = pShelfY;
                    posYchanged = false;
                }
            }
        }

        var notchUpdated = false;
        var newNotch = -1;
        if (posYchanged) {
            if ((typeof prevShelf.NotchNo !== "undefined" || prevShelf.NotchNo !== "") && g_pog_json[pPogIndex].ModuleInfo[prevModuleIndex].NotchStart == currModule.NotchStart && g_pog_json[pPogIndex].ModuleInfo[prevModuleIndex].NotchSpacing == currModule.NotchSpacing) {
                var currShelfObject = g_scene_objects[pPogIndex].scene.children[2].getObjectById(currShelf.SObjID);
                var prevShelfObject = g_scene_objects[pPogIndex].scene.children[2].getObjectById(prevShelf.SObjID);
                if (typeof currShelfObject !== "undefined" && typeof prevShelfObject !== "undefined") {
                    currShelfObject.NotchNo = prevShelfObject.NotchNo;
                }
                newNotch = prevShelf.NotchNo;
                notchUpdated = true;
            }
        }

        logDebug("function : autoPositionShelfVertically", "E");
        return [returnY, notchUpdated, newNotch];
    } catch (err) {
        error_handling(err);
    }
}

//ASA-1628
function textboxHit(pPogIndex, pModuleIndex, pShelfIndex, pStart, pEnd, pTop, pBottom, pCompareItem = "Y") {
    try {
        var m = 0;
        for (const pogModule of g_pog_json[pPogIndex].ModuleInfo) {
            if (typeof pogModule.ParentModule == "undefined" || pogModule.ParentModule == null) {
                for (textbox of pogModule.ShelfInfo) {
                    if (textbox.ObjType == "TEXTBOX") {
                        var txtStr = wpdSetFixed(textbox.X - textbox.W / 2);
                        var txtEnd = wpdSetFixed(textbox.X + textbox.W / 2);
                        var txtTop = wpdSetFixed(textbox.Y + textbox.H / 2);
                        var txtBtm = wpdSetFixed(textbox.Y - textbox.H / 2);
                        if (!((pStart < txtStr && pEnd < txtStr) || (pStart > txtEnd && pEnd > txtEnd) || (pTop > txtTop && pBottom > txtTop) || (pTop < txtBtm && pBottom < txtBtm))) {
                            return true;
                        }
                    }
                }
                //ASA-1659
                //Check vertical hit with shelf in same module. Need to validate this before as now we are validating all the shelf after the position update
                if (pModuleIndex == m && pCompareItem == "N") {
                    var s = 0;
                    for (shelf of pogModule.ShelfInfo) {
                        if (s !== pShelfIndex && shelf.ObjType !== "BASE" && shelf.ObjType !== "NOTCH" && shelf.ObjType !== "DIVIDER" && shelf.ObjType !== "TEXTBOX") {
                            var shlfTop = wpdSetFixed(shelf.Y + shelf.H / 2);
                            var shlfBtm = wpdSetFixed(shelf.Y - shelf.H / 2);
                            var shlfStr = wpdSetFixed(shelf.X - shelf.W / 2);
                            var shlfEnd = wpdSetFixed(shelf.X + shelf.W / 2);
                            if (!((pTop > shlfTop && pBottom > shlfTop) || (pTop < shlfBtm && pBottom < shlfBtm))) {
                                if ((pStart == shlfStr && pEnd == shlfEnd) || (pStart < shlfStr && pEnd < shlfStr) || (pStart > shlfEnd && pEnd > shlfEnd)) {
                                    return true;
                                }
                            }
                        }
                        s++;
                    }
                }
            }
            m++;
        }
        return false;
    } catch (err) {
        error_handling(err);
    }
}

/*ASA - 1544 #1*/
function isShelfOnPegboard(p_shelf_x, p_shelf_y, p_module_idx, p_pog_idx, p_shelf, p_pog_json) {
    try {
        var isShelfOnPegboard = false;
        var shelfStart = wpdSetFixed(p_shelf_x - p_shelf.W / 2);
        var shelfEnd = wpdSetFixed(p_shelf_x + p_shelf.W / 2);
        var shelfTop = wpdSetFixed(p_shelf_y + p_shelf.H / 2);
        var shelfBottom = wpdSetFixed(p_shelf_y - p_shelf.H / 2);

        if (p_pog_json[p_pog_idx].ModuleInfo) { //ASA-1945 Issue3 //to check whether ModuleInfo exists or not (if statement added)
            for (const shelf of p_pog_json[p_pog_idx].ModuleInfo[p_module_idx].ShelfInfo) {
                if (shelf.ObjType == "PEGBOARD") {
                    var pbStart = wpdSetFixed(shelf.X - shelf.W / 2);
                    var pbEnd = wpdSetFixed(shelf.X + shelf.W / 2);
                    var pbTop = wpdSetFixed(shelf.Y + shelf.H / 2);
                    var pbBottom = wpdSetFixed(shelf.Y - shelf.H / 2);
                    if (pbTop >= shelfTop && shelfBottom >= pbBottom && shelfStart >= pbStart && pbEnd >= shelfEnd) {
                        isShelfOnPegboard = true;
                        break;
                    }
                }
            }
        }
        return isShelfOnPegboard;
    } catch (err) {
        error_handling(err);
    }
}

function logFinalUndoObjectsInfo(p_actionType, p_undoType, p_masterInfo, p_detailInfo, p_multiObjects, p_multiDelShelfInd, p_multiSelectDrag, p_multiselect, p_ctrlSelect, p_clearRedoLog, p_isCarpark) {
    logDebug("function : logFinalUndoObjectsInfo; actionType : " + p_actionType + "; undoType : " + p_undoType + "; p_MultiObjects : " + p_multiObjects + "; multiDelShelfInd : " + p_multiDelShelfInd + "; multiSelectDrag : " + p_multiSelectDrag + "; g_multiselect : " + p_multiselect + "; ctrlSelect : " + p_ctrlSelect + "; clearRedoLog : " + p_clearRedoLog + "; isCarpark : " + p_isCarpark, "S");
    if (p_undoType == "U") {
        g_undo_all_obj_arr = [];
        if (p_clearRedoLog == "Y") {
            g_redo_final_obj_arr = [];
        }
        g_redo_all_obj_arr = [];
        g_undo_all_obj_arr.push(p_masterInfo);
        g_undo_all_obj_arr.push(p_detailInfo);
        g_undo_all_obj_arr.previousAction = p_actionType;
        g_undo_all_obj_arr.g_MultiObjects = p_multiObjects;
        g_undo_all_obj_arr.multi_delete_shelf_ind = p_multiDelShelfInd;
        g_undo_all_obj_arr.CurrCanvas = g_curr_canvas;
        g_undo_all_obj_arr.IsCarpark = p_isCarpark;
        g_undo_final_obj_arr.push(g_undo_all_obj_arr);
        if (g_context_opened !== "Y") {
            if (g_delete_details["is_dragging"] != "Y") {
                //ASA-1577
                g_delete_details = [];
            }
            g_multi_drag_shelf_arr = [];
            g_multi_drag_item_arr = [];
        }
        g_cut_copy_arr = [];
        cut_copy_arr1 = [];
        g_undo_details = [];
        g_mselect_drag = p_multiSelectDrag;
        p_multiselect = p_multiselect;
        g_ctrl_select = p_ctrlSelect;
        g_undo_all_obj_arr = [];
        g_temp_cut_arr = [];
    } else {
        g_redo_all_obj_arr = [];
        g_redo_all_obj_arr = [];
        g_redo_all_obj_arr.push(p_masterInfo);
        g_redo_all_obj_arr.push(p_detailInfo);
        g_redo_all_obj_arr.previousAction = p_actionType;
        g_redo_all_obj_arr.g_MultiObjects = p_multiObjects;
        g_redo_all_obj_arr.CurrCanvas = g_curr_canvas;
        g_redo_all_obj_arr.IsCarpark = p_isCarpark;
        g_redo_all_obj_arr.multi_delete_shelf_ind = p_multiDelShelfInd;
        g_redo_final_obj_arr.push(g_redo_all_obj_arr);
        if (g_context_opened !== "Y") {
            if (g_delete_details["is_dragging"] != "Y") {
                //ASA-1577
                g_delete_details = [];
            }
            g_multi_drag_shelf_arr = [];
            g_multi_drag_item_arr = [];
        }
        g_cut_copy_arr = [];
        cut_copy_arr1 = [];
        g_undo_details = [];
        g_mselect_drag = p_multiSelectDrag;
        p_multiselect = p_multiselect;
        g_ctrl_select = p_ctrlSelect;
        g_undo_all_obj_arr = [];
        g_temp_cut_arr = [];
    }
    logDebug("function : logFinalUndoObjectsInfo", "E");
}

//ASA-1668
function calcCombineShelfAvlSpace(pPogIndex, pCombinationIndx) {
    try {
        logDebug("function : calcCombineShelfAvlSpace;", "S");
        var combineSpace = 0;
        var itemsSpace = 0;
        var c = 0;
        for (combineShelf of g_combinedShelfs[pCombinationIndx]) {
            var shelf = g_pog_json[pPogIndex].ModuleInfo[combineShelf.MIndex].ShelfInfo[combineShelf.SIndex];
            combineSpace += shelf.W;
            if (g_lr_overhung == "Y") {
                if (c == 0) {
                    combineSpace += nvl(shelf.LOverhang);
                }
                if (c == g_combinedShelfs[pCombinationIndx].length - 1) {
                    combineSpace += nvl(shelf.ROverhang);
                }
            }
            for (const items of shelf.ItemInfo) {
                if (typeof items.BottomObjID == "undefined" || items.BottomObjID == "") {
                    itemsSpace += items.W;
                }
            }
            c++;
        }

        var availableSpace = wpdSetFixed((combineSpace - itemsSpace) * 100);
        availableSpace = availableSpace < 0 ? 0 : availableSpace;

        var c = 0;
        for (combineShelf of g_combinedShelfs[pCombinationIndx]) {
            var shelf = g_pog_json[pPogIndex].ModuleInfo[combineShelf.MIndex].ShelfInfo[combineShelf.SIndex];
            var shelf_obj = g_scene_objects[pPogIndex].scene.children[2].getObjectById(shelf.SObjID);
            if (typeof shelf.availableSpaceObjID !== "undefined" && shelf.availableSpaceObjID !== -1) {
                //If obj is undefined in case of undo need to update
                var obj = shelf_obj.getObjectById(shelf.availableSpaceObjID);
                shelf_obj.remove(obj);
            }
            var hex_color = shelf.Color;
            if (hexToRgb(hex_color) == null) {
                var red = parseInt("FF", 16);
                var green = parseInt("FF", 16);
                var blue = parseInt("FF", 16);
            } else {
                var red = hexToRgb(hex_color).r;
                var green = hexToRgb(hex_color).r;
                var blue = hexToRgb(hex_color).g;
            }
            var text_color = getTextColor(red, green, blue);
            var return_obj = addlabelText("Space " + (c == 0 ? availableSpace : 0), g_labelFont, g_labelActualSize, text_color, "center", "");
            shelf_obj.add(return_obj);
            var shelfObj = g_scene_objects[pPogIndex].scene.children[2].getObjectById(shelf.SObjID);
            shelfObj.AvlSpace = availableSpace;
            return_obj.position.y = -0.005;
            return_obj.uuid = "fixel_space";
            if (shelf.Rotation !== 0 || shelf.Slope !== 0) {
                return_obj.position.z = shelf.D / 2 + 0.005;
            } else {
                return_obj.position.z = 0.005;
            }
            return_obj.position.x = 0 + (shelf.W / 2.4 - 0.08);
            shelf.availableSpaceObjID = return_obj.id;
            c++;
        }
        logDebug("function : calcCombineShelfAvlSpace;", "E");
    } catch (err) {
        error_handling(err);
    }
}

//ASA-1652 - Start
//ASA-1722 p_overrideZ param added
function textboxPriorityPlacing(p_sel_obj, p_pog_idx, p_manual_upd_val, p_overrideZ = "N", p_dragged="N") {
    logDebug("function : textboxPriorityPlacing", "S");
    try {
        const selTxtboxStart = wpdSetFixed(p_sel_obj.ShelfInfo.X - p_sel_obj.ShelfInfo.W / 2);
        const selTxtboxEnd = wpdSetFixed(p_sel_obj.ShelfInfo.X + p_sel_obj.ShelfInfo.W / 2);
        const selTxtboxTop = wpdSetFixed(p_sel_obj.ShelfInfo.Y + p_sel_obj.ShelfInfo.H / 2);
        const selTxtboxBottom = wpdSetFixed(p_sel_obj.ShelfInfo.Y - p_sel_obj.ShelfInfo.H / 2);
        var txtBoxInfo = [],
            shelfInfo = [];
        var isShelfHit = "N";
        var finalZ;

        for (const modInfo of g_pog_json[p_pog_idx].ModuleInfo) {
            if (typeof modInfo.ParentModule == "undefined" || modInfo.ParentModule == null) {
                for (const shelf of modInfo.ShelfInfo) {
                    if (shelf.ObjType == "TEXTBOX" && typeof g_world.getObjectById(shelf.SObjID) !== "undefined") {
                        const hitObjStart = wpdSetFixed(shelf.X - shelf.W / 2);
                        const hitObjEnd = wpdSetFixed(shelf.X + shelf.W / 2);
                        const hitObjTop = wpdSetFixed(shelf.Y + shelf.H / 2);
                        const hitObjBottom = wpdSetFixed(shelf.Y - shelf.H / 2);
                        if (selTxtboxStart < hitObjEnd && selTxtboxEnd > hitObjStart && selTxtboxTop > hitObjBottom && selTxtboxBottom < hitObjTop) {
                            txtBoxInfo.push({ shelfInfo: shelf, txtboxZ: shelf.Z, txtboxWorldZ: g_world.getObjectById(shelf.SObjID).position.z });
                        }
                    } else if (shelf.ObjType != "NOTCH") {
                        const hitObjStart = wpdSetFixed(shelf.X - shelf.W / 2);
                        const hitObjEnd = wpdSetFixed(shelf.X + shelf.W / 2);
                        const hitObjTop = wpdSetFixed(shelf.Y + shelf.H / 2);
                        const hitObjBottom = wpdSetFixed(shelf.Y - shelf.H / 2);
                        if (selTxtboxStart < hitObjEnd && selTxtboxEnd > hitObjStart && selTxtboxTop > hitObjBottom && selTxtboxBottom < hitObjTop) {
                            shelfInfo.push({ shelfInfo: shelf, shelfD: shelf.D, shelfZ: shelf.Z });
                            isShelfHit = "Y";
                        } else {
                            for (const item of shelf.ItemInfo) {
                                const hitObjStart = wpdSetFixed(item.X - item.W / 2);
                                const hitObjEnd = wpdSetFixed(item.X + item.W / 2);
                                const hitObjTop = wpdSetFixed(item.Y + item.H / 2);
                                const hitObjBottom = wpdSetFixed(item.Y - item.H / 2);
                                if (selTxtboxStart < hitObjEnd && selTxtboxEnd > hitObjStart && selTxtboxTop > hitObjBottom && selTxtboxBottom < hitObjTop) {
                                    if (nvl(item.ItemID) != 0) {
                                        shelfInfo.push({ shelfInfo: shelf, shelfD: shelf.D, shelfZ: shelf.Z });
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        //ASA-1722 Issue 1
        if (isShelfHit == "Y") {
            let filteredTxtBoxInfo = txtBoxInfo.filter((item) => item.shelfInfo.SObjID !== p_sel_obj.id);

            let maxTxtboxZ = filteredTxtBoxInfo.length > 0 ? Math.max(...filteredTxtBoxInfo.map((item) => item.txtboxZ)) : -Infinity;

            let maxShelfValue = shelfInfo.length > 0 ? Math.max(...shelfInfo.map((item) => item.shelfZ + item.shelfD / 2)) : -Infinity;

            if (maxTxtboxZ >= maxShelfValue) {
                isShelfHit = "N";
            } else {
                txtBoxInfo = [];
            }
        }

        if (p_overrideZ == "Y" && isShelfHit == "Y" && p_manual_upd_val != "undefined" && txtBoxInfo.length == 1) {
            //ASA-1722
            const sorto = {
                shelfD: "desc",
            };
            shelfInfo.keySort(sorto);
            const maxD = wpdSetFixed(shelfInfo[0].shelfZ + shelfInfo[0].shelfD / 2); //ASA-1722 Issue 2, shelfInfo[0].shelfD
            if (maxD > p_sel_obj.ShelfInfo.Z) {
                finalZ = 0.001;
            } else {
                finalZ = 0.0021;
            }
            p_sel_obj.position.z = finalZ;
        } else if (p_overrideZ != "Y") {
            if (txtBoxInfo.length > 1 && isShelfHit == "N") {
                const sorto = {
                    txtboxZ: "desc",
                    txtboxWorldZ: "desc",
                };
                txtBoxInfo.keySort(sorto);
                // //ASA-2000.2
                // if (txtBoxInfo[0].shelfInfo.Shelf == p_sel_obj.FixelID) {
                //     const hitObj = g_world.getObjectById(txtBoxInfo[0].shelfInfo.SObjID); //ASA-1804
                //     var maxz = Math.max(...txtBoxInfo.map((item) => item.txtboxWorldZ));
                //     hitObj.position.z = maxz + 0.0001; //ASA-1804
                //     return maxz + 0.0001; //txtBoxInfo[0].txtboxWorldZ;  //ASA-1804 issue 1
                // } //ASA-1722
                //ASA-2000 Issue 15 Start
                if (txtBoxInfo[0].shelfInfo.Shelf == p_sel_obj.FixelID && g_textbox_dragged == "Y") {
                    const hitObj = g_world.getObjectById(p_sel_obj.id); //ASA-1804
                    const maxWorldZ = Math.max(...txtBoxInfo.map(item => item.txtboxWorldZ));
                    const currentLogicalZ = p_sel_obj.ShelfInfo.Z;
                    const belowBoxes = txtBoxInfo.filter(item => item.shelfInfo.SObjID !== p_sel_obj.id).filter(item => item.txtboxZ <= currentLogicalZ);
                    const belowZ = belowBoxes.length? Math.max(...belowBoxes.map(item => item.txtboxZ)):currentLogicalZ;
                    p_sel_obj.ShelfInfo.Z = belowZ + 0.01;
                    hitObj.Z = (belowZ + 1) * 100;
                    hitObj.position.z = maxWorldZ + 0.0001; //ASA-1804 issue 1
                    return hitObj.position.z;
                }
                //ASA-2000 Issue 15 End
                var calcZ = txtBoxInfo[0].txtboxWorldZ,
                    prevZ = txtBoxInfo[0].txtboxWorldZ;
                var idx = 0;
                const pogJSONMaxZ = txtBoxInfo[0].txtboxZ;
                for (const txtbox of txtBoxInfo) {
                    const hitObj = g_world.getObjectById(txtbox.shelfInfo.SObjID);
                    //ASA-2000 Issue 3 Start
                    // if (txtbox.shelfInfo.SObjID == p_sel_obj.id && txtbox.shelfInfo.ManualZupdate != "Y") {                       
                    //     hitObj.Z = pogJSONMaxZ * 100 + 1;
                    //     txtbox.shelfInfo.Z = pogJSONMaxZ + 0.01;
                    //     hitObj.position.z = txtBoxInfo[0].txtboxWorldZ + 0.0001; //ASA-1722  0.00001 -> 0.0001
                    //     finalZ = txtBoxInfo[0].txtboxWorldZ + 0.0001; //ASA-1722  0.00001 -> 0.0001
                    //     break;
                    // } 
                    if (txtbox.shelfInfo.SObjID == p_sel_obj.id && txtbox.shelfInfo.ManualZupdate != "Y") {
                        const hitObj = g_world.getObjectById(txtbox.shelfInfo.SObjID);
                        const currentZ = txtbox.shelfInfo.Z;
                        let isIncrement = false;
                        for (const tbox of txtBoxInfo) {
                            if (
                                tbox.shelfInfo.SObjID !== p_sel_obj.id &&
                                tbox.shelfInfo.Z >= currentZ
                            ) {
                                isIncrement = true;
                                break;
                            }
                        }
                        if (!isIncrement) {
                            finalZ = hitObj.position.z;
                            break;
                        }
                        hitObj.Z = pogJSONMaxZ * 100 + 1;
                        txtbox.shelfInfo.Z = pogJSONMaxZ + 0.01;
                        hitObj.position.z = txtBoxInfo[0].txtboxWorldZ + 0.0001;  //ASA-1722  0.00001 -> 0.0001
                        finalZ = hitObj.position.z; //ASA-1722  0.00001 -> 0.0001
                        break;
                    }
                     //ASA-2000 Issue 3 End
                    else if (txtbox.shelfInfo.SObjID == p_sel_obj.id && txtbox.shelfInfo.ManualZupdate == "Y") {
                        hitObj.Z = typeof p_manual_upd_val == "undefined" ? hitObj.Z : p_manual_upd_val * 100;
                        txtbox.shelfInfo.Z = typeof p_manual_upd_val == "undefined" ? txtbox.shelfInfo.Z : p_manual_upd_val;
                        if (shelfInfo.length > 0) {
                            const sorto = {
                                shelfD: "desc",
                            };
                            shelfInfo.keySort(sorto);
                            const maxD = wpdSetFixed(shelfInfo[0].shelfZ + shelfInfo[0].shelfD / 2); //ASA-1722 Issue 2, shelfInfo[0].shelfD
                            if (maxD > p_manual_upd_val) {
                                calcZ = 0.001 + maxD / 1000 - 0.0001; //ASA-1652 #11       //ASA-1722  0.00001 -> 0.0001
                            } else {
                                calcZ = 0.0021;
                            }
                        }
                        hitObj.position.z = calcZ;
                        finalZ = calcZ;
                        var idx1 = 0;
                        for (const txtbox1 of txtBoxInfo) {
                            if (idx1 > idx) {
                                calcZ = calcZ - 0.0001; //ASA-1722  0.00001 -> 0.0001
                                if (g_world.getObjectById(txtbox1.shelfInfo.SObjID).position.z > calcZ) {
                                    g_world.getObjectById(txtbox1.shelfInfo.SObjID).position.z = calcZ;
                                } else {
                                    calcZ = g_world.getObjectById(txtbox1.shelfInfo.SObjID).position.z;
                                } //ASA-1652 #11
                            }
                            idx1++;
                        }
                        break;
                    }
                    idx++;
                }
            } 
            else if (typeof p_manual_upd_val != "undefined") {
                if (shelfInfo.length > 0) {
                    const sorto = {
                        shelfD: "desc",
                    };
                    shelfInfo.keySort(sorto);
                    const maxD = wpdSetFixed(shelfInfo[0].shelfZ + shelfInfo[0].shelfD / 2); //ASA-1722 Issue 2, shelfInfo[0].shelfD
                    if (maxD > p_sel_obj.ShelfInfo.Z) {
                        finalZ = 0.001;
                    } else {
                        finalZ = 0.0021;
                    }
                } else {
                    finalZ = 0.001;
                }
                p_sel_obj.position.z = finalZ;
                p_sel_obj.Z = p_manual_upd_val * 100;
                p_sel_obj.ShelfInfo.Z = p_manual_upd_val;
            } else if (shelfInfo.length > 0 && isShelfHit == "N") {
                finalZ = -1;
            } else if (isShelfHit == "Y") {
                const sorto = {
                    shelfD: "desc",
                };
                shelfInfo.keySort(sorto);
                const maxD = wpdSetFixed(shelfInfo[0].shelfZ + shelfInfo[0].shelfD / 2); //ASA-1722 Issue 2, shelfInfo[0].shelfD
                if (p_sel_obj.ShelfInfo.ManualZupdate != "Y") {
                    p_sel_obj.Z = maxD * 100 + 1;
                    p_sel_obj.ShelfInfo.Z = maxD + 0.01;
                    finalZ = 0.0021;
                } else {
                    if (maxD > p_sel_obj.ShelfInfo.Z) {
                        finalZ = 0.001;
                    } else {
                        finalZ = 0.0021;
                    }
                }
                p_sel_obj.position.z = finalZ;
            } else {
                p_sel_obj.Z = 1;
                p_sel_obj.ShelfInfo.Z = 0.01;
                p_sel_obj.position.z = 0.001;
                finalZ = 0.001;
            }
        } else if (p_overrideZ == "Y" && p_sel_obj.ShelfInfo.ManualZupdate == "Y") { //ASA-1804 added else

            if (txtBoxInfo.length > 1 && isShelfHit == "N") {
                const sorto = {
                    txtboxZ: "desc",
                };
                txtBoxInfo.keySort(sorto);
                if (txtBoxInfo[0].shelfInfo.Shelf == p_sel_obj.FixelID) {
                    const hitObj = g_world.getObjectById(txtBoxInfo[0].shelfInfo.SObjID);
                    var maxz = Math.max(...txtBoxInfo.map((item) => item.txtboxWorldZ));
                    hitObj.position.z = maxz + 0.0001;
                    return maxz + 0.0001; //txtBoxInfo[0].txtboxWorldZ; //ASA-1804 issue 1
                }
                var calcZ;
                var idx = 0;
                for (const txtbox of txtBoxInfo) {
                    const hitObj = g_world.getObjectById(txtbox.shelfInfo.SObjID);
                    var maxz = Math.max(...txtBoxInfo.map((item) => (item.txtboxZ * 100)));
                    var gmaxz = Math.max(...txtBoxInfo.map((item) => (item.txtboxWorldZ)));
                    if (txtbox.shelfInfo.SObjID == p_sel_obj.id && txtbox.shelfInfo.ManualZupdate == "Y") {
                        if (shelfInfo.length > 0) {
                            const sorto = {
                                shelfD: "desc",
                            };
                            shelfInfo.keySort(sorto);
                            const maxD = wpdSetFixed(shelfInfo[0].shelfZ + shelfInfo[0].shelfD / 2);
                            if (maxD > txtbox.txtboxZ) {
                                calcZ = 0.001 + maxD / 1000 - 0.0001;
                            } else if (maxz == txtbox.txtboxZ) {
                                calcZ = gmaxz;
                            } else if (maxz > txtbox.txtboxZ) {
                                calcZ = 0.0021 - 0.0001;
                            } else {
                                calcZ = 0.0021;
                            }
                        } else {
                            if (maxz == txtbox.txtboxZ) {
                                calcZ = gmaxz;
                            } else if (maxz > txtbox.txtboxZ) {
                                calcZ = gmaxz - 0.0001;
                            } else {
                                calcZ = 0.0021;
                            }
                        }
                        g_world.getObjectById(txtbox.shelfInfo.SObjID)
                        hitObj.position.z = calcZ;
                        finalZ = calcZ;
                        if (shelfInfo.length > 0) {
                            var idx1 = 0;
                            for (const txtbox1 of txtBoxInfo) {
                                if (idx1 > idx) {
                                    calcZ = calcZ - 0.0001;
                                    if (g_world.getObjectById(txtbox1.shelfInfo.SObjID).position.z > calcZ) {
                                        g_world.getObjectById(txtbox1.shelfInfo.SObjID).position.z = calcZ;
                                    } else {
                                        calcZ = g_world.getObjectById(txtbox1.shelfInfo.SObjID).position.z;
                                    }
                                } else {
                                    if (g_world.getObjectById(txtbox1.shelfInfo.SObjID).position.z < calcZ) {
                                        g_world.getObjectById(txtbox1.shelfInfo.SObjID).position.z = 0.0021;
                                    }
                                }
                                idx1++;
                            }
                        }
                        break;
                    }
                    idx++;
                }
            } else if (isShelfHit == "Y") {
                const sorto = {
                    shelfD: "desc",
                };
                shelfInfo.keySort(sorto);
                const maxD = wpdSetFixed(shelfInfo[0].shelfZ + shelfInfo[0].shelfD / 2);
                if (maxD > p_sel_obj.ShelfInfo.Z) {
                    finalZ = 0.001;
                } else {
                    finalZ = 0.0021;
                }
                p_sel_obj.position.z = finalZ;
            }
        } //ASA-1804 end
        return finalZ;
    } catch (err) {
        error_handling(err);
    }
}

//ASA-1652 - End

function reorderShelfWithFixedItem(pShelf, pShelfStart, pShelfEnd, pSpreadProduct, pSpreadGap, pItems) {
    try {
        var itemSplitObj = []; //This will hold array of items seperated by fixed items. Will include fixed items as well
        var currentItemFixed = "N";
        var itemSplitArr = [];
        var fixedItemArr = [];
        var splitCnt = 0;
        var i = 0;
        for (const items of pItems) {
            items.IIndex = i;
            items.ShelfSplit = pSpreadProduct == "E" || pSpreadProduct == "F" ? splitCnt : -1;
            if (items.Fixed == "Y") {
                if (items.X - items.W / 2 < pShelfStart) {
                    items.X = wpdSetFixed(pShelfStart + items.W / 2);
                } else if (items.X + items.W / 2 > pShelfEnd) {
                    items.X = wpdSetFixed(pShelfEnd - items.W / 2);
                }
                if (pSpreadProduct == "E" || pSpreadProduct == "F") {
                    itemSplitArr.push(items);
                    if (i !== 0) {
                        itemSplitObj.push(itemSplitArr);
                        splitCnt++;
                        itemSplitArr = [];
                        itemSplitArr.push(items);
                    }
                } else {
                    fixedItemArr.push(items);
                }
                currentItemFixed = "Y";
            } else {
                itemSplitArr.push(items);
                currentItemFixed = "N";
            }
            i++;
        }
        if (currentItemFixed == "N" && (pSpreadProduct == "E" || pSpreadProduct == "F")) {
            itemSplitObj.push(itemSplitArr);
        }
        const totalItemCount = pShelf.ItemInfo.length - 1;
        pShelf.ItemInfo.splice(0);
        if (pSpreadProduct == "E" || pSpreadProduct == "F") {
            var prevFixedPresent = "N";
            var s = 0;
            for (splitShelfItems of itemSplitObj) {
                var j = 0;
                var splitStart = pShelfStart;
                var splitEnd = pShelfEnd;
                for (item of splitShelfItems) {
                    if (item.Fixed == "Y") {
                        if (j == 0) {
                            splitStart = wpdSetFixed(item.X - item.W / 2);
                            firstItemFixed = "Y";
                        }

                        if (j == splitShelfItems.length - 1) {
                            splitEnd = wpdSetFixed(item.X + item.W / 2);
                        }
                    }
                    j++;
                }
                var splitAvlSpace = splitEnd - splitStart;
                var k = 0;
                for (item of splitShelfItems) {
                    if (typeof item.BottomObjID === "undefined" || item.BottomObjID === "") {
                        if (item.BHoriz > 1 && pSpreadProduct == "F") {
                            splitAvlSpace = wpdSetFixed(splitAvlSpace - (item.W + pSpreadGap * (item.BHoriz - 1)));
                        } else {
                            splitAvlSpace = wpdSetFixed(splitAvlSpace - item.W);
                        }
                        if (!(prevFixedPresent == "Y" && k == 0 && item.Fixed == "Y")) {
                            pShelf.ItemInfo.push(item);
                        }
                    }
                    k++;
                }
                var spreadItem = splitAvlSpace >= 0 ? wpdSetFixed(splitAvlSpace / (splitShelfItems.length - 1)) : 0;
                splitShelfItems.forEach((item) => {
                    if (item.ShelfSplit == s) {
                        item.SpreadItem = spreadItem;
                    }
                });
                prevFixedPresent = "Y";
                s++;
            }
        } else if (pSpreadProduct == "L") {
            var avlSpace = 0;
            var prevItemEnd = 0;
            var x = 0;
            for (var f = 0; f <= fixedItemArr.length; f++) {
                var fItem = f !== fixedItemArr.length ? fixedItemArr[f] : -1;
                if (f == 0) {
                    avlSpace = wpdSetFixed(fItem.X - fItem.W / 2 - pShelfStart);
                } else if (f < fixedItemArr.length) {
                    avlSpace = wpdSetFixed(fItem.X - fItem.W / 2 - prevItemEnd);
                } else {
                    avlSpace = wpdSetFixed(pShelfEnd - prevItemEnd);
                }
                for (item of itemSplitArr) {
                    if (item.ShelfSplit == -1) {
                        avlSpace = wpdSetFixed(avlSpace - item.W);
                        if (avlSpace > 0 || fItem == -1) {
                            item.ShelfSplit = 0;
                            item.IIndex = x;
                            pShelf.ItemInfo.push(item);
                            x++;
                        }
                    }
                }
                if (fItem !== -1) {
                    prevItemEnd = wpdSetFixed(fItem.X + fItem.W / 2);
                    fItem.IIndex = x;
                    pShelf.ItemInfo.push(fItem);
                    x++;
                }
            }
        } else if (pSpreadProduct == "R") {
            var avlSpace = 0;
            var prevItemStart = 0;
            var prevItemEnd = 0;
            var x = 0;
            for (var f = fixedItemArr.length - 1; f >= -1; f--) {
                var fItem = f !== -1 ? fixedItemArr[f] : -1;
                if (f == fixedItemArr.length - 1) {
                    avlSpace = wpdSetFixed(pShelfEnd - (fItem.X + fItem.W / 2));
                } else if (f == -1) {
                    avlSpace = wpdSetFixed(prevItemStart - pShelfStart);
                } else {
                    avlSpace = wpdSetFixed(prevItemStart - (fItem.X + fItem.W / 2));
                }

                for (var i = itemSplitArr.length - 1; i >= 0; i--) {
                    if (itemSplitArr[i].ShelfSplit == -1) {
                        avlSpace = wpdSetFixed(avlSpace - itemSplitArr[i].W);
                        if (avlSpace > 0 || fItem == -1) {
                            itemSplitArr[i].ShelfSplit = 0;
                            itemSplitArr[i].IIndex = totalItemCount - x;
                            pShelf.ItemInfo.splice(0, 0, itemSplitArr[i]);
                            x++;
                        }
                    }
                }
                if (fItem !== -1) {
                    prevItemEnd = wpdSetFixed(fItem.X + fItem.W / 2);
                    prevItemStart = wpdSetFixed(fItem.X - fItem.W / 2);
                    fItem.IIndex = totalItemCount - x;
                    pShelf.ItemInfo.splice(0, 0, fItem);
                    x++;
                }
            }
        }
        var sorto = {
            IIndex: "asc",
        };
        pShelf.ItemInfo.keySort(sorto); //ASA-1677 #3
    } catch (err) {
        error_handling(err);
    }
}

// ASA-1965 TASK 1 S Create new function for cleanup extra json tag from autofill json
function filterAutoFillJsontag(p_autoFillData) {
    const keepKeys = ["ItemID", "Item", "Desc"];
    if (!p_autoFillData || typeof p_autoFillData !== "object")
        return {};

    const cleanData = JSON.parse(JSON.stringify(p_autoFillData));

    const cleanItemKeys = (itemArray) => {
        if (!Array.isArray(itemArray))
            return;
        itemArray.forEach((item) => {
            Object.keys(item).forEach((key) => {
                if (!keepKeys.includes(key))
                    delete item[key];
            });
        });
    };

    if (Array.isArray(cleanData.BlkInfo)) {
        cleanData.BlkInfo.forEach((block) => {
            //  Remove unwanted data and keep object data only from colorObj: BlockDim > ColorObj 
            if (block.BlockDim && block.BlockDim.ColorObj) {
                const obj = block.BlockDim.ColorObj.object; // ASA-1965 Issue 5
                block.BlockDim.ColorObj = { object: obj }; 
            }
            // Path 1: BlkModInfo > moduleInfo > ShelfInfo > ItemInfo
            if (Array.isArray(block.BlkModInfo)) {
                block.BlkModInfo.forEach((modInfo) => {
                    const shelves = modInfo?.moduleInfo?.ShelfInfo;
                    if (Array.isArray(shelves)) {
                        shelves.forEach((shelf) => cleanItemKeys(shelf.ItemInfo));
                    } else if (shelves && typeof shelves === "object") {
                        cleanItemKeys(shelves.ItemInfo);
                    }
                });
            }

            // Path 2: BlkShelfInfo > ShelfInfo > ItemInfo
            if (Array.isArray(block.BlkShelfInfo)) {
                block.BlkShelfInfo.forEach((shelfBlock) => {
                    const shelfInfo = shelfBlock?.ShelfInfo;
                    if (Array.isArray(shelfInfo)) {
                        shelfInfo.forEach((shelf) => cleanItemKeys(shelf.ItemInfo));
                    } else if (shelfInfo && typeof shelfInfo === "object") {
                        cleanItemKeys(shelfInfo.ItemInfo);
                    }
                });
            }
        });
    }

    return cleanData;
}
//ASA-1965 TASK 1 E